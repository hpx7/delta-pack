// Auto-generated by DeltaPack - do not edit
using System.Linq;

namespace Generated.Examples
{
    public enum Team
    {
        RED = 0,
        BLUE = 1,
        GREEN = 2,
        YELLOW = 3
    }

    public enum PlayerStatus
    {
        ALIVE = 0,
        DEAD = 1,
        SPECTATING = 2,
        DISCONNECTED = 3
    }

    public enum WeaponType
    {
        SWORD = 0,
        BOW = 1,
        STAFF = 2,
        DAGGER = 3,
        AXE = 4
    }

    public enum ItemRarity
    {
        COMMON = 0,
        UNCOMMON = 1,
        RARE = 2,
        EPIC = 3,
        LEGENDARY = 4
    }

    public enum AbilityType
    {
        HEAL = 0,
        DAMAGE = 1,
        SHIELD = 2,
        BUFF = 3,
        DEBUFF = 4,
        TELEPORT = 5
    }

    public enum EffectType
    {
        POISON = 0,
        BURN = 1,
        FREEZE = 2,
        STUN = 3,
        REGEN = 4,
        HASTE = 5
    }

    public class Position
    {
        public float X { get; set; }
        public float Y { get; set; }

        public static Position Default() => new();

        public static Position FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                X = DeltaPack.JsonHelpers.ParseFloatQuantized(json.GetProperty("x"), 0.1f),
                Y = DeltaPack.JsonHelpers.ParseFloatQuantized(json.GetProperty("y"), 0.1f),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Position obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["x"] = obj.X;
            result["y"] = obj.Y;
            return result;
        }

        public static Position Clone(Position obj)
        {
            return new()
            {
                X = obj.X,
                Y = obj.Y,
            };
        }

        public static bool Equals(Position a, Position b)
        {
            return DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.X, b.X, 0.1f) &&
                DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.Y, b.Y, 0.1f);
        }

        public static byte[] Encode(Position obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Position obj, DeltaPack.Encoder encoder)
        {
            encoder.PushFloatQuantized(obj.X, 0.1f);
            encoder.PushFloatQuantized(obj.Y, 0.1f);
        }

        public static byte[] EncodeDiff(Position a, Position b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Position a, Position b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Position a, Position b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.X, b.X, 0.1f));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatQuantizedDiff(a.X, b.X, 0.1f);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.Y, b.Y, 0.1f));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatQuantizedDiff(a.Y, b.Y, 0.1f);
            }
        }

        public static Position Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Position Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextFloatQuantized(0.1f),
                Y = decoder.NextFloatQuantized(0.1f),
            };
        }

        public static Position DecodeDiff(Position obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Position DecodeDiff_(Position obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Position DecodeDiffFields_(Position obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextFieldDiff(obj.X, x => decoder.NextFloatQuantizedDiff(x, 0.1f)),
                Y = decoder.NextFieldDiff(obj.Y, x => decoder.NextFloatQuantizedDiff(x, 0.1f)),
            };
        }
    }

    public class Velocity
    {
        public float Vx { get; set; }
        public float Vy { get; set; }

        public static Velocity Default() => new();

        public static Velocity FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Vx = json.GetProperty("vx").GetSingle(),
                Vy = json.GetProperty("vy").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Velocity obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["vx"] = obj.Vx;
            result["vy"] = obj.Vy;
            return result;
        }

        public static Velocity Clone(Velocity obj)
        {
            return new()
            {
                Vx = obj.Vx,
                Vy = obj.Vy,
            };
        }

        public static bool Equals(Velocity a, Velocity b)
        {
            return DeltaPack.EqualityHelpers.EqualsFloat(a.Vx, b.Vx) &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.Vy, b.Vy);
        }

        public static byte[] Encode(Velocity obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Velocity obj, DeltaPack.Encoder encoder)
        {
            encoder.PushFloat(obj.Vx);
            encoder.PushFloat(obj.Vy);
        }

        public static byte[] EncodeDiff(Velocity a, Velocity b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Velocity a, Velocity b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Velocity a, Velocity b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.Vx, b.Vx));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.Vx, b.Vx);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.Vy, b.Vy));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.Vy, b.Vy);
            }
        }

        public static Velocity Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Velocity Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Vx = decoder.NextFloat(),
                Vy = decoder.NextFloat(),
            };
        }

        public static Velocity DecodeDiff(Velocity obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Velocity DecodeDiff_(Velocity obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Velocity DecodeDiffFields_(Velocity obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Vx = decoder.NextFieldDiff(obj.Vx, x => decoder.NextFloatDiff(x)),
                Vy = decoder.NextFieldDiff(obj.Vy, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class InventoryItem
    {
        public string ItemId { get; set; } = "";
        public string Name { get; set; } = "";
        public long Quantity { get; set; }
        public ItemRarity Rarity { get; set; } = ItemRarity.COMMON;
        public long? Durability { get; set; }
        public long? EnchantmentLevel { get; set; }

        public static InventoryItem Default() => new();

        public static InventoryItem FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                ItemId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("itemId")),
                Name = DeltaPack.JsonHelpers.ParseString(json.GetProperty("name")),
                Quantity = json.GetProperty("quantity").GetInt64(),
                Rarity = DeltaPack.JsonHelpers.ParseEnum<ItemRarity>(json.GetProperty("rarity")),
                Durability = json.TryGetProperty("durability", out var durabilityEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(durabilityEl) ? null : durabilityEl.GetInt64() : null,
                EnchantmentLevel = json.TryGetProperty("enchantmentLevel", out var enchantmentLevelEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(enchantmentLevelEl) ? null : enchantmentLevelEl.GetInt64() : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(InventoryItem obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["itemId"] = obj.ItemId;
            result["name"] = obj.Name;
            result["quantity"] = obj.Quantity;
            result["rarity"] = obj.Rarity.ToString();
            if (obj.Durability.HasValue) result["durability"] = obj.Durability;
            if (obj.EnchantmentLevel.HasValue) result["enchantmentLevel"] = obj.EnchantmentLevel;
            return result;
        }

        public static InventoryItem Clone(InventoryItem obj)
        {
            return new()
            {
                ItemId = obj.ItemId,
                Name = obj.Name,
                Quantity = obj.Quantity,
                Rarity = obj.Rarity,
                Durability = obj.Durability,
                EnchantmentLevel = obj.EnchantmentLevel,
            };
        }

        public static bool Equals(InventoryItem a, InventoryItem b)
        {
            return a.ItemId == b.ItemId &&
                a.Name == b.Name &&
                a.Quantity == b.Quantity &&
                a.Rarity == b.Rarity &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Durability, b.Durability, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.EnchantmentLevel, b.EnchantmentLevel, (x, y) => x == y);
        }

        public static byte[] Encode(InventoryItem obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(InventoryItem obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.ItemId);
            encoder.PushString(obj.Name);
            encoder.PushBoundedInt(obj.Quantity, 0);
            encoder.PushEnum((int)obj.Rarity, 3);
            encoder.PushBoolean(obj.Durability.HasValue);
            if (obj.Durability.HasValue) encoder.PushBoundedInt(obj.Durability.Value, 0);
            encoder.PushBoolean(obj.EnchantmentLevel.HasValue);
            if (obj.EnchantmentLevel.HasValue) encoder.PushBoundedInt(obj.EnchantmentLevel.Value, 0);
        }

        public static byte[] EncodeDiff(InventoryItem a, InventoryItem b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(InventoryItem a, InventoryItem b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(InventoryItem a, InventoryItem b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.ItemId == b.ItemId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.ItemId, b.ItemId);
            }
            {
                var changed = !(a.Name == b.Name);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.Name, b.Name);
            }
            {
                var changed = !(a.Quantity == b.Quantity);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Quantity, b.Quantity, 0);
            }
            {
                var changed = !(a.Rarity == b.Rarity);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushEnumDiff((int)a.Rarity, (int)b.Rarity, 3);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Durability, b.Durability, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<long>(a.Durability, b.Durability, x => encoder.PushBoundedInt(x, 0), (x, y) => encoder.PushBoundedIntDiff(x, y, 0));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.EnchantmentLevel, b.EnchantmentLevel, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<long>(a.EnchantmentLevel, b.EnchantmentLevel, x => encoder.PushBoundedInt(x, 0), (x, y) => encoder.PushBoundedIntDiff(x, y, 0));
            }
        }

        public static InventoryItem Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static InventoryItem Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                ItemId = decoder.NextString(),
                Name = decoder.NextString(),
                Quantity = decoder.NextBoundedInt(0),
                Rarity = (ItemRarity)decoder.NextEnum(3),
                Durability = decoder.NextBoolean() ? (long?)decoder.NextBoundedInt(0) : null,
                EnchantmentLevel = decoder.NextBoolean() ? (long?)decoder.NextBoundedInt(0) : null,
            };
        }

        public static InventoryItem DecodeDiff(InventoryItem obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static InventoryItem DecodeDiff_(InventoryItem obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static InventoryItem DecodeDiffFields_(InventoryItem obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                ItemId = decoder.NextFieldDiff(obj.ItemId, x => decoder.NextStringDiff(x)),
                Name = decoder.NextFieldDiff(obj.Name, x => decoder.NextStringDiff(x)),
                Quantity = decoder.NextFieldDiff(obj.Quantity, x => decoder.NextBoundedIntDiff(x, 0)),
                Rarity = decoder.NextFieldDiff(obj.Rarity, x => (ItemRarity)decoder.NextEnumDiff((int)x, 3)),
                Durability = decoder.NextFieldDiff(obj.Durability, x => decoder.NextOptionalDiff<long>(x, () => decoder.NextBoundedInt(0), x => decoder.NextBoundedIntDiff(x, 0))),
                EnchantmentLevel = decoder.NextFieldDiff(obj.EnchantmentLevel, x => decoder.NextOptionalDiff<long>(x, () => decoder.NextBoundedInt(0), x => decoder.NextBoundedIntDiff(x, 0))),
            };
        }
    }

    public class Equipment
    {
        public WeaponType? Weapon { get; set; }
        public string? Armor { get; set; }
        public string? Accessory1 { get; set; }
        public string? Accessory2 { get; set; }

        public static Equipment Default() => new();

        public static Equipment FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Weapon = json.TryGetProperty("weapon", out var weaponEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(weaponEl) ? null : DeltaPack.JsonHelpers.ParseEnum<WeaponType>(weaponEl) : null,
                Armor = json.TryGetProperty("armor", out var armorEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(armorEl) ? null : DeltaPack.JsonHelpers.ParseString(armorEl) : null,
                Accessory1 = json.TryGetProperty("accessory1", out var accessory1El) ? DeltaPack.JsonHelpers.IsNullOrEmpty(accessory1El) ? null : DeltaPack.JsonHelpers.ParseString(accessory1El) : null,
                Accessory2 = json.TryGetProperty("accessory2", out var accessory2El) ? DeltaPack.JsonHelpers.IsNullOrEmpty(accessory2El) ? null : DeltaPack.JsonHelpers.ParseString(accessory2El) : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Equipment obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            if (obj.Weapon.HasValue) result["weapon"] = obj.Weapon.ToString();
            if (obj.Armor != null) result["armor"] = obj.Armor;
            if (obj.Accessory1 != null) result["accessory1"] = obj.Accessory1;
            if (obj.Accessory2 != null) result["accessory2"] = obj.Accessory2;
            return result;
        }

        public static Equipment Clone(Equipment obj)
        {
            return new()
            {
                Weapon = obj.Weapon,
                Armor = obj.Armor,
                Accessory1 = obj.Accessory1,
                Accessory2 = obj.Accessory2,
            };
        }

        public static bool Equals(Equipment a, Equipment b)
        {
            return DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Weapon, b.Weapon, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.Armor, b.Armor, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.Accessory1, b.Accessory1, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.Accessory2, b.Accessory2, (x, y) => x == y);
        }

        public static byte[] Encode(Equipment obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Equipment obj, DeltaPack.Encoder encoder)
        {
            encoder.PushBoolean(obj.Weapon.HasValue);
            if (obj.Weapon.HasValue) encoder.PushEnum((int)obj.Weapon.Value, 3);
            encoder.PushOptional(obj.Armor, x => encoder.PushString(x));
            encoder.PushOptional(obj.Accessory1, x => encoder.PushString(x));
            encoder.PushOptional(obj.Accessory2, x => encoder.PushString(x));
        }

        public static byte[] EncodeDiff(Equipment a, Equipment b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Equipment a, Equipment b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Equipment a, Equipment b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Weapon, b.Weapon, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<WeaponType>(a.Weapon, b.Weapon, x => encoder.PushEnum((int)x, 3), (x, y) => encoder.PushEnumDiff((int)x, (int)y, 3));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.Armor, b.Armor, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.Armor, b.Armor, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.Accessory1, b.Accessory1, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.Accessory1, b.Accessory1, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.Accessory2, b.Accessory2, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.Accessory2, b.Accessory2, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
        }

        public static Equipment Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Equipment Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Weapon = decoder.NextBoolean() ? (WeaponType?)decoder.NextEnum(3) : null,
                Armor = decoder.NextOptional(() => decoder.NextString()),
                Accessory1 = decoder.NextOptional(() => decoder.NextString()),
                Accessory2 = decoder.NextOptional(() => decoder.NextString()),
            };
        }

        public static Equipment DecodeDiff(Equipment obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Equipment DecodeDiff_(Equipment obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Equipment DecodeDiffFields_(Equipment obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Weapon = decoder.NextFieldDiff(obj.Weapon, x => decoder.NextOptionalDiff<WeaponType>(x, () => (WeaponType)decoder.NextEnum(3), x => (WeaponType)decoder.NextEnumDiff((int)x, 3))),
                Armor = decoder.NextFieldDiff(obj.Armor, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
                Accessory1 = decoder.NextFieldDiff(obj.Accessory1, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
                Accessory2 = decoder.NextFieldDiff(obj.Accessory2, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
            };
        }
    }

    public class PlayerStats
    {
        public long Health { get; set; }
        public long MaxHealth { get; set; }
        public long Mana { get; set; }
        public long MaxMana { get; set; }
        public long Stamina { get; set; }
        public long MaxStamina { get; set; }
        public long Level { get; set; }
        public long Experience { get; set; }
        public long Strength { get; set; }
        public long Agility { get; set; }
        public long Intelligence { get; set; }
        public long Defense { get; set; }

        public static PlayerStats Default() => new();

        public static PlayerStats FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Health = json.GetProperty("health").GetInt64(),
                MaxHealth = json.GetProperty("maxHealth").GetInt64(),
                Mana = json.GetProperty("mana").GetInt64(),
                MaxMana = json.GetProperty("maxMana").GetInt64(),
                Stamina = json.GetProperty("stamina").GetInt64(),
                MaxStamina = json.GetProperty("maxStamina").GetInt64(),
                Level = json.GetProperty("level").GetInt64(),
                Experience = json.GetProperty("experience").GetInt64(),
                Strength = json.GetProperty("strength").GetInt64(),
                Agility = json.GetProperty("agility").GetInt64(),
                Intelligence = json.GetProperty("intelligence").GetInt64(),
                Defense = json.GetProperty("defense").GetInt64(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(PlayerStats obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["health"] = obj.Health;
            result["maxHealth"] = obj.MaxHealth;
            result["mana"] = obj.Mana;
            result["maxMana"] = obj.MaxMana;
            result["stamina"] = obj.Stamina;
            result["maxStamina"] = obj.MaxStamina;
            result["level"] = obj.Level;
            result["experience"] = obj.Experience;
            result["strength"] = obj.Strength;
            result["agility"] = obj.Agility;
            result["intelligence"] = obj.Intelligence;
            result["defense"] = obj.Defense;
            return result;
        }

        public static PlayerStats Clone(PlayerStats obj)
        {
            return new()
            {
                Health = obj.Health,
                MaxHealth = obj.MaxHealth,
                Mana = obj.Mana,
                MaxMana = obj.MaxMana,
                Stamina = obj.Stamina,
                MaxStamina = obj.MaxStamina,
                Level = obj.Level,
                Experience = obj.Experience,
                Strength = obj.Strength,
                Agility = obj.Agility,
                Intelligence = obj.Intelligence,
                Defense = obj.Defense,
            };
        }

        public static bool Equals(PlayerStats a, PlayerStats b)
        {
            return a.Health == b.Health &&
                a.MaxHealth == b.MaxHealth &&
                a.Mana == b.Mana &&
                a.MaxMana == b.MaxMana &&
                a.Stamina == b.Stamina &&
                a.MaxStamina == b.MaxStamina &&
                a.Level == b.Level &&
                a.Experience == b.Experience &&
                a.Strength == b.Strength &&
                a.Agility == b.Agility &&
                a.Intelligence == b.Intelligence &&
                a.Defense == b.Defense;
        }

        public static byte[] Encode(PlayerStats obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(PlayerStats obj, DeltaPack.Encoder encoder)
        {
            encoder.PushBoundedInt(obj.Health, 0);
            encoder.PushBoundedInt(obj.MaxHealth, 0);
            encoder.PushBoundedInt(obj.Mana, 0);
            encoder.PushBoundedInt(obj.MaxMana, 0);
            encoder.PushBoundedInt(obj.Stamina, 0);
            encoder.PushBoundedInt(obj.MaxStamina, 0);
            encoder.PushBoundedInt(obj.Level, 0);
            encoder.PushBoundedInt(obj.Experience, 0);
            encoder.PushBoundedInt(obj.Strength, 0);
            encoder.PushBoundedInt(obj.Agility, 0);
            encoder.PushBoundedInt(obj.Intelligence, 0);
            encoder.PushBoundedInt(obj.Defense, 0);
        }

        public static byte[] EncodeDiff(PlayerStats a, PlayerStats b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(PlayerStats a, PlayerStats b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(PlayerStats a, PlayerStats b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.Health == b.Health);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Health, b.Health, 0);
            }
            {
                var changed = !(a.MaxHealth == b.MaxHealth);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.MaxHealth, b.MaxHealth, 0);
            }
            {
                var changed = !(a.Mana == b.Mana);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Mana, b.Mana, 0);
            }
            {
                var changed = !(a.MaxMana == b.MaxMana);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.MaxMana, b.MaxMana, 0);
            }
            {
                var changed = !(a.Stamina == b.Stamina);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Stamina, b.Stamina, 0);
            }
            {
                var changed = !(a.MaxStamina == b.MaxStamina);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.MaxStamina, b.MaxStamina, 0);
            }
            {
                var changed = !(a.Level == b.Level);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Level, b.Level, 0);
            }
            {
                var changed = !(a.Experience == b.Experience);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Experience, b.Experience, 0);
            }
            {
                var changed = !(a.Strength == b.Strength);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Strength, b.Strength, 0);
            }
            {
                var changed = !(a.Agility == b.Agility);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Agility, b.Agility, 0);
            }
            {
                var changed = !(a.Intelligence == b.Intelligence);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Intelligence, b.Intelligence, 0);
            }
            {
                var changed = !(a.Defense == b.Defense);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Defense, b.Defense, 0);
            }
        }

        public static PlayerStats Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static PlayerStats Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Health = decoder.NextBoundedInt(0),
                MaxHealth = decoder.NextBoundedInt(0),
                Mana = decoder.NextBoundedInt(0),
                MaxMana = decoder.NextBoundedInt(0),
                Stamina = decoder.NextBoundedInt(0),
                MaxStamina = decoder.NextBoundedInt(0),
                Level = decoder.NextBoundedInt(0),
                Experience = decoder.NextBoundedInt(0),
                Strength = decoder.NextBoundedInt(0),
                Agility = decoder.NextBoundedInt(0),
                Intelligence = decoder.NextBoundedInt(0),
                Defense = decoder.NextBoundedInt(0),
            };
        }

        public static PlayerStats DecodeDiff(PlayerStats obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static PlayerStats DecodeDiff_(PlayerStats obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static PlayerStats DecodeDiffFields_(PlayerStats obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Health = decoder.NextFieldDiff(obj.Health, x => decoder.NextBoundedIntDiff(x, 0)),
                MaxHealth = decoder.NextFieldDiff(obj.MaxHealth, x => decoder.NextBoundedIntDiff(x, 0)),
                Mana = decoder.NextFieldDiff(obj.Mana, x => decoder.NextBoundedIntDiff(x, 0)),
                MaxMana = decoder.NextFieldDiff(obj.MaxMana, x => decoder.NextBoundedIntDiff(x, 0)),
                Stamina = decoder.NextFieldDiff(obj.Stamina, x => decoder.NextBoundedIntDiff(x, 0)),
                MaxStamina = decoder.NextFieldDiff(obj.MaxStamina, x => decoder.NextBoundedIntDiff(x, 0)),
                Level = decoder.NextFieldDiff(obj.Level, x => decoder.NextBoundedIntDiff(x, 0)),
                Experience = decoder.NextFieldDiff(obj.Experience, x => decoder.NextBoundedIntDiff(x, 0)),
                Strength = decoder.NextFieldDiff(obj.Strength, x => decoder.NextBoundedIntDiff(x, 0)),
                Agility = decoder.NextFieldDiff(obj.Agility, x => decoder.NextBoundedIntDiff(x, 0)),
                Intelligence = decoder.NextFieldDiff(obj.Intelligence, x => decoder.NextBoundedIntDiff(x, 0)),
                Defense = decoder.NextFieldDiff(obj.Defense, x => decoder.NextBoundedIntDiff(x, 0)),
            };
        }
    }

    public class ActiveEffect
    {
        public EffectType EffectType { get; set; } = EffectType.POISON;
        public float Duration { get; set; }
        public long Strength { get; set; }
        public long StackCount { get; set; }

        public static ActiveEffect Default() => new();

        public static ActiveEffect FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                EffectType = DeltaPack.JsonHelpers.ParseEnum<EffectType>(json.GetProperty("effectType")),
                Duration = json.GetProperty("duration").GetSingle(),
                Strength = json.GetProperty("strength").GetInt64(),
                StackCount = json.GetProperty("stackCount").GetInt64(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(ActiveEffect obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["effectType"] = obj.EffectType.ToString();
            result["duration"] = obj.Duration;
            result["strength"] = obj.Strength;
            result["stackCount"] = obj.StackCount;
            return result;
        }

        public static ActiveEffect Clone(ActiveEffect obj)
        {
            return new()
            {
                EffectType = obj.EffectType,
                Duration = obj.Duration,
                Strength = obj.Strength,
                StackCount = obj.StackCount,
            };
        }

        public static bool Equals(ActiveEffect a, ActiveEffect b)
        {
            return a.EffectType == b.EffectType &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.Duration, b.Duration) &&
                a.Strength == b.Strength &&
                a.StackCount == b.StackCount;
        }

        public static byte[] Encode(ActiveEffect obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(ActiveEffect obj, DeltaPack.Encoder encoder)
        {
            encoder.PushEnum((int)obj.EffectType, 3);
            encoder.PushFloat(obj.Duration);
            encoder.PushBoundedInt(obj.Strength, 0);
            encoder.PushBoundedInt(obj.StackCount, 0);
        }

        public static byte[] EncodeDiff(ActiveEffect a, ActiveEffect b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(ActiveEffect a, ActiveEffect b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(ActiveEffect a, ActiveEffect b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.EffectType == b.EffectType);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushEnumDiff((int)a.EffectType, (int)b.EffectType, 3);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.Duration, b.Duration));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.Duration, b.Duration);
            }
            {
                var changed = !(a.Strength == b.Strength);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Strength, b.Strength, 0);
            }
            {
                var changed = !(a.StackCount == b.StackCount);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.StackCount, b.StackCount, 0);
            }
        }

        public static ActiveEffect Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static ActiveEffect Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                EffectType = (EffectType)decoder.NextEnum(3),
                Duration = decoder.NextFloat(),
                Strength = decoder.NextBoundedInt(0),
                StackCount = decoder.NextBoundedInt(0),
            };
        }

        public static ActiveEffect DecodeDiff(ActiveEffect obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static ActiveEffect DecodeDiff_(ActiveEffect obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static ActiveEffect DecodeDiffFields_(ActiveEffect obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                EffectType = decoder.NextFieldDiff(obj.EffectType, x => (EffectType)decoder.NextEnumDiff((int)x, 3)),
                Duration = decoder.NextFieldDiff(obj.Duration, x => decoder.NextFloatDiff(x)),
                Strength = decoder.NextFieldDiff(obj.Strength, x => decoder.NextBoundedIntDiff(x, 0)),
                StackCount = decoder.NextFieldDiff(obj.StackCount, x => decoder.NextBoundedIntDiff(x, 0)),
            };
        }
    }

    public class AbilityCooldown
    {
        public string AbilityId { get; set; } = "";
        public AbilityType AbilityType { get; set; } = AbilityType.HEAL;
        public float RemainingCooldown { get; set; }

        public static AbilityCooldown Default() => new();

        public static AbilityCooldown FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                AbilityId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("abilityId")),
                AbilityType = DeltaPack.JsonHelpers.ParseEnum<AbilityType>(json.GetProperty("abilityType")),
                RemainingCooldown = json.GetProperty("remainingCooldown").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(AbilityCooldown obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["abilityId"] = obj.AbilityId;
            result["abilityType"] = obj.AbilityType.ToString();
            result["remainingCooldown"] = obj.RemainingCooldown;
            return result;
        }

        public static AbilityCooldown Clone(AbilityCooldown obj)
        {
            return new()
            {
                AbilityId = obj.AbilityId,
                AbilityType = obj.AbilityType,
                RemainingCooldown = obj.RemainingCooldown,
            };
        }

        public static bool Equals(AbilityCooldown a, AbilityCooldown b)
        {
            return a.AbilityId == b.AbilityId &&
                a.AbilityType == b.AbilityType &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.RemainingCooldown, b.RemainingCooldown);
        }

        public static byte[] Encode(AbilityCooldown obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(AbilityCooldown obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.AbilityId);
            encoder.PushEnum((int)obj.AbilityType, 3);
            encoder.PushFloat(obj.RemainingCooldown);
        }

        public static byte[] EncodeDiff(AbilityCooldown a, AbilityCooldown b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(AbilityCooldown a, AbilityCooldown b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(AbilityCooldown a, AbilityCooldown b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.AbilityId == b.AbilityId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.AbilityId, b.AbilityId);
            }
            {
                var changed = !(a.AbilityType == b.AbilityType);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushEnumDiff((int)a.AbilityType, (int)b.AbilityType, 3);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.RemainingCooldown, b.RemainingCooldown));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.RemainingCooldown, b.RemainingCooldown);
            }
        }

        public static AbilityCooldown Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static AbilityCooldown Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                AbilityId = decoder.NextString(),
                AbilityType = (AbilityType)decoder.NextEnum(3),
                RemainingCooldown = decoder.NextFloat(),
            };
        }

        public static AbilityCooldown DecodeDiff(AbilityCooldown obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static AbilityCooldown DecodeDiff_(AbilityCooldown obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static AbilityCooldown DecodeDiffFields_(AbilityCooldown obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                AbilityId = decoder.NextFieldDiff(obj.AbilityId, x => decoder.NextStringDiff(x)),
                AbilityType = decoder.NextFieldDiff(obj.AbilityType, x => (AbilityType)decoder.NextEnumDiff((int)x, 3)),
                RemainingCooldown = decoder.NextFieldDiff(obj.RemainingCooldown, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class Player
    {
        public string PlayerId { get; set; } = "";
        public string Username { get; set; } = "";
        public Team? Team { get; set; }
        public PlayerStatus Status { get; set; } = PlayerStatus.ALIVE;
        public Position Position { get; set; } = Position.Default();
        public Velocity Velocity { get; set; } = Velocity.Default();
        public float Rotation { get; set; }
        public PlayerStats Stats { get; set; } = PlayerStats.Default();
        public System.Collections.Generic.List<InventoryItem> Inventory { get; set; } = new System.Collections.Generic.List<InventoryItem>();
        public Equipment Equipment { get; set; } = Equipment.Default();
        public System.Collections.Generic.List<ActiveEffect> ActiveEffects { get; set; } = new System.Collections.Generic.List<ActiveEffect>();
        public System.Collections.Generic.List<AbilityCooldown> AbilityCooldowns { get; set; } = new System.Collections.Generic.List<AbilityCooldown>();
        public long Kills { get; set; }
        public long Deaths { get; set; }
        public long Assists { get; set; }
        public long Gold { get; set; }
        public long Score { get; set; }
        public long Ping { get; set; }
        public bool IsJumping { get; set; }
        public bool IsCrouching { get; set; }
        public bool IsAiming { get; set; }
        public float? LastDamageTime { get; set; }
        public float? RespawnTime { get; set; }

        public static Player Default() => new();

        public static Player FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                PlayerId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("playerId")),
                Username = DeltaPack.JsonHelpers.ParseString(json.GetProperty("username")),
                Team = json.TryGetProperty("team", out var teamEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(teamEl) ? null : DeltaPack.JsonHelpers.ParseEnum<Team>(teamEl) : null,
                Status = DeltaPack.JsonHelpers.ParseEnum<PlayerStatus>(json.GetProperty("status")),
                Position = Position.FromJson(json.GetProperty("position")),
                Velocity = Velocity.FromJson(json.GetProperty("velocity")),
                Rotation = json.GetProperty("rotation").GetSingle(),
                Stats = PlayerStats.FromJson(json.GetProperty("stats")),
                Inventory = json.GetProperty("inventory").EnumerateArray().Select(x => InventoryItem.FromJson(x)).ToList(),
                Equipment = Equipment.FromJson(json.GetProperty("equipment")),
                ActiveEffects = json.GetProperty("activeEffects").EnumerateArray().Select(x => ActiveEffect.FromJson(x)).ToList(),
                AbilityCooldowns = json.GetProperty("abilityCooldowns").EnumerateArray().Select(x => AbilityCooldown.FromJson(x)).ToList(),
                Kills = json.GetProperty("kills").GetInt64(),
                Deaths = json.GetProperty("deaths").GetInt64(),
                Assists = json.GetProperty("assists").GetInt64(),
                Gold = json.GetProperty("gold").GetInt64(),
                Score = json.GetProperty("score").GetInt64(),
                Ping = json.GetProperty("ping").GetInt64(),
                IsJumping = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isJumping")),
                IsCrouching = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isCrouching")),
                IsAiming = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isAiming")),
                LastDamageTime = json.TryGetProperty("lastDamageTime", out var lastDamageTimeEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(lastDamageTimeEl) ? null : lastDamageTimeEl.GetSingle() : null,
                RespawnTime = json.TryGetProperty("respawnTime", out var respawnTimeEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(respawnTimeEl) ? null : respawnTimeEl.GetSingle() : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Player obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["playerId"] = obj.PlayerId;
            result["username"] = obj.Username;
            if (obj.Team.HasValue) result["team"] = obj.Team.ToString();
            result["status"] = obj.Status.ToString();
            result["position"] = Position.ToJson(obj.Position);
            result["velocity"] = Velocity.ToJson(obj.Velocity);
            result["rotation"] = obj.Rotation;
            result["stats"] = PlayerStats.ToJson(obj.Stats);
            result["inventory"] = new System.Text.Json.Nodes.JsonArray(obj.Inventory.Select(x => (System.Text.Json.Nodes.JsonNode?)InventoryItem.ToJson(x)).ToArray());
            result["equipment"] = Equipment.ToJson(obj.Equipment);
            result["activeEffects"] = new System.Text.Json.Nodes.JsonArray(obj.ActiveEffects.Select(x => (System.Text.Json.Nodes.JsonNode?)ActiveEffect.ToJson(x)).ToArray());
            result["abilityCooldowns"] = new System.Text.Json.Nodes.JsonArray(obj.AbilityCooldowns.Select(x => (System.Text.Json.Nodes.JsonNode?)AbilityCooldown.ToJson(x)).ToArray());
            result["kills"] = obj.Kills;
            result["deaths"] = obj.Deaths;
            result["assists"] = obj.Assists;
            result["gold"] = obj.Gold;
            result["score"] = obj.Score;
            result["ping"] = obj.Ping;
            result["isJumping"] = obj.IsJumping;
            result["isCrouching"] = obj.IsCrouching;
            result["isAiming"] = obj.IsAiming;
            if (obj.LastDamageTime.HasValue) result["lastDamageTime"] = obj.LastDamageTime;
            if (obj.RespawnTime.HasValue) result["respawnTime"] = obj.RespawnTime;
            return result;
        }

        public static Player Clone(Player obj)
        {
            return new()
            {
                PlayerId = obj.PlayerId,
                Username = obj.Username,
                Team = obj.Team,
                Status = obj.Status,
                Position = Position.Clone(obj.Position),
                Velocity = Velocity.Clone(obj.Velocity),
                Rotation = obj.Rotation,
                Stats = PlayerStats.Clone(obj.Stats),
                Inventory = obj.Inventory.Select(x => InventoryItem.Clone(x)).ToList(),
                Equipment = Equipment.Clone(obj.Equipment),
                ActiveEffects = obj.ActiveEffects.Select(x => ActiveEffect.Clone(x)).ToList(),
                AbilityCooldowns = obj.AbilityCooldowns.Select(x => AbilityCooldown.Clone(x)).ToList(),
                Kills = obj.Kills,
                Deaths = obj.Deaths,
                Assists = obj.Assists,
                Gold = obj.Gold,
                Score = obj.Score,
                Ping = obj.Ping,
                IsJumping = obj.IsJumping,
                IsCrouching = obj.IsCrouching,
                IsAiming = obj.IsAiming,
                LastDamageTime = obj.LastDamageTime,
                RespawnTime = obj.RespawnTime,
            };
        }

        public static bool Equals(Player a, Player b)
        {
            return a.PlayerId == b.PlayerId &&
                a.Username == b.Username &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Team, b.Team, (x, y) => x == y) &&
                a.Status == b.Status &&
                Position.Equals(a.Position, b.Position) &&
                Velocity.Equals(a.Velocity, b.Velocity) &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.Rotation, b.Rotation) &&
                PlayerStats.Equals(a.Stats, b.Stats) &&
                a.Inventory.Count == b.Inventory.Count && a.Inventory.Zip(b.Inventory).All(pair => InventoryItem.Equals(pair.First, pair.Second)) &&
                Equipment.Equals(a.Equipment, b.Equipment) &&
                a.ActiveEffects.Count == b.ActiveEffects.Count && a.ActiveEffects.Zip(b.ActiveEffects).All(pair => ActiveEffect.Equals(pair.First, pair.Second)) &&
                a.AbilityCooldowns.Count == b.AbilityCooldowns.Count && a.AbilityCooldowns.Zip(b.AbilityCooldowns).All(pair => AbilityCooldown.Equals(pair.First, pair.Second)) &&
                a.Kills == b.Kills &&
                a.Deaths == b.Deaths &&
                a.Assists == b.Assists &&
                a.Gold == b.Gold &&
                a.Score == b.Score &&
                a.Ping == b.Ping &&
                a.IsJumping == b.IsJumping &&
                a.IsCrouching == b.IsCrouching &&
                a.IsAiming == b.IsAiming &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.LastDamageTime, b.LastDamageTime, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y)) &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.RespawnTime, b.RespawnTime, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y));
        }

        public static byte[] Encode(Player obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Player obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.PlayerId);
            encoder.PushString(obj.Username);
            encoder.PushBoolean(obj.Team.HasValue);
            if (obj.Team.HasValue) encoder.PushEnum((int)obj.Team.Value, 2);
            encoder.PushEnum((int)obj.Status, 2);
            Position.Encode_(obj.Position, encoder);
            Velocity.Encode_(obj.Velocity, encoder);
            encoder.PushFloat(obj.Rotation);
            PlayerStats.Encode_(obj.Stats, encoder);
            encoder.PushArray(obj.Inventory, x => InventoryItem.Encode_(x, encoder));
            Equipment.Encode_(obj.Equipment, encoder);
            encoder.PushArray(obj.ActiveEffects, x => ActiveEffect.Encode_(x, encoder));
            encoder.PushArray(obj.AbilityCooldowns, x => AbilityCooldown.Encode_(x, encoder));
            encoder.PushBoundedInt(obj.Kills, 0);
            encoder.PushBoundedInt(obj.Deaths, 0);
            encoder.PushBoundedInt(obj.Assists, 0);
            encoder.PushBoundedInt(obj.Gold, 0);
            encoder.PushInt(obj.Score);
            encoder.PushBoundedInt(obj.Ping, 0);
            encoder.PushBoolean(obj.IsJumping);
            encoder.PushBoolean(obj.IsCrouching);
            encoder.PushBoolean(obj.IsAiming);
            encoder.PushBoolean(obj.LastDamageTime.HasValue);
            if (obj.LastDamageTime.HasValue) encoder.PushFloat(obj.LastDamageTime.Value);
            encoder.PushBoolean(obj.RespawnTime.HasValue);
            if (obj.RespawnTime.HasValue) encoder.PushFloat(obj.RespawnTime.Value);
        }

        public static byte[] EncodeDiff(Player a, Player b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Player a, Player b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Player a, Player b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.PlayerId == b.PlayerId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.PlayerId, b.PlayerId);
            }
            {
                var changed = !(a.Username == b.Username);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.Username, b.Username);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Team, b.Team, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<Team>(a.Team, b.Team, x => encoder.PushEnum((int)x, 2), (x, y) => encoder.PushEnumDiff((int)x, (int)y, 2));
            }
            {
                var changed = !(a.Status == b.Status);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushEnumDiff((int)a.Status, (int)b.Status, 2);
            }
            Position.EncodeDiff_(a.Position, b.Position, encoder);
            Velocity.EncodeDiff_(a.Velocity, b.Velocity, encoder);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.Rotation, b.Rotation));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.Rotation, b.Rotation);
            }
            PlayerStats.EncodeDiff_(a.Stats, b.Stats, encoder);
            {
                var changed = !(a.Inventory.Count == b.Inventory.Count && a.Inventory.Zip(b.Inventory).All(pair => InventoryItem.Equals(pair.First, pair.Second)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushArrayDiff<InventoryItem>(a.Inventory, b.Inventory, (x, y) => InventoryItem.Equals(x, y), x => InventoryItem.Encode_(x, encoder), (x, y) => InventoryItem.EncodeDiffFields_(x, y, encoder));
            }
            Equipment.EncodeDiff_(a.Equipment, b.Equipment, encoder);
            {
                var changed = !(a.ActiveEffects.Count == b.ActiveEffects.Count && a.ActiveEffects.Zip(b.ActiveEffects).All(pair => ActiveEffect.Equals(pair.First, pair.Second)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushArrayDiff<ActiveEffect>(a.ActiveEffects, b.ActiveEffects, (x, y) => ActiveEffect.Equals(x, y), x => ActiveEffect.Encode_(x, encoder), (x, y) => ActiveEffect.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.AbilityCooldowns.Count == b.AbilityCooldowns.Count && a.AbilityCooldowns.Zip(b.AbilityCooldowns).All(pair => AbilityCooldown.Equals(pair.First, pair.Second)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushArrayDiff<AbilityCooldown>(a.AbilityCooldowns, b.AbilityCooldowns, (x, y) => AbilityCooldown.Equals(x, y), x => AbilityCooldown.Encode_(x, encoder), (x, y) => AbilityCooldown.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.Kills == b.Kills);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Kills, b.Kills, 0);
            }
            {
                var changed = !(a.Deaths == b.Deaths);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Deaths, b.Deaths, 0);
            }
            {
                var changed = !(a.Assists == b.Assists);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Assists, b.Assists, 0);
            }
            {
                var changed = !(a.Gold == b.Gold);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Gold, b.Gold, 0);
            }
            {
                var changed = !(a.Score == b.Score);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushIntDiff(a.Score, b.Score);
            }
            {
                var changed = !(a.Ping == b.Ping);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Ping, b.Ping, 0);
            }
            encoder.PushBooleanDiff(a.IsJumping, b.IsJumping);
            encoder.PushBooleanDiff(a.IsCrouching, b.IsCrouching);
            encoder.PushBooleanDiff(a.IsAiming, b.IsAiming);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.LastDamageTime, b.LastDamageTime, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<float>(a.LastDamageTime, b.LastDamageTime, x => encoder.PushFloat(x), (x, y) => encoder.PushFloatDiff(x, y));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.RespawnTime, b.RespawnTime, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<float>(a.RespawnTime, b.RespawnTime, x => encoder.PushFloat(x), (x, y) => encoder.PushFloatDiff(x, y));
            }
        }

        public static Player Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Player Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                PlayerId = decoder.NextString(),
                Username = decoder.NextString(),
                Team = decoder.NextBoolean() ? (Team?)decoder.NextEnum(2) : null,
                Status = (PlayerStatus)decoder.NextEnum(2),
                Position = Position.Decode_(decoder),
                Velocity = Velocity.Decode_(decoder),
                Rotation = decoder.NextFloat(),
                Stats = PlayerStats.Decode_(decoder),
                Inventory = decoder.NextArray(() => InventoryItem.Decode_(decoder)),
                Equipment = Equipment.Decode_(decoder),
                ActiveEffects = decoder.NextArray(() => ActiveEffect.Decode_(decoder)),
                AbilityCooldowns = decoder.NextArray(() => AbilityCooldown.Decode_(decoder)),
                Kills = decoder.NextBoundedInt(0),
                Deaths = decoder.NextBoundedInt(0),
                Assists = decoder.NextBoundedInt(0),
                Gold = decoder.NextBoundedInt(0),
                Score = decoder.NextInt(),
                Ping = decoder.NextBoundedInt(0),
                IsJumping = decoder.NextBoolean(),
                IsCrouching = decoder.NextBoolean(),
                IsAiming = decoder.NextBoolean(),
                LastDamageTime = decoder.NextBoolean() ? (float?)decoder.NextFloat() : null,
                RespawnTime = decoder.NextBoolean() ? (float?)decoder.NextFloat() : null,
            };
        }

        public static Player DecodeDiff(Player obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Player DecodeDiff_(Player obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Player DecodeDiffFields_(Player obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                PlayerId = decoder.NextFieldDiff(obj.PlayerId, x => decoder.NextStringDiff(x)),
                Username = decoder.NextFieldDiff(obj.Username, x => decoder.NextStringDiff(x)),
                Team = decoder.NextFieldDiff(obj.Team, x => decoder.NextOptionalDiff<Team>(x, () => (Team)decoder.NextEnum(2), x => (Team)decoder.NextEnumDiff((int)x, 2))),
                Status = decoder.NextFieldDiff(obj.Status, x => (PlayerStatus)decoder.NextEnumDiff((int)x, 2)),
                Position = Position.DecodeDiff_(obj.Position, decoder),
                Velocity = Velocity.DecodeDiff_(obj.Velocity, decoder),
                Rotation = decoder.NextFieldDiff(obj.Rotation, x => decoder.NextFloatDiff(x)),
                Stats = PlayerStats.DecodeDiff_(obj.Stats, decoder),
                Inventory = decoder.NextFieldDiff(obj.Inventory, x => decoder.NextArrayDiff<InventoryItem>(x, () => InventoryItem.Decode_(decoder), x => InventoryItem.DecodeDiffFields_(x, decoder))),
                Equipment = Equipment.DecodeDiff_(obj.Equipment, decoder),
                ActiveEffects = decoder.NextFieldDiff(obj.ActiveEffects, x => decoder.NextArrayDiff<ActiveEffect>(x, () => ActiveEffect.Decode_(decoder), x => ActiveEffect.DecodeDiffFields_(x, decoder))),
                AbilityCooldowns = decoder.NextFieldDiff(obj.AbilityCooldowns, x => decoder.NextArrayDiff<AbilityCooldown>(x, () => AbilityCooldown.Decode_(decoder), x => AbilityCooldown.DecodeDiffFields_(x, decoder))),
                Kills = decoder.NextFieldDiff(obj.Kills, x => decoder.NextBoundedIntDiff(x, 0)),
                Deaths = decoder.NextFieldDiff(obj.Deaths, x => decoder.NextBoundedIntDiff(x, 0)),
                Assists = decoder.NextFieldDiff(obj.Assists, x => decoder.NextBoundedIntDiff(x, 0)),
                Gold = decoder.NextFieldDiff(obj.Gold, x => decoder.NextBoundedIntDiff(x, 0)),
                Score = decoder.NextFieldDiff(obj.Score, x => decoder.NextIntDiff(x)),
                Ping = decoder.NextFieldDiff(obj.Ping, x => decoder.NextBoundedIntDiff(x, 0)),
                IsJumping = decoder.NextBooleanDiff(obj.IsJumping),
                IsCrouching = decoder.NextBooleanDiff(obj.IsCrouching),
                IsAiming = decoder.NextBooleanDiff(obj.IsAiming),
                LastDamageTime = decoder.NextFieldDiff(obj.LastDamageTime, x => decoder.NextOptionalDiff<float>(x, () => decoder.NextFloat(), x => decoder.NextFloatDiff(x))),
                RespawnTime = decoder.NextFieldDiff(obj.RespawnTime, x => decoder.NextOptionalDiff<float>(x, () => decoder.NextFloat(), x => decoder.NextFloatDiff(x))),
            };
        }
    }

    public class Enemy
    {
        public string EnemyId { get; set; } = "";
        public string Name { get; set; } = "";
        public Position Position { get; set; } = Position.Default();
        public Velocity Velocity { get; set; } = Velocity.Default();
        public long Health { get; set; }
        public long MaxHealth { get; set; }
        public long Level { get; set; }
        public bool IsAggro { get; set; }
        public string? TargetPlayerId { get; set; }
        public float LastAttackTime { get; set; }
        public string? LootTableId { get; set; }

        public static Enemy Default() => new();

        public static Enemy FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                EnemyId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("enemyId")),
                Name = DeltaPack.JsonHelpers.ParseString(json.GetProperty("name")),
                Position = Position.FromJson(json.GetProperty("position")),
                Velocity = Velocity.FromJson(json.GetProperty("velocity")),
                Health = json.GetProperty("health").GetInt64(),
                MaxHealth = json.GetProperty("maxHealth").GetInt64(),
                Level = json.GetProperty("level").GetInt64(),
                IsAggro = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isAggro")),
                TargetPlayerId = json.TryGetProperty("targetPlayerId", out var targetPlayerIdEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(targetPlayerIdEl) ? null : DeltaPack.JsonHelpers.ParseString(targetPlayerIdEl) : null,
                LastAttackTime = json.GetProperty("lastAttackTime").GetSingle(),
                LootTableId = json.TryGetProperty("lootTableId", out var lootTableIdEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(lootTableIdEl) ? null : DeltaPack.JsonHelpers.ParseString(lootTableIdEl) : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Enemy obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["enemyId"] = obj.EnemyId;
            result["name"] = obj.Name;
            result["position"] = Position.ToJson(obj.Position);
            result["velocity"] = Velocity.ToJson(obj.Velocity);
            result["health"] = obj.Health;
            result["maxHealth"] = obj.MaxHealth;
            result["level"] = obj.Level;
            result["isAggro"] = obj.IsAggro;
            if (obj.TargetPlayerId != null) result["targetPlayerId"] = obj.TargetPlayerId;
            result["lastAttackTime"] = obj.LastAttackTime;
            if (obj.LootTableId != null) result["lootTableId"] = obj.LootTableId;
            return result;
        }

        public static Enemy Clone(Enemy obj)
        {
            return new()
            {
                EnemyId = obj.EnemyId,
                Name = obj.Name,
                Position = Position.Clone(obj.Position),
                Velocity = Velocity.Clone(obj.Velocity),
                Health = obj.Health,
                MaxHealth = obj.MaxHealth,
                Level = obj.Level,
                IsAggro = obj.IsAggro,
                TargetPlayerId = obj.TargetPlayerId,
                LastAttackTime = obj.LastAttackTime,
                LootTableId = obj.LootTableId,
            };
        }

        public static bool Equals(Enemy a, Enemy b)
        {
            return a.EnemyId == b.EnemyId &&
                a.Name == b.Name &&
                Position.Equals(a.Position, b.Position) &&
                Velocity.Equals(a.Velocity, b.Velocity) &&
                a.Health == b.Health &&
                a.MaxHealth == b.MaxHealth &&
                a.Level == b.Level &&
                a.IsAggro == b.IsAggro &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.TargetPlayerId, b.TargetPlayerId, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.LastAttackTime, b.LastAttackTime) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.LootTableId, b.LootTableId, (x, y) => x == y);
        }

        public static byte[] Encode(Enemy obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Enemy obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.EnemyId);
            encoder.PushString(obj.Name);
            Position.Encode_(obj.Position, encoder);
            Velocity.Encode_(obj.Velocity, encoder);
            encoder.PushBoundedInt(obj.Health, 0);
            encoder.PushBoundedInt(obj.MaxHealth, 0);
            encoder.PushBoundedInt(obj.Level, 0);
            encoder.PushBoolean(obj.IsAggro);
            encoder.PushOptional(obj.TargetPlayerId, x => encoder.PushString(x));
            encoder.PushFloat(obj.LastAttackTime);
            encoder.PushOptional(obj.LootTableId, x => encoder.PushString(x));
        }

        public static byte[] EncodeDiff(Enemy a, Enemy b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Enemy a, Enemy b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Enemy a, Enemy b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.EnemyId == b.EnemyId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.EnemyId, b.EnemyId);
            }
            {
                var changed = !(a.Name == b.Name);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.Name, b.Name);
            }
            Position.EncodeDiff_(a.Position, b.Position, encoder);
            Velocity.EncodeDiff_(a.Velocity, b.Velocity, encoder);
            {
                var changed = !(a.Health == b.Health);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Health, b.Health, 0);
            }
            {
                var changed = !(a.MaxHealth == b.MaxHealth);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.MaxHealth, b.MaxHealth, 0);
            }
            {
                var changed = !(a.Level == b.Level);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Level, b.Level, 0);
            }
            encoder.PushBooleanDiff(a.IsAggro, b.IsAggro);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.TargetPlayerId, b.TargetPlayerId, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.TargetPlayerId, b.TargetPlayerId, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.LastAttackTime, b.LastAttackTime));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.LastAttackTime, b.LastAttackTime);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.LootTableId, b.LootTableId, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.LootTableId, b.LootTableId, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
        }

        public static Enemy Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Enemy Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                EnemyId = decoder.NextString(),
                Name = decoder.NextString(),
                Position = Position.Decode_(decoder),
                Velocity = Velocity.Decode_(decoder),
                Health = decoder.NextBoundedInt(0),
                MaxHealth = decoder.NextBoundedInt(0),
                Level = decoder.NextBoundedInt(0),
                IsAggro = decoder.NextBoolean(),
                TargetPlayerId = decoder.NextOptional(() => decoder.NextString()),
                LastAttackTime = decoder.NextFloat(),
                LootTableId = decoder.NextOptional(() => decoder.NextString()),
            };
        }

        public static Enemy DecodeDiff(Enemy obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Enemy DecodeDiff_(Enemy obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Enemy DecodeDiffFields_(Enemy obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                EnemyId = decoder.NextFieldDiff(obj.EnemyId, x => decoder.NextStringDiff(x)),
                Name = decoder.NextFieldDiff(obj.Name, x => decoder.NextStringDiff(x)),
                Position = Position.DecodeDiff_(obj.Position, decoder),
                Velocity = Velocity.DecodeDiff_(obj.Velocity, decoder),
                Health = decoder.NextFieldDiff(obj.Health, x => decoder.NextBoundedIntDiff(x, 0)),
                MaxHealth = decoder.NextFieldDiff(obj.MaxHealth, x => decoder.NextBoundedIntDiff(x, 0)),
                Level = decoder.NextFieldDiff(obj.Level, x => decoder.NextBoundedIntDiff(x, 0)),
                IsAggro = decoder.NextBooleanDiff(obj.IsAggro),
                TargetPlayerId = decoder.NextFieldDiff(obj.TargetPlayerId, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
                LastAttackTime = decoder.NextFieldDiff(obj.LastAttackTime, x => decoder.NextFloatDiff(x)),
                LootTableId = decoder.NextFieldDiff(obj.LootTableId, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
            };
        }
    }

    public class Projectile
    {
        public string ProjectileId { get; set; } = "";
        public string OwnerId { get; set; } = "";
        public Position Position { get; set; } = Position.Default();
        public Velocity Velocity { get; set; } = Velocity.Default();
        public long Damage { get; set; }
        public long Penetration { get; set; }
        public float TimeToLive { get; set; }
        public System.Collections.Generic.List<string> HitPlayers { get; set; } = new System.Collections.Generic.List<string>();

        public static Projectile Default() => new();

        public static Projectile FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                ProjectileId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("projectileId")),
                OwnerId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("ownerId")),
                Position = Position.FromJson(json.GetProperty("position")),
                Velocity = Velocity.FromJson(json.GetProperty("velocity")),
                Damage = json.GetProperty("damage").GetInt64(),
                Penetration = json.GetProperty("penetration").GetInt64(),
                TimeToLive = json.GetProperty("timeToLive").GetSingle(),
                HitPlayers = json.GetProperty("hitPlayers").EnumerateArray().Select(x => DeltaPack.JsonHelpers.ParseString(x)).ToList(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Projectile obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["projectileId"] = obj.ProjectileId;
            result["ownerId"] = obj.OwnerId;
            result["position"] = Position.ToJson(obj.Position);
            result["velocity"] = Velocity.ToJson(obj.Velocity);
            result["damage"] = obj.Damage;
            result["penetration"] = obj.Penetration;
            result["timeToLive"] = obj.TimeToLive;
            result["hitPlayers"] = new System.Text.Json.Nodes.JsonArray(obj.HitPlayers.Select(x => (System.Text.Json.Nodes.JsonNode?)x).ToArray());
            return result;
        }

        public static Projectile Clone(Projectile obj)
        {
            return new()
            {
                ProjectileId = obj.ProjectileId,
                OwnerId = obj.OwnerId,
                Position = Position.Clone(obj.Position),
                Velocity = Velocity.Clone(obj.Velocity),
                Damage = obj.Damage,
                Penetration = obj.Penetration,
                TimeToLive = obj.TimeToLive,
                HitPlayers = new System.Collections.Generic.List<string>(obj.HitPlayers),
            };
        }

        public static bool Equals(Projectile a, Projectile b)
        {
            return a.ProjectileId == b.ProjectileId &&
                a.OwnerId == b.OwnerId &&
                Position.Equals(a.Position, b.Position) &&
                Velocity.Equals(a.Velocity, b.Velocity) &&
                a.Damage == b.Damage &&
                a.Penetration == b.Penetration &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.TimeToLive, b.TimeToLive) &&
                a.HitPlayers.Count == b.HitPlayers.Count && a.HitPlayers.Zip(b.HitPlayers).All(pair => pair.First == pair.Second);
        }

        public static byte[] Encode(Projectile obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Projectile obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.ProjectileId);
            encoder.PushString(obj.OwnerId);
            Position.Encode_(obj.Position, encoder);
            Velocity.Encode_(obj.Velocity, encoder);
            encoder.PushBoundedInt(obj.Damage, 0);
            encoder.PushBoundedInt(obj.Penetration, 0);
            encoder.PushFloat(obj.TimeToLive);
            encoder.PushArray(obj.HitPlayers, x => encoder.PushString(x));
        }

        public static byte[] EncodeDiff(Projectile a, Projectile b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Projectile a, Projectile b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(Projectile a, Projectile b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.ProjectileId == b.ProjectileId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.ProjectileId, b.ProjectileId);
            }
            {
                var changed = !(a.OwnerId == b.OwnerId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.OwnerId, b.OwnerId);
            }
            Position.EncodeDiff_(a.Position, b.Position, encoder);
            Velocity.EncodeDiff_(a.Velocity, b.Velocity, encoder);
            {
                var changed = !(a.Damage == b.Damage);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Damage, b.Damage, 0);
            }
            {
                var changed = !(a.Penetration == b.Penetration);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Penetration, b.Penetration, 0);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.TimeToLive, b.TimeToLive));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.TimeToLive, b.TimeToLive);
            }
            {
                var changed = !(a.HitPlayers.Count == b.HitPlayers.Count && a.HitPlayers.Zip(b.HitPlayers).All(pair => pair.First == pair.Second));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushArrayDiff<string>(a.HitPlayers, b.HitPlayers, (x, y) => x == y, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
        }

        public static Projectile Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Projectile Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                ProjectileId = decoder.NextString(),
                OwnerId = decoder.NextString(),
                Position = Position.Decode_(decoder),
                Velocity = Velocity.Decode_(decoder),
                Damage = decoder.NextBoundedInt(0),
                Penetration = decoder.NextBoundedInt(0),
                TimeToLive = decoder.NextFloat(),
                HitPlayers = decoder.NextArray(() => decoder.NextString()),
            };
        }

        public static Projectile DecodeDiff(Projectile obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static Projectile DecodeDiff_(Projectile obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static Projectile DecodeDiffFields_(Projectile obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                ProjectileId = decoder.NextFieldDiff(obj.ProjectileId, x => decoder.NextStringDiff(x)),
                OwnerId = decoder.NextFieldDiff(obj.OwnerId, x => decoder.NextStringDiff(x)),
                Position = Position.DecodeDiff_(obj.Position, decoder),
                Velocity = Velocity.DecodeDiff_(obj.Velocity, decoder),
                Damage = decoder.NextFieldDiff(obj.Damage, x => decoder.NextBoundedIntDiff(x, 0)),
                Penetration = decoder.NextFieldDiff(obj.Penetration, x => decoder.NextBoundedIntDiff(x, 0)),
                TimeToLive = decoder.NextFieldDiff(obj.TimeToLive, x => decoder.NextFloatDiff(x)),
                HitPlayers = decoder.NextFieldDiff(obj.HitPlayers, x => decoder.NextArrayDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
            };
        }
    }

    public class DroppedLoot
    {
        public string LootId { get; set; } = "";
        public Position Position { get; set; } = Position.Default();
        public InventoryItem Item { get; set; } = InventoryItem.Default();
        public float DespawnTime { get; set; }

        public static DroppedLoot Default() => new();

        public static DroppedLoot FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                LootId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("lootId")),
                Position = Position.FromJson(json.GetProperty("position")),
                Item = InventoryItem.FromJson(json.GetProperty("item")),
                DespawnTime = json.GetProperty("despawnTime").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(DroppedLoot obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["lootId"] = obj.LootId;
            result["position"] = Position.ToJson(obj.Position);
            result["item"] = InventoryItem.ToJson(obj.Item);
            result["despawnTime"] = obj.DespawnTime;
            return result;
        }

        public static DroppedLoot Clone(DroppedLoot obj)
        {
            return new()
            {
                LootId = obj.LootId,
                Position = Position.Clone(obj.Position),
                Item = InventoryItem.Clone(obj.Item),
                DespawnTime = obj.DespawnTime,
            };
        }

        public static bool Equals(DroppedLoot a, DroppedLoot b)
        {
            return a.LootId == b.LootId &&
                Position.Equals(a.Position, b.Position) &&
                InventoryItem.Equals(a.Item, b.Item) &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.DespawnTime, b.DespawnTime);
        }

        public static byte[] Encode(DroppedLoot obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(DroppedLoot obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.LootId);
            Position.Encode_(obj.Position, encoder);
            InventoryItem.Encode_(obj.Item, encoder);
            encoder.PushFloat(obj.DespawnTime);
        }

        public static byte[] EncodeDiff(DroppedLoot a, DroppedLoot b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(DroppedLoot a, DroppedLoot b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(DroppedLoot a, DroppedLoot b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.LootId == b.LootId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.LootId, b.LootId);
            }
            Position.EncodeDiff_(a.Position, b.Position, encoder);
            InventoryItem.EncodeDiff_(a.Item, b.Item, encoder);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.DespawnTime, b.DespawnTime));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.DespawnTime, b.DespawnTime);
            }
        }

        public static DroppedLoot Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static DroppedLoot Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                LootId = decoder.NextString(),
                Position = Position.Decode_(decoder),
                Item = InventoryItem.Decode_(decoder),
                DespawnTime = decoder.NextFloat(),
            };
        }

        public static DroppedLoot DecodeDiff(DroppedLoot obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static DroppedLoot DecodeDiff_(DroppedLoot obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static DroppedLoot DecodeDiffFields_(DroppedLoot obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                LootId = decoder.NextFieldDiff(obj.LootId, x => decoder.NextStringDiff(x)),
                Position = Position.DecodeDiff_(obj.Position, decoder),
                Item = InventoryItem.DecodeDiff_(obj.Item, decoder),
                DespawnTime = decoder.NextFieldDiff(obj.DespawnTime, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class WorldObject
    {
        public string ObjectId { get; set; } = "";
        public string ObjectType { get; set; } = "";
        public Position Position { get; set; } = Position.Default();
        public long? Health { get; set; }
        public bool IsDestroyed { get; set; }
        public bool IsInteractable { get; set; }
        public string? InteractedBy { get; set; }

        public static WorldObject Default() => new();

        public static WorldObject FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                ObjectId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("objectId")),
                ObjectType = DeltaPack.JsonHelpers.ParseString(json.GetProperty("objectType")),
                Position = Position.FromJson(json.GetProperty("position")),
                Health = json.TryGetProperty("health", out var healthEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(healthEl) ? null : healthEl.GetInt64() : null,
                IsDestroyed = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isDestroyed")),
                IsInteractable = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isInteractable")),
                InteractedBy = json.TryGetProperty("interactedBy", out var interactedByEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(interactedByEl) ? null : DeltaPack.JsonHelpers.ParseString(interactedByEl) : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(WorldObject obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["objectId"] = obj.ObjectId;
            result["objectType"] = obj.ObjectType;
            result["position"] = Position.ToJson(obj.Position);
            if (obj.Health.HasValue) result["health"] = obj.Health;
            result["isDestroyed"] = obj.IsDestroyed;
            result["isInteractable"] = obj.IsInteractable;
            if (obj.InteractedBy != null) result["interactedBy"] = obj.InteractedBy;
            return result;
        }

        public static WorldObject Clone(WorldObject obj)
        {
            return new()
            {
                ObjectId = obj.ObjectId,
                ObjectType = obj.ObjectType,
                Position = Position.Clone(obj.Position),
                Health = obj.Health,
                IsDestroyed = obj.IsDestroyed,
                IsInteractable = obj.IsInteractable,
                InteractedBy = obj.InteractedBy,
            };
        }

        public static bool Equals(WorldObject a, WorldObject b)
        {
            return a.ObjectId == b.ObjectId &&
                a.ObjectType == b.ObjectType &&
                Position.Equals(a.Position, b.Position) &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Health, b.Health, (x, y) => x == y) &&
                a.IsDestroyed == b.IsDestroyed &&
                a.IsInteractable == b.IsInteractable &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.InteractedBy, b.InteractedBy, (x, y) => x == y);
        }

        public static byte[] Encode(WorldObject obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(WorldObject obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.ObjectId);
            encoder.PushString(obj.ObjectType);
            Position.Encode_(obj.Position, encoder);
            encoder.PushBoolean(obj.Health.HasValue);
            if (obj.Health.HasValue) encoder.PushBoundedInt(obj.Health.Value, 0);
            encoder.PushBoolean(obj.IsDestroyed);
            encoder.PushBoolean(obj.IsInteractable);
            encoder.PushOptional(obj.InteractedBy, x => encoder.PushString(x));
        }

        public static byte[] EncodeDiff(WorldObject a, WorldObject b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(WorldObject a, WorldObject b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(WorldObject a, WorldObject b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.ObjectId == b.ObjectId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.ObjectId, b.ObjectId);
            }
            {
                var changed = !(a.ObjectType == b.ObjectType);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.ObjectType, b.ObjectType);
            }
            Position.EncodeDiff_(a.Position, b.Position, encoder);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.Health, b.Health, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<long>(a.Health, b.Health, x => encoder.PushBoundedInt(x, 0), (x, y) => encoder.PushBoundedIntDiff(x, y, 0));
            }
            encoder.PushBooleanDiff(a.IsDestroyed, b.IsDestroyed);
            encoder.PushBooleanDiff(a.IsInteractable, b.IsInteractable);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptional(a.InteractedBy, b.InteractedBy, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<string>(a.InteractedBy, b.InteractedBy, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            }
        }

        public static WorldObject Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static WorldObject Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                ObjectId = decoder.NextString(),
                ObjectType = decoder.NextString(),
                Position = Position.Decode_(decoder),
                Health = decoder.NextBoolean() ? (long?)decoder.NextBoundedInt(0) : null,
                IsDestroyed = decoder.NextBoolean(),
                IsInteractable = decoder.NextBoolean(),
                InteractedBy = decoder.NextOptional(() => decoder.NextString()),
            };
        }

        public static WorldObject DecodeDiff(WorldObject obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static WorldObject DecodeDiff_(WorldObject obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static WorldObject DecodeDiffFields_(WorldObject obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                ObjectId = decoder.NextFieldDiff(obj.ObjectId, x => decoder.NextStringDiff(x)),
                ObjectType = decoder.NextFieldDiff(obj.ObjectType, x => decoder.NextStringDiff(x)),
                Position = Position.DecodeDiff_(obj.Position, decoder),
                Health = decoder.NextFieldDiff(obj.Health, x => decoder.NextOptionalDiff<long>(x, () => decoder.NextBoundedInt(0), x => decoder.NextBoundedIntDiff(x, 0))),
                IsDestroyed = decoder.NextBooleanDiff(obj.IsDestroyed),
                IsInteractable = decoder.NextBooleanDiff(obj.IsInteractable),
                InteractedBy = decoder.NextFieldDiff(obj.InteractedBy, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
            };
        }
    }

    public class MatchStats
    {
        public long TotalKills { get; set; }
        public long TotalDeaths { get; set; }
        public long TotalDamageDealt { get; set; }
        public long TotalHealingDone { get; set; }
        public long LongestKillStreak { get; set; }
        public float MatchDuration { get; set; }

        public static MatchStats Default() => new();

        public static MatchStats FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                TotalKills = json.GetProperty("totalKills").GetInt64(),
                TotalDeaths = json.GetProperty("totalDeaths").GetInt64(),
                TotalDamageDealt = json.GetProperty("totalDamageDealt").GetInt64(),
                TotalHealingDone = json.GetProperty("totalHealingDone").GetInt64(),
                LongestKillStreak = json.GetProperty("longestKillStreak").GetInt64(),
                MatchDuration = json.GetProperty("matchDuration").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(MatchStats obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["totalKills"] = obj.TotalKills;
            result["totalDeaths"] = obj.TotalDeaths;
            result["totalDamageDealt"] = obj.TotalDamageDealt;
            result["totalHealingDone"] = obj.TotalHealingDone;
            result["longestKillStreak"] = obj.LongestKillStreak;
            result["matchDuration"] = obj.MatchDuration;
            return result;
        }

        public static MatchStats Clone(MatchStats obj)
        {
            return new()
            {
                TotalKills = obj.TotalKills,
                TotalDeaths = obj.TotalDeaths,
                TotalDamageDealt = obj.TotalDamageDealt,
                TotalHealingDone = obj.TotalHealingDone,
                LongestKillStreak = obj.LongestKillStreak,
                MatchDuration = obj.MatchDuration,
            };
        }

        public static bool Equals(MatchStats a, MatchStats b)
        {
            return a.TotalKills == b.TotalKills &&
                a.TotalDeaths == b.TotalDeaths &&
                a.TotalDamageDealt == b.TotalDamageDealt &&
                a.TotalHealingDone == b.TotalHealingDone &&
                a.LongestKillStreak == b.LongestKillStreak &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.MatchDuration, b.MatchDuration);
        }

        public static byte[] Encode(MatchStats obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(MatchStats obj, DeltaPack.Encoder encoder)
        {
            encoder.PushBoundedInt(obj.TotalKills, 0);
            encoder.PushBoundedInt(obj.TotalDeaths, 0);
            encoder.PushBoundedInt(obj.TotalDamageDealt, 0);
            encoder.PushBoundedInt(obj.TotalHealingDone, 0);
            encoder.PushBoundedInt(obj.LongestKillStreak, 0);
            encoder.PushFloat(obj.MatchDuration);
        }

        public static byte[] EncodeDiff(MatchStats a, MatchStats b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(MatchStats a, MatchStats b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(MatchStats a, MatchStats b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.TotalKills == b.TotalKills);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.TotalKills, b.TotalKills, 0);
            }
            {
                var changed = !(a.TotalDeaths == b.TotalDeaths);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.TotalDeaths, b.TotalDeaths, 0);
            }
            {
                var changed = !(a.TotalDamageDealt == b.TotalDamageDealt);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.TotalDamageDealt, b.TotalDamageDealt, 0);
            }
            {
                var changed = !(a.TotalHealingDone == b.TotalHealingDone);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.TotalHealingDone, b.TotalHealingDone, 0);
            }
            {
                var changed = !(a.LongestKillStreak == b.LongestKillStreak);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.LongestKillStreak, b.LongestKillStreak, 0);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.MatchDuration, b.MatchDuration));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.MatchDuration, b.MatchDuration);
            }
        }

        public static MatchStats Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static MatchStats Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                TotalKills = decoder.NextBoundedInt(0),
                TotalDeaths = decoder.NextBoundedInt(0),
                TotalDamageDealt = decoder.NextBoundedInt(0),
                TotalHealingDone = decoder.NextBoundedInt(0),
                LongestKillStreak = decoder.NextBoundedInt(0),
                MatchDuration = decoder.NextFloat(),
            };
        }

        public static MatchStats DecodeDiff(MatchStats obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static MatchStats DecodeDiff_(MatchStats obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static MatchStats DecodeDiffFields_(MatchStats obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                TotalKills = decoder.NextFieldDiff(obj.TotalKills, x => decoder.NextBoundedIntDiff(x, 0)),
                TotalDeaths = decoder.NextFieldDiff(obj.TotalDeaths, x => decoder.NextBoundedIntDiff(x, 0)),
                TotalDamageDealt = decoder.NextFieldDiff(obj.TotalDamageDealt, x => decoder.NextBoundedIntDiff(x, 0)),
                TotalHealingDone = decoder.NextFieldDiff(obj.TotalHealingDone, x => decoder.NextBoundedIntDiff(x, 0)),
                LongestKillStreak = decoder.NextFieldDiff(obj.LongestKillStreak, x => decoder.NextBoundedIntDiff(x, 0)),
                MatchDuration = decoder.NextFieldDiff(obj.MatchDuration, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class TeamScore
    {
        public Team Team { get; set; } = Team.RED;
        public long Score { get; set; }
        public long Kills { get; set; }
        public long ObjectivesCaptured { get; set; }

        public static TeamScore Default() => new();

        public static TeamScore FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Team = DeltaPack.JsonHelpers.ParseEnum<Team>(json.GetProperty("team")),
                Score = json.GetProperty("score").GetInt64(),
                Kills = json.GetProperty("kills").GetInt64(),
                ObjectivesCaptured = json.GetProperty("objectivesCaptured").GetInt64(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(TeamScore obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["team"] = obj.Team.ToString();
            result["score"] = obj.Score;
            result["kills"] = obj.Kills;
            result["objectivesCaptured"] = obj.ObjectivesCaptured;
            return result;
        }

        public static TeamScore Clone(TeamScore obj)
        {
            return new()
            {
                Team = obj.Team,
                Score = obj.Score,
                Kills = obj.Kills,
                ObjectivesCaptured = obj.ObjectivesCaptured,
            };
        }

        public static bool Equals(TeamScore a, TeamScore b)
        {
            return a.Team == b.Team &&
                a.Score == b.Score &&
                a.Kills == b.Kills &&
                a.ObjectivesCaptured == b.ObjectivesCaptured;
        }

        public static byte[] Encode(TeamScore obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(TeamScore obj, DeltaPack.Encoder encoder)
        {
            encoder.PushEnum((int)obj.Team, 2);
            encoder.PushBoundedInt(obj.Score, 0);
            encoder.PushBoundedInt(obj.Kills, 0);
            encoder.PushBoundedInt(obj.ObjectivesCaptured, 0);
        }

        public static byte[] EncodeDiff(TeamScore a, TeamScore b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(TeamScore a, TeamScore b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(TeamScore a, TeamScore b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.Team == b.Team);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushEnumDiff((int)a.Team, (int)b.Team, 2);
            }
            {
                var changed = !(a.Score == b.Score);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Score, b.Score, 0);
            }
            {
                var changed = !(a.Kills == b.Kills);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Kills, b.Kills, 0);
            }
            {
                var changed = !(a.ObjectivesCaptured == b.ObjectivesCaptured);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.ObjectivesCaptured, b.ObjectivesCaptured, 0);
            }
        }

        public static TeamScore Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static TeamScore Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Team = (Team)decoder.NextEnum(2),
                Score = decoder.NextBoundedInt(0),
                Kills = decoder.NextBoundedInt(0),
                ObjectivesCaptured = decoder.NextBoundedInt(0),
            };
        }

        public static TeamScore DecodeDiff(TeamScore obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static TeamScore DecodeDiff_(TeamScore obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static TeamScore DecodeDiffFields_(TeamScore obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Team = decoder.NextFieldDiff(obj.Team, x => (Team)decoder.NextEnumDiff((int)x, 2)),
                Score = decoder.NextFieldDiff(obj.Score, x => decoder.NextBoundedIntDiff(x, 0)),
                Kills = decoder.NextFieldDiff(obj.Kills, x => decoder.NextBoundedIntDiff(x, 0)),
                ObjectivesCaptured = decoder.NextFieldDiff(obj.ObjectivesCaptured, x => decoder.NextBoundedIntDiff(x, 0)),
            };
        }
    }

    public class GameSettings
    {
        public long MaxPlayers { get; set; }
        public bool FriendlyFire { get; set; }
        public float RespawnDelay { get; set; }
        public long RoundTimeLimit { get; set; }
        public long StartingGold { get; set; }
        public float GravityMultiplier { get; set; }

        public static GameSettings Default() => new();

        public static GameSettings FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                MaxPlayers = json.GetProperty("maxPlayers").GetInt64(),
                FriendlyFire = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("friendlyFire")),
                RespawnDelay = json.GetProperty("respawnDelay").GetSingle(),
                RoundTimeLimit = json.GetProperty("roundTimeLimit").GetInt64(),
                StartingGold = json.GetProperty("startingGold").GetInt64(),
                GravityMultiplier = json.GetProperty("gravityMultiplier").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(GameSettings obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["maxPlayers"] = obj.MaxPlayers;
            result["friendlyFire"] = obj.FriendlyFire;
            result["respawnDelay"] = obj.RespawnDelay;
            result["roundTimeLimit"] = obj.RoundTimeLimit;
            result["startingGold"] = obj.StartingGold;
            result["gravityMultiplier"] = obj.GravityMultiplier;
            return result;
        }

        public static GameSettings Clone(GameSettings obj)
        {
            return new()
            {
                MaxPlayers = obj.MaxPlayers,
                FriendlyFire = obj.FriendlyFire,
                RespawnDelay = obj.RespawnDelay,
                RoundTimeLimit = obj.RoundTimeLimit,
                StartingGold = obj.StartingGold,
                GravityMultiplier = obj.GravityMultiplier,
            };
        }

        public static bool Equals(GameSettings a, GameSettings b)
        {
            return a.MaxPlayers == b.MaxPlayers &&
                a.FriendlyFire == b.FriendlyFire &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.RespawnDelay, b.RespawnDelay) &&
                a.RoundTimeLimit == b.RoundTimeLimit &&
                a.StartingGold == b.StartingGold &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.GravityMultiplier, b.GravityMultiplier);
        }

        public static byte[] Encode(GameSettings obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(GameSettings obj, DeltaPack.Encoder encoder)
        {
            encoder.PushBoundedInt(obj.MaxPlayers, 0);
            encoder.PushBoolean(obj.FriendlyFire);
            encoder.PushFloat(obj.RespawnDelay);
            encoder.PushBoundedInt(obj.RoundTimeLimit, 0);
            encoder.PushBoundedInt(obj.StartingGold, 0);
            encoder.PushFloat(obj.GravityMultiplier);
        }

        public static byte[] EncodeDiff(GameSettings a, GameSettings b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(GameSettings a, GameSettings b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(GameSettings a, GameSettings b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.MaxPlayers == b.MaxPlayers);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.MaxPlayers, b.MaxPlayers, 0);
            }
            encoder.PushBooleanDiff(a.FriendlyFire, b.FriendlyFire);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.RespawnDelay, b.RespawnDelay));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.RespawnDelay, b.RespawnDelay);
            }
            {
                var changed = !(a.RoundTimeLimit == b.RoundTimeLimit);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.RoundTimeLimit, b.RoundTimeLimit, 0);
            }
            {
                var changed = !(a.StartingGold == b.StartingGold);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.StartingGold, b.StartingGold, 0);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.GravityMultiplier, b.GravityMultiplier));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.GravityMultiplier, b.GravityMultiplier);
            }
        }

        public static GameSettings Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static GameSettings Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                MaxPlayers = decoder.NextBoundedInt(0),
                FriendlyFire = decoder.NextBoolean(),
                RespawnDelay = decoder.NextFloat(),
                RoundTimeLimit = decoder.NextBoundedInt(0),
                StartingGold = decoder.NextBoundedInt(0),
                GravityMultiplier = decoder.NextFloat(),
            };
        }

        public static GameSettings DecodeDiff(GameSettings obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static GameSettings DecodeDiff_(GameSettings obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static GameSettings DecodeDiffFields_(GameSettings obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                MaxPlayers = decoder.NextFieldDiff(obj.MaxPlayers, x => decoder.NextBoundedIntDiff(x, 0)),
                FriendlyFire = decoder.NextBooleanDiff(obj.FriendlyFire),
                RespawnDelay = decoder.NextFieldDiff(obj.RespawnDelay, x => decoder.NextFloatDiff(x)),
                RoundTimeLimit = decoder.NextFieldDiff(obj.RoundTimeLimit, x => decoder.NextBoundedIntDiff(x, 0)),
                StartingGold = decoder.NextFieldDiff(obj.StartingGold, x => decoder.NextBoundedIntDiff(x, 0)),
                GravityMultiplier = decoder.NextFieldDiff(obj.GravityMultiplier, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class GameState
    {
        public string GameId { get; set; } = "";
        public float ServerTime { get; set; }
        public long TickNumber { get; set; }
        public long Round { get; set; }
        public string Phase { get; set; } = "";
        public float TimeRemaining { get; set; }
        public System.Collections.Generic.Dictionary<string, Player> Players { get; set; } = new System.Collections.Generic.Dictionary<string, Player>();
        public System.Collections.Generic.Dictionary<string, Enemy> Enemies { get; set; } = new System.Collections.Generic.Dictionary<string, Enemy>();
        public System.Collections.Generic.Dictionary<string, Projectile> Projectiles { get; set; } = new System.Collections.Generic.Dictionary<string, Projectile>();
        public System.Collections.Generic.Dictionary<string, DroppedLoot> DroppedLoot { get; set; } = new System.Collections.Generic.Dictionary<string, DroppedLoot>();
        public System.Collections.Generic.Dictionary<string, WorldObject> WorldObjects { get; set; } = new System.Collections.Generic.Dictionary<string, WorldObject>();
        public System.Collections.Generic.List<TeamScore> TeamScores { get; set; } = new System.Collections.Generic.List<TeamScore>();
        public MatchStats MatchStats { get; set; } = MatchStats.Default();
        public GameSettings Settings { get; set; } = GameSettings.Default();
        public Team? WinningTeam { get; set; }
        public string MapName { get; set; } = "";
        public float WeatherIntensity { get; set; }

        public static GameState Default() => new();

        public static GameState FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                GameId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("gameId")),
                ServerTime = json.GetProperty("serverTime").GetSingle(),
                TickNumber = json.GetProperty("tickNumber").GetInt64(),
                Round = json.GetProperty("round").GetInt64(),
                Phase = DeltaPack.JsonHelpers.ParseString(json.GetProperty("phase")),
                TimeRemaining = json.GetProperty("timeRemaining").GetSingle(),
                Players = json.GetProperty("players").EnumerateObject().ToDictionary(p => p.Name, p => Player.FromJson(p.Value)),
                Enemies = json.GetProperty("enemies").EnumerateObject().ToDictionary(p => p.Name, p => Enemy.FromJson(p.Value)),
                Projectiles = json.GetProperty("projectiles").EnumerateObject().ToDictionary(p => p.Name, p => Projectile.FromJson(p.Value)),
                DroppedLoot = json.GetProperty("droppedLoot").EnumerateObject().ToDictionary(p => p.Name, p => Generated.Examples.DroppedLoot.FromJson(p.Value)),
                WorldObjects = json.GetProperty("worldObjects").EnumerateObject().ToDictionary(p => p.Name, p => WorldObject.FromJson(p.Value)),
                TeamScores = json.GetProperty("teamScores").EnumerateArray().Select(x => TeamScore.FromJson(x)).ToList(),
                MatchStats = MatchStats.FromJson(json.GetProperty("matchStats")),
                Settings = GameSettings.FromJson(json.GetProperty("settings")),
                WinningTeam = json.TryGetProperty("winningTeam", out var winningTeamEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(winningTeamEl) ? null : DeltaPack.JsonHelpers.ParseEnum<Team>(winningTeamEl) : null,
                MapName = DeltaPack.JsonHelpers.ParseString(json.GetProperty("mapName")),
                WeatherIntensity = json.GetProperty("weatherIntensity").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(GameState obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["gameId"] = obj.GameId;
            result["serverTime"] = obj.ServerTime;
            result["tickNumber"] = obj.TickNumber;
            result["round"] = obj.Round;
            result["phase"] = obj.Phase;
            result["timeRemaining"] = obj.TimeRemaining;
            result["players"] = new System.Text.Json.Nodes.JsonObject(obj.Players.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, Player.ToJson(kvp.Value))));
            result["enemies"] = new System.Text.Json.Nodes.JsonObject(obj.Enemies.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, Enemy.ToJson(kvp.Value))));
            result["projectiles"] = new System.Text.Json.Nodes.JsonObject(obj.Projectiles.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, Projectile.ToJson(kvp.Value))));
            result["droppedLoot"] = new System.Text.Json.Nodes.JsonObject(obj.DroppedLoot.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, Generated.Examples.DroppedLoot.ToJson(kvp.Value))));
            result["worldObjects"] = new System.Text.Json.Nodes.JsonObject(obj.WorldObjects.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, WorldObject.ToJson(kvp.Value))));
            result["teamScores"] = new System.Text.Json.Nodes.JsonArray(obj.TeamScores.Select(x => (System.Text.Json.Nodes.JsonNode?)TeamScore.ToJson(x)).ToArray());
            result["matchStats"] = MatchStats.ToJson(obj.MatchStats);
            result["settings"] = GameSettings.ToJson(obj.Settings);
            if (obj.WinningTeam.HasValue) result["winningTeam"] = obj.WinningTeam.ToString();
            result["mapName"] = obj.MapName;
            result["weatherIntensity"] = obj.WeatherIntensity;
            return result;
        }

        public static GameState Clone(GameState obj)
        {
            return new()
            {
                GameId = obj.GameId,
                ServerTime = obj.ServerTime,
                TickNumber = obj.TickNumber,
                Round = obj.Round,
                Phase = obj.Phase,
                TimeRemaining = obj.TimeRemaining,
                Players = obj.Players.ToDictionary(kvp => kvp.Key, kvp => Player.Clone(kvp.Value)),
                Enemies = obj.Enemies.ToDictionary(kvp => kvp.Key, kvp => Enemy.Clone(kvp.Value)),
                Projectiles = obj.Projectiles.ToDictionary(kvp => kvp.Key, kvp => Projectile.Clone(kvp.Value)),
                DroppedLoot = obj.DroppedLoot.ToDictionary(kvp => kvp.Key, kvp => Generated.Examples.DroppedLoot.Clone(kvp.Value)),
                WorldObjects = obj.WorldObjects.ToDictionary(kvp => kvp.Key, kvp => WorldObject.Clone(kvp.Value)),
                TeamScores = obj.TeamScores.Select(x => TeamScore.Clone(x)).ToList(),
                MatchStats = MatchStats.Clone(obj.MatchStats),
                Settings = GameSettings.Clone(obj.Settings),
                WinningTeam = obj.WinningTeam,
                MapName = obj.MapName,
                WeatherIntensity = obj.WeatherIntensity,
            };
        }

        public static bool Equals(GameState a, GameState b)
        {
            return a.GameId == b.GameId &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.ServerTime, b.ServerTime) &&
                a.TickNumber == b.TickNumber &&
                a.Round == b.Round &&
                a.Phase == b.Phase &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.TimeRemaining, b.TimeRemaining) &&
                a.Players.Count == b.Players.Count && a.Players.All(kvp => b.Players.TryGetValue(kvp.Key, out var v) && Player.Equals(kvp.Value, v)) &&
                a.Enemies.Count == b.Enemies.Count && a.Enemies.All(kvp => b.Enemies.TryGetValue(kvp.Key, out var v) && Enemy.Equals(kvp.Value, v)) &&
                a.Projectiles.Count == b.Projectiles.Count && a.Projectiles.All(kvp => b.Projectiles.TryGetValue(kvp.Key, out var v) && Projectile.Equals(kvp.Value, v)) &&
                a.DroppedLoot.Count == b.DroppedLoot.Count && a.DroppedLoot.All(kvp => b.DroppedLoot.TryGetValue(kvp.Key, out var v) && Generated.Examples.DroppedLoot.Equals(kvp.Value, v)) &&
                a.WorldObjects.Count == b.WorldObjects.Count && a.WorldObjects.All(kvp => b.WorldObjects.TryGetValue(kvp.Key, out var v) && WorldObject.Equals(kvp.Value, v)) &&
                a.TeamScores.Count == b.TeamScores.Count && a.TeamScores.Zip(b.TeamScores).All(pair => TeamScore.Equals(pair.First, pair.Second)) &&
                MatchStats.Equals(a.MatchStats, b.MatchStats) &&
                GameSettings.Equals(a.Settings, b.Settings) &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.WinningTeam, b.WinningTeam, (x, y) => x == y) &&
                a.MapName == b.MapName &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.WeatherIntensity, b.WeatherIntensity);
        }

        public static byte[] Encode(GameState obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(GameState obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.GameId);
            encoder.PushFloat(obj.ServerTime);
            encoder.PushBoundedInt(obj.TickNumber, 0);
            encoder.PushBoundedInt(obj.Round, 0);
            encoder.PushString(obj.Phase);
            encoder.PushFloat(obj.TimeRemaining);
            encoder.PushRecord(obj.Players, x => encoder.PushString(x), x => Player.Encode_(x, encoder));
            encoder.PushRecord(obj.Enemies, x => encoder.PushString(x), x => Enemy.Encode_(x, encoder));
            encoder.PushRecord(obj.Projectiles, x => encoder.PushString(x), x => Projectile.Encode_(x, encoder));
            encoder.PushRecord(obj.DroppedLoot, x => encoder.PushString(x), x => Generated.Examples.DroppedLoot.Encode_(x, encoder));
            encoder.PushRecord(obj.WorldObjects, x => encoder.PushString(x), x => WorldObject.Encode_(x, encoder));
            encoder.PushArray(obj.TeamScores, x => TeamScore.Encode_(x, encoder));
            MatchStats.Encode_(obj.MatchStats, encoder);
            GameSettings.Encode_(obj.Settings, encoder);
            encoder.PushBoolean(obj.WinningTeam.HasValue);
            if (obj.WinningTeam.HasValue) encoder.PushEnum((int)obj.WinningTeam.Value, 2);
            encoder.PushString(obj.MapName);
            encoder.PushFloat(obj.WeatherIntensity);
        }

        public static byte[] EncodeDiff(GameState a, GameState b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(GameState a, GameState b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            EncodeDiffFields_(a, b, encoder);
        }

        internal static void EncodeDiffFields_(GameState a, GameState b, DeltaPack.Encoder encoder)
        {
            {
                var changed = !(a.GameId == b.GameId);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.GameId, b.GameId);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.ServerTime, b.ServerTime));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.ServerTime, b.ServerTime);
            }
            {
                var changed = !(a.TickNumber == b.TickNumber);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.TickNumber, b.TickNumber, 0);
            }
            {
                var changed = !(a.Round == b.Round);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushBoundedIntDiff(a.Round, b.Round, 0);
            }
            {
                var changed = !(a.Phase == b.Phase);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.Phase, b.Phase);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.TimeRemaining, b.TimeRemaining));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.TimeRemaining, b.TimeRemaining);
            }
            {
                var changed = !(a.Players.Count == b.Players.Count && a.Players.All(kvp => b.Players.TryGetValue(kvp.Key, out var v) && Player.Equals(kvp.Value, v)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushRecordDiff<string, Player>(a.Players, b.Players, (x, y) => Player.Equals(x, y), x => encoder.PushString(x), x => Player.Encode_(x, encoder), (x, y) => Player.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.Enemies.Count == b.Enemies.Count && a.Enemies.All(kvp => b.Enemies.TryGetValue(kvp.Key, out var v) && Enemy.Equals(kvp.Value, v)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushRecordDiff<string, Enemy>(a.Enemies, b.Enemies, (x, y) => Enemy.Equals(x, y), x => encoder.PushString(x), x => Enemy.Encode_(x, encoder), (x, y) => Enemy.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.Projectiles.Count == b.Projectiles.Count && a.Projectiles.All(kvp => b.Projectiles.TryGetValue(kvp.Key, out var v) && Projectile.Equals(kvp.Value, v)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushRecordDiff<string, Projectile>(a.Projectiles, b.Projectiles, (x, y) => Projectile.Equals(x, y), x => encoder.PushString(x), x => Projectile.Encode_(x, encoder), (x, y) => Projectile.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.DroppedLoot.Count == b.DroppedLoot.Count && a.DroppedLoot.All(kvp => b.DroppedLoot.TryGetValue(kvp.Key, out var v) && Generated.Examples.DroppedLoot.Equals(kvp.Value, v)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushRecordDiff<string, DroppedLoot>(a.DroppedLoot, b.DroppedLoot, (x, y) => Generated.Examples.DroppedLoot.Equals(x, y), x => encoder.PushString(x), x => Generated.Examples.DroppedLoot.Encode_(x, encoder), (x, y) => Generated.Examples.DroppedLoot.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.WorldObjects.Count == b.WorldObjects.Count && a.WorldObjects.All(kvp => b.WorldObjects.TryGetValue(kvp.Key, out var v) && WorldObject.Equals(kvp.Value, v)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushRecordDiff<string, WorldObject>(a.WorldObjects, b.WorldObjects, (x, y) => WorldObject.Equals(x, y), x => encoder.PushString(x), x => WorldObject.Encode_(x, encoder), (x, y) => WorldObject.EncodeDiffFields_(x, y, encoder));
            }
            {
                var changed = !(a.TeamScores.Count == b.TeamScores.Count && a.TeamScores.Zip(b.TeamScores).All(pair => TeamScore.Equals(pair.First, pair.Second)));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushArrayDiff<TeamScore>(a.TeamScores, b.TeamScores, (x, y) => TeamScore.Equals(x, y), x => TeamScore.Encode_(x, encoder), (x, y) => TeamScore.EncodeDiffFields_(x, y, encoder));
            }
            MatchStats.EncodeDiff_(a.MatchStats, b.MatchStats, encoder);
            GameSettings.EncodeDiff_(a.Settings, b.Settings, encoder);
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsOptionalValue(a.WinningTeam, b.WinningTeam, (x, y) => x == y));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushOptionalDiff<Team>(a.WinningTeam, b.WinningTeam, x => encoder.PushEnum((int)x, 2), (x, y) => encoder.PushEnumDiff((int)x, (int)y, 2));
            }
            {
                var changed = !(a.MapName == b.MapName);
                encoder.PushBoolean(changed);
                if (changed) encoder.PushStringDiff(a.MapName, b.MapName);
            }
            {
                var changed = !(DeltaPack.EqualityHelpers.EqualsFloat(a.WeatherIntensity, b.WeatherIntensity));
                encoder.PushBoolean(changed);
                if (changed) encoder.PushFloatDiff(a.WeatherIntensity, b.WeatherIntensity);
            }
        }

        public static GameState Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static GameState Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                GameId = decoder.NextString(),
                ServerTime = decoder.NextFloat(),
                TickNumber = decoder.NextBoundedInt(0),
                Round = decoder.NextBoundedInt(0),
                Phase = decoder.NextString(),
                TimeRemaining = decoder.NextFloat(),
                Players = decoder.NextRecord(() => decoder.NextString(), () => Player.Decode_(decoder)),
                Enemies = decoder.NextRecord(() => decoder.NextString(), () => Enemy.Decode_(decoder)),
                Projectiles = decoder.NextRecord(() => decoder.NextString(), () => Projectile.Decode_(decoder)),
                DroppedLoot = decoder.NextRecord(() => decoder.NextString(), () => Generated.Examples.DroppedLoot.Decode_(decoder)),
                WorldObjects = decoder.NextRecord(() => decoder.NextString(), () => WorldObject.Decode_(decoder)),
                TeamScores = decoder.NextArray(() => TeamScore.Decode_(decoder)),
                MatchStats = MatchStats.Decode_(decoder),
                Settings = GameSettings.Decode_(decoder),
                WinningTeam = decoder.NextBoolean() ? (Team?)decoder.NextEnum(2) : null,
                MapName = decoder.NextString(),
                WeatherIntensity = decoder.NextFloat(),
            };
        }

        public static GameState DecodeDiff(GameState obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static GameState DecodeDiff_(GameState obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return DecodeDiffFields_(obj, decoder);
        }

        internal static GameState DecodeDiffFields_(GameState obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                GameId = decoder.NextFieldDiff(obj.GameId, x => decoder.NextStringDiff(x)),
                ServerTime = decoder.NextFieldDiff(obj.ServerTime, x => decoder.NextFloatDiff(x)),
                TickNumber = decoder.NextFieldDiff(obj.TickNumber, x => decoder.NextBoundedIntDiff(x, 0)),
                Round = decoder.NextFieldDiff(obj.Round, x => decoder.NextBoundedIntDiff(x, 0)),
                Phase = decoder.NextFieldDiff(obj.Phase, x => decoder.NextStringDiff(x)),
                TimeRemaining = decoder.NextFieldDiff(obj.TimeRemaining, x => decoder.NextFloatDiff(x)),
                Players = decoder.NextFieldDiff(obj.Players, x => decoder.NextRecordDiff<string, Player>(x, () => decoder.NextString(), () => Player.Decode_(decoder), x => Player.DecodeDiffFields_(x, decoder))),
                Enemies = decoder.NextFieldDiff(obj.Enemies, x => decoder.NextRecordDiff<string, Enemy>(x, () => decoder.NextString(), () => Enemy.Decode_(decoder), x => Enemy.DecodeDiffFields_(x, decoder))),
                Projectiles = decoder.NextFieldDiff(obj.Projectiles, x => decoder.NextRecordDiff<string, Projectile>(x, () => decoder.NextString(), () => Projectile.Decode_(decoder), x => Projectile.DecodeDiffFields_(x, decoder))),
                DroppedLoot = decoder.NextFieldDiff(obj.DroppedLoot, x => decoder.NextRecordDiff<string, DroppedLoot>(x, () => decoder.NextString(), () => Generated.Examples.DroppedLoot.Decode_(decoder), x => Generated.Examples.DroppedLoot.DecodeDiffFields_(x, decoder))),
                WorldObjects = decoder.NextFieldDiff(obj.WorldObjects, x => decoder.NextRecordDiff<string, WorldObject>(x, () => decoder.NextString(), () => WorldObject.Decode_(decoder), x => WorldObject.DecodeDiffFields_(x, decoder))),
                TeamScores = decoder.NextFieldDiff(obj.TeamScores, x => decoder.NextArrayDiff<TeamScore>(x, () => TeamScore.Decode_(decoder), x => TeamScore.DecodeDiffFields_(x, decoder))),
                MatchStats = MatchStats.DecodeDiff_(obj.MatchStats, decoder),
                Settings = GameSettings.DecodeDiff_(obj.Settings, decoder),
                WinningTeam = decoder.NextFieldDiff(obj.WinningTeam, x => decoder.NextOptionalDiff<Team>(x, () => (Team)decoder.NextEnum(2), x => (Team)decoder.NextEnumDiff((int)x, 2))),
                MapName = decoder.NextFieldDiff(obj.MapName, x => decoder.NextStringDiff(x)),
                WeatherIntensity = decoder.NextFieldDiff(obj.WeatherIntensity, x => decoder.NextFloatDiff(x)),
            };
        }
    }
}
