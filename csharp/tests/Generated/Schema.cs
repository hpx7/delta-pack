// Auto-generated by DeltaPack - do not edit
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Nodes;
using DeltaPack;

namespace Generated
{
    public enum Color
    {
        RED = 0,
        BLUE = 1,
        GREEN = 2,
        YELLOW = 3
    }

    public class Player
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public long Score { get; set; }
        public bool IsActive { get; set; }
        public Player? Partner { get; set; }

        public static Player Default() => new Player();

        public static Player FromJson(JsonElement json)
        {
            return new Player
            {
                Id = json.GetProperty("id").GetString() ?? "",
                Name = json.GetProperty("name").GetString() ?? "",
                Score = json.GetProperty("score").GetInt64(),
                IsActive = json.GetProperty("isActive").GetBoolean(),
                Partner = json.TryGetProperty("partner", out var partnerEl) ? partnerEl.ValueKind == JsonValueKind.Null ? null : Generated.Player.FromJson(partnerEl) : null,
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["id"] = Id;
            result["name"] = Name;
            result["score"] = Score;
            result["isActive"] = IsActive;
            if (Partner != null) result["partner"] = Partner.ToJson();
            return result;
        }

        public static Player Clone(Player obj)
        {
            return new Player
            {
                Id = obj.Id,
                Name = obj.Name,
                Score = obj.Score,
                IsActive = obj.IsActive,
                Partner = obj.Partner != null ? Generated.Player.Clone(obj.Partner) : null,
            };
        }

        public static bool Equals(Player a, Player b)
        {
            return a.Id == b.Id &&
                a.Name == b.Name &&
                a.Score == b.Score &&
                a.IsActive == b.IsActive &&
                (a.Partner == null && b.Partner == null || a.Partner != null && b.Partner != null && Generated.Player.Equals(a.Partner, b.Partner));
        }

        public static byte[] Encode(Player obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(Player obj, Encoder encoder)
        {
            encoder.PushString(obj.Id);
            encoder.PushString(obj.Name);
            encoder.PushInt(obj.Score);
            encoder.PushBoolean(obj.IsActive);
            encoder.PushOptional(obj.Partner, x => Generated.Player.EncodeInternal(x, encoder));
        }

        public static byte[] EncodeDiff(Player a, Player b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(Player a, Player b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushStringDiff(a.Id, b.Id);
            encoder.PushStringDiff(a.Name, b.Name);
            encoder.PushIntDiff(a.Score, b.Score);
            encoder.PushBooleanDiff(a.IsActive, b.IsActive);
            encoder.PushOptionalDiff<Player>(a.Partner, b.Partner, x => Generated.Player.EncodeInternal(x, encoder), (x, y) => Generated.Player.EncodeDiffInternal(x, y, encoder));
        }

        public static Player Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static Player DecodeInternal(Decoder decoder)
        {
            return new Player
            {
                Id = decoder.NextString(),
                Name = decoder.NextString(),
                Score = decoder.NextInt(),
                IsActive = decoder.NextBoolean(),
                Partner = decoder.NextOptional(() => Generated.Player.DecodeInternal(decoder)),
            };
        }

        public static Player DecodeDiff(Player obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static Player DecodeDiffInternal(Player obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new Player
            {
                Id = decoder.NextStringDiff(obj.Id),
                Name = decoder.NextStringDiff(obj.Name),
                Score = decoder.NextIntDiff(obj.Score),
                IsActive = decoder.NextBooleanDiff(obj.IsActive),
                Partner = decoder.NextOptionalDiff<Player>(obj.Partner, () => Generated.Player.DecodeInternal(decoder), x => Generated.Player.DecodeDiffInternal(x, decoder)),
            };
        }
    }

    public class Position
    {
        public float X { get; set; }
        public float Y { get; set; }

        public static Position Default() => new Position();

        public static Position FromJson(JsonElement json)
        {
            return new Position
            {
                X = json.GetProperty("x").GetSingle(),
                Y = json.GetProperty("y").GetSingle(),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["x"] = X;
            result["y"] = Y;
            return result;
        }

        public static Position Clone(Position obj)
        {
            return new Position
            {
                X = obj.X,
                Y = obj.Y,
            };
        }

        public static bool Equals(Position a, Position b)
        {
            return Math.Abs(a.X - b.X) < 0.05f &&
                Math.Abs(a.Y - b.Y) < 0.05f;
        }

        public static byte[] Encode(Position obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(Position obj, Encoder encoder)
        {
            encoder.PushFloatQuantized(obj.X, 0.1f);
            encoder.PushFloatQuantized(obj.Y, 0.1f);
        }

        public static byte[] EncodeDiff(Position a, Position b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(Position a, Position b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushFloatQuantizedDiff(a.X, b.X, 0.1f);
            encoder.PushFloatQuantizedDiff(a.Y, b.Y, 0.1f);
        }

        public static Position Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static Position DecodeInternal(Decoder decoder)
        {
            return new Position
            {
                X = decoder.NextFloatQuantized(0.1f),
                Y = decoder.NextFloatQuantized(0.1f),
            };
        }

        public static Position DecodeDiff(Position obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static Position DecodeDiffInternal(Position obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new Position
            {
                X = decoder.NextFloatQuantizedDiff(obj.X, 0.1f),
                Y = decoder.NextFloatQuantizedDiff(obj.Y, 0.1f),
            };
        }
    }

    public class Velocity
    {
        public float Vx { get; set; }
        public float Vy { get; set; }

        public static Velocity Default() => new Velocity();

        public static Velocity FromJson(JsonElement json)
        {
            return new Velocity
            {
                Vx = json.GetProperty("vx").GetSingle(),
                Vy = json.GetProperty("vy").GetSingle(),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["vx"] = Vx;
            result["vy"] = Vy;
            return result;
        }

        public static Velocity Clone(Velocity obj)
        {
            return new Velocity
            {
                Vx = obj.Vx,
                Vy = obj.Vy,
            };
        }

        public static bool Equals(Velocity a, Velocity b)
        {
            return a.Vx == b.Vx &&
                a.Vy == b.Vy;
        }

        public static byte[] Encode(Velocity obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(Velocity obj, Encoder encoder)
        {
            encoder.PushFloat(obj.Vx);
            encoder.PushFloat(obj.Vy);
        }

        public static byte[] EncodeDiff(Velocity a, Velocity b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(Velocity a, Velocity b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushFloatDiff(a.Vx, b.Vx);
            encoder.PushFloatDiff(a.Vy, b.Vy);
        }

        public static Velocity Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static Velocity DecodeInternal(Decoder decoder)
        {
            return new Velocity
            {
                Vx = decoder.NextFloat(),
                Vy = decoder.NextFloat(),
            };
        }

        public static Velocity DecodeDiff(Velocity obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static Velocity DecodeDiffInternal(Velocity obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new Velocity
            {
                Vx = decoder.NextFloatDiff(obj.Vx),
                Vy = decoder.NextFloatDiff(obj.Vy),
            };
        }
    }

    public class Entity
    {
        public string Id { get; set; } = "";
        public Position Position { get; set; } = Generated.Position.Default();

        public static Entity Default() => new Entity();

        public static Entity FromJson(JsonElement json)
        {
            return new Entity
            {
                Id = json.GetProperty("id").GetString() ?? "",
                Position = Generated.Position.FromJson(json.GetProperty("position")),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["id"] = Id;
            result["position"] = Position.ToJson();
            return result;
        }

        public static Entity Clone(Entity obj)
        {
            return new Entity
            {
                Id = obj.Id,
                Position = Generated.Position.Clone(obj.Position),
            };
        }

        public static bool Equals(Entity a, Entity b)
        {
            return a.Id == b.Id &&
                Generated.Position.Equals(a.Position, b.Position);
        }

        public static byte[] Encode(Entity obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(Entity obj, Encoder encoder)
        {
            encoder.PushString(obj.Id);
            Generated.Position.EncodeInternal(obj.Position, encoder);
        }

        public static byte[] EncodeDiff(Entity a, Entity b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(Entity a, Entity b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushStringDiff(a.Id, b.Id);
            Generated.Position.EncodeDiffInternal(a.Position, b.Position, encoder);
        }

        public static Entity Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static Entity DecodeInternal(Decoder decoder)
        {
            return new Entity
            {
                Id = decoder.NextString(),
                Position = Generated.Position.DecodeInternal(decoder),
            };
        }

        public static Entity DecodeDiff(Entity obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static Entity DecodeDiffInternal(Entity obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new Entity
            {
                Id = decoder.NextStringDiff(obj.Id),
                Position = Generated.Position.DecodeDiffInternal(obj.Position, decoder),
            };
        }
    }

    public class MoveAction : GameAction
    {
        public override string Type => "MoveAction";

        public long X { get; set; }
        public long Y { get; set; }

        public static new MoveAction Default() => new MoveAction();

        public static new MoveAction FromJson(JsonElement json)
        {
            return new MoveAction
            {
                X = json.GetProperty("x").GetInt64(),
                Y = json.GetProperty("y").GetInt64(),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["x"] = X;
            result["y"] = Y;
            return result;
        }

        public static MoveAction Clone(MoveAction obj)
        {
            return new MoveAction
            {
                X = obj.X,
                Y = obj.Y,
            };
        }

        public static bool Equals(MoveAction a, MoveAction b)
        {
            return a.X == b.X &&
                a.Y == b.Y;
        }

        public static byte[] Encode(MoveAction obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(MoveAction obj, Encoder encoder)
        {
            encoder.PushInt(obj.X);
            encoder.PushInt(obj.Y);
        }

        public static byte[] EncodeDiff(MoveAction a, MoveAction b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(MoveAction a, MoveAction b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushIntDiff(a.X, b.X);
            encoder.PushIntDiff(a.Y, b.Y);
        }

        public static new MoveAction Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static new MoveAction DecodeInternal(Decoder decoder)
        {
            return new MoveAction
            {
                X = decoder.NextInt(),
                Y = decoder.NextInt(),
            };
        }

        public static MoveAction DecodeDiff(MoveAction obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static MoveAction DecodeDiffInternal(MoveAction obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new MoveAction
            {
                X = decoder.NextIntDiff(obj.X),
                Y = decoder.NextIntDiff(obj.Y),
            };
        }
    }

    public class AttackAction : GameAction
    {
        public override string Type => "AttackAction";

        public string TargetId { get; set; } = "";
        public long Damage { get; set; }

        public static new AttackAction Default() => new AttackAction();

        public static new AttackAction FromJson(JsonElement json)
        {
            return new AttackAction
            {
                TargetId = json.GetProperty("targetId").GetString() ?? "",
                Damage = json.GetProperty("damage").GetInt64(),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["targetId"] = TargetId;
            result["damage"] = Damage;
            return result;
        }

        public static AttackAction Clone(AttackAction obj)
        {
            return new AttackAction
            {
                TargetId = obj.TargetId,
                Damage = obj.Damage,
            };
        }

        public static bool Equals(AttackAction a, AttackAction b)
        {
            return a.TargetId == b.TargetId &&
                a.Damage == b.Damage;
        }

        public static byte[] Encode(AttackAction obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(AttackAction obj, Encoder encoder)
        {
            encoder.PushString(obj.TargetId);
            encoder.PushBoundedInt(obj.Damage, 0);
        }

        public static byte[] EncodeDiff(AttackAction a, AttackAction b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(AttackAction a, AttackAction b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushStringDiff(a.TargetId, b.TargetId);
            encoder.PushBoundedIntDiff(a.Damage, b.Damage, 0);
        }

        public static new AttackAction Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static new AttackAction DecodeInternal(Decoder decoder)
        {
            return new AttackAction
            {
                TargetId = decoder.NextString(),
                Damage = decoder.NextBoundedInt(0),
            };
        }

        public static AttackAction DecodeDiff(AttackAction obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static AttackAction DecodeDiffInternal(AttackAction obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new AttackAction
            {
                TargetId = decoder.NextStringDiff(obj.TargetId),
                Damage = decoder.NextBoundedIntDiff(obj.Damage, 0),
            };
        }
    }

    public class UseItemAction : GameAction
    {
        public override string Type => "UseItemAction";

        public string ItemId { get; set; } = "";

        public static new UseItemAction Default() => new UseItemAction();

        public static new UseItemAction FromJson(JsonElement json)
        {
            return new UseItemAction
            {
                ItemId = json.GetProperty("itemId").GetString() ?? "",
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["itemId"] = ItemId;
            return result;
        }

        public static UseItemAction Clone(UseItemAction obj)
        {
            return new UseItemAction
            {
                ItemId = obj.ItemId,
            };
        }

        public static bool Equals(UseItemAction a, UseItemAction b)
        {
            return a.ItemId == b.ItemId;
        }

        public static byte[] Encode(UseItemAction obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(UseItemAction obj, Encoder encoder)
        {
            encoder.PushString(obj.ItemId);
        }

        public static byte[] EncodeDiff(UseItemAction a, UseItemAction b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(UseItemAction a, UseItemAction b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushStringDiff(a.ItemId, b.ItemId);
        }

        public static new UseItemAction Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static new UseItemAction DecodeInternal(Decoder decoder)
        {
            return new UseItemAction
            {
                ItemId = decoder.NextString(),
            };
        }

        public static UseItemAction DecodeDiff(UseItemAction obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static UseItemAction DecodeDiffInternal(UseItemAction obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new UseItemAction
            {
                ItemId = decoder.NextStringDiff(obj.ItemId),
            };
        }
    }

    public abstract class GameAction
    {
        public abstract string Type { get; }

        public static GameAction Default() => MoveAction.Default();

        public static GameAction FromJson(JsonElement json)
        {
            if (json.TryGetProperty("type", out var typeEl) && json.TryGetProperty("val", out var val))
            {
                var typeName = typeEl.GetString();
                if (typeName == "MoveAction") return MoveAction.FromJson(val);
                else if (typeName == "AttackAction") return AttackAction.FromJson(val);
                else if (typeName == "UseItemAction") return UseItemAction.FromJson(val);
                throw new InvalidOperationException($"Unknown GameAction type: {typeName}");
            }
            // Protobuf format: { "TypeName": {...} }
            var prop = json.EnumerateObject().FirstOrDefault();
            if (prop.Value.ValueKind != JsonValueKind.Undefined)
            {
                var typeName = prop.Name;
                var valProp = prop.Value;
                if (typeName == "MoveAction") return MoveAction.FromJson(valProp);
                else if (typeName == "AttackAction") return AttackAction.FromJson(valProp);
                else if (typeName == "UseItemAction") return UseItemAction.FromJson(valProp);
            }
            throw new InvalidOperationException("Invalid GameAction format");
        }

        public static JsonObject ToJson(GameAction obj)
        {
            if (obj is MoveAction moveAction) return new JsonObject { ["MoveAction"] = moveAction.ToJson() };
            else if (obj is AttackAction attackAction) return new JsonObject { ["AttackAction"] = attackAction.ToJson() };
            else if (obj is UseItemAction useItemAction) return new JsonObject { ["UseItemAction"] = useItemAction.ToJson() };
            throw new InvalidOperationException($"Unknown GameAction type: {obj.Type}");
        }

        public static GameAction Clone(GameAction obj)
        {
            if (obj is MoveAction moveAction) return MoveAction.Clone(moveAction);
            else if (obj is AttackAction attackAction) return AttackAction.Clone(attackAction);
            else if (obj is UseItemAction useItemAction) return UseItemAction.Clone(useItemAction);
            throw new InvalidOperationException($"Unknown GameAction type: {obj.Type}");
        }

        public static bool Equals(GameAction a, GameAction b)
        {
            if (a.Type != b.Type) return false;
            if (a is MoveAction moveActionA && b is MoveAction moveActionB) return MoveAction.Equals(moveActionA, moveActionB);
            else if (a is AttackAction attackActionA && b is AttackAction attackActionB) return AttackAction.Equals(attackActionA, attackActionB);
            else if (a is UseItemAction useItemActionA && b is UseItemAction useItemActionB) return UseItemAction.Equals(useItemActionA, useItemActionB);
            return false;
        }

        public static byte[] Encode(GameAction obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(GameAction obj, Encoder encoder)
        {
            if (obj is MoveAction moveAction)
            {
                encoder.PushEnum(0, 2);
                MoveAction.EncodeInternal(moveAction, encoder);
            }
            else if (obj is AttackAction attackAction)
            {
                encoder.PushEnum(1, 2);
                AttackAction.EncodeInternal(attackAction, encoder);
            }
            else if (obj is UseItemAction useItemAction)
            {
                encoder.PushEnum(2, 2);
                UseItemAction.EncodeInternal(useItemAction, encoder);
            }
        }

        public static byte[] EncodeDiff(GameAction a, GameAction b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(GameAction a, GameAction b, Encoder encoder)
        {
            encoder.PushBoolean(a.Type == b.Type);
            if (b is MoveAction moveActionB)
            {
                if (a is MoveAction moveActionA)
                {
                    MoveAction.EncodeDiffInternal(moveActionA, moveActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(0, 2);
                    MoveAction.EncodeInternal(moveActionB, encoder);
                }
            }
            else if (b is AttackAction attackActionB)
            {
                if (a is AttackAction attackActionA)
                {
                    AttackAction.EncodeDiffInternal(attackActionA, attackActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(1, 2);
                    AttackAction.EncodeInternal(attackActionB, encoder);
                }
            }
            else if (b is UseItemAction useItemActionB)
            {
                if (a is UseItemAction useItemActionA)
                {
                    UseItemAction.EncodeDiffInternal(useItemActionA, useItemActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(2, 2);
                    UseItemAction.EncodeInternal(useItemActionB, encoder);
                }
            }
        }

        public static GameAction Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static GameAction DecodeInternal(Decoder decoder)
        {
            var type = decoder.NextEnum(2);
            if (type == 0) return MoveAction.DecodeInternal(decoder);
            else if (type == 1) return AttackAction.DecodeInternal(decoder);
            else if (type == 2) return UseItemAction.DecodeInternal(decoder);
            throw new InvalidOperationException("Invalid GameAction union");
        }

        public static GameAction DecodeDiff(GameAction obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static GameAction DecodeDiffInternal(GameAction obj, Decoder decoder)
        {
            var isSameType = decoder.NextBoolean();
            if (isSameType)
            {
                if (obj is MoveAction moveAction) return MoveAction.DecodeDiffInternal(moveAction, decoder);
                else if (obj is AttackAction attackAction) return AttackAction.DecodeDiffInternal(attackAction, decoder);
                else if (obj is UseItemAction useItemAction) return UseItemAction.DecodeDiffInternal(useItemAction, decoder);
                throw new InvalidOperationException("Invalid GameAction diff");
            }
            else
            {
                var type = decoder.NextEnum(2);
                if (type == 0) return MoveAction.DecodeInternal(decoder);
                else if (type == 1) return AttackAction.DecodeInternal(decoder);
                else if (type == 2) return UseItemAction.DecodeInternal(decoder);
                throw new InvalidOperationException("Invalid GameAction diff");
            }
        }
    }

    public class GameState
    {
        public List<Player> Players { get; set; } = new List<Player>();
        public string? CurrentPlayer { get; set; }
        public long Round { get; set; }
        public Dictionary<string, string> Metadata { get; set; } = new Dictionary<string, string>();
        public Color? WinningColor { get; set; }
        public GameAction? LastAction { get; set; }

        public static GameState Default() => new GameState();

        public static GameState FromJson(JsonElement json)
        {
            return new GameState
            {
                Players = json.GetProperty("players").EnumerateArray().Select(x => Generated.Player.FromJson(x)).ToList(),
                CurrentPlayer = json.TryGetProperty("currentPlayer", out var currentPlayerEl) ? currentPlayerEl.ValueKind == JsonValueKind.Null ? null : currentPlayerEl.GetString() ?? "" : null,
                Round = json.GetProperty("round").GetInt64(),
                Metadata = json.GetProperty("metadata").EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetString() ?? ""),
                WinningColor = json.TryGetProperty("winningColor", out var winningColorEl) ? winningColorEl.ValueKind == JsonValueKind.Null ? null : Enum.Parse<Color>(winningColorEl.GetString()!, true) : null,
                LastAction = json.TryGetProperty("lastAction", out var lastActionEl) ? lastActionEl.ValueKind == JsonValueKind.Null ? null : Generated.GameAction.FromJson(lastActionEl) : null,
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["players"] = new JsonArray(Players.Select(x => (JsonNode?)x.ToJson()).ToArray());
            if (CurrentPlayer != null) result["currentPlayer"] = CurrentPlayer;
            result["round"] = Round;
            result["metadata"] = new JsonObject(Metadata.Select(kvp => new KeyValuePair<string, JsonNode?>(kvp.Key, kvp.Value)));
            if (WinningColor.HasValue) result["winningColor"] = WinningColor.ToString();
            if (LastAction != null) result["lastAction"] = Generated.GameAction.ToJson(LastAction);
            return result;
        }

        public static GameState Clone(GameState obj)
        {
            return new GameState
            {
                Players = obj.Players.Select(x => Generated.Player.Clone(x)).ToList(),
                CurrentPlayer = obj.CurrentPlayer,
                Round = obj.Round,
                Metadata = new Dictionary<string, string>(obj.Metadata),
                WinningColor = obj.WinningColor,
                LastAction = obj.LastAction != null ? Generated.GameAction.Clone(obj.LastAction) : null,
            };
        }

        public static bool Equals(GameState a, GameState b)
        {
            return a.Players.Count == b.Players.Count && a.Players.Zip(b.Players).All(pair => Generated.Player.Equals(pair.First, pair.Second)) &&
                a.CurrentPlayer == b.CurrentPlayer &&
                a.Round == b.Round &&
                a.Metadata.Count == b.Metadata.Count && a.Metadata.All(kvp => b.Metadata.TryGetValue(kvp.Key, out var v) && kvp.Value == v) &&
                a.WinningColor == b.WinningColor &&
                (a.LastAction == null && b.LastAction == null || a.LastAction != null && b.LastAction != null && Generated.GameAction.Equals(a.LastAction, b.LastAction));
        }

        public static byte[] Encode(GameState obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(GameState obj, Encoder encoder)
        {
            encoder.PushArray(obj.Players, x => Generated.Player.EncodeInternal(x, encoder));
            encoder.PushOptional(obj.CurrentPlayer, x => encoder.PushString(x));
            encoder.PushBoundedInt(obj.Round, 0);
            encoder.PushRecord(obj.Metadata, x => encoder.PushString(x), x => encoder.PushString(x));
            encoder.PushBoolean(obj.WinningColor.HasValue);
            if (obj.WinningColor.HasValue) encoder.PushEnum((int)obj.WinningColor.Value, 2);
            encoder.PushOptional(obj.LastAction, x => Generated.GameAction.EncodeInternal(x, encoder));
        }

        public static byte[] EncodeDiff(GameState a, GameState b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(GameState a, GameState b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushArrayDiff<Player>(a.Players, b.Players, (x, y) => Generated.Player.Equals(x, y), x => Generated.Player.EncodeInternal(x, encoder), (x, y) => Generated.Player.EncodeDiffInternal(x, y, encoder));
            encoder.PushOptionalDiffPrimitive<string>(a.CurrentPlayer, b.CurrentPlayer, x => encoder.PushString(x));
            encoder.PushBoundedIntDiff(a.Round, b.Round, 0);
            encoder.PushRecordDiff<string, string>(a.Metadata, b.Metadata, (x, y) => x == y, x => encoder.PushString(x), x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y));
            {
                var eq = a.WinningColor == b.WinningColor;
                encoder.PushBoolean(!eq);
                if (!eq)
                {
                    encoder.PushBoolean(b.WinningColor.HasValue);
                    if (b.WinningColor.HasValue) encoder.PushEnum((int)b.WinningColor.Value, 2);
                }
            }
            encoder.PushOptionalDiff<GameAction>(a.LastAction, b.LastAction, x => Generated.GameAction.EncodeInternal(x, encoder), (x, y) => Generated.GameAction.EncodeDiffInternal(x, y, encoder));
        }

        public static GameState Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static GameState DecodeInternal(Decoder decoder)
        {
            return new GameState
            {
                Players = decoder.NextArray(() => Generated.Player.DecodeInternal(decoder)),
                CurrentPlayer = decoder.NextOptional(() => decoder.NextString()),
                Round = decoder.NextBoundedInt(0),
                Metadata = decoder.NextRecord(() => decoder.NextString(), () => decoder.NextString()),
                WinningColor = decoder.NextBoolean() ? (Color?)decoder.NextEnum(2) : null,
                LastAction = decoder.NextOptional(() => Generated.GameAction.DecodeInternal(decoder)),
            };
        }

        public static GameState DecodeDiff(GameState obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static GameState DecodeDiffInternal(GameState obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new GameState
            {
                Players = decoder.NextArrayDiff<Player>(obj.Players, () => Generated.Player.DecodeInternal(decoder), x => Generated.Player.DecodeDiffInternal(x, decoder)),
                CurrentPlayer = decoder.NextOptionalDiffPrimitive<string>(obj.CurrentPlayer, () => decoder.NextString()),
                Round = decoder.NextBoundedIntDiff(obj.Round, 0),
                Metadata = decoder.NextRecordDiff<string, string>(obj.Metadata, () => decoder.NextString(), () => decoder.NextString(), x => decoder.NextStringDiff(x)),
                WinningColor = decoder.NextBoolean() ? (decoder.NextBoolean() ? (Color?)decoder.NextEnum(2) : null) : obj.WinningColor,
                LastAction = decoder.NextOptionalDiff<GameAction>(obj.LastAction, () => Generated.GameAction.DecodeInternal(decoder), x => Generated.GameAction.DecodeDiffInternal(x, decoder)),
            };
        }
    }

    public class Inventory
    {
        public List<Dictionary<string, long>>? Items { get; set; }

        public static Inventory Default() => new Inventory();

        public static Inventory FromJson(JsonElement json)
        {
            return new Inventory
            {
                Items = json.TryGetProperty("items", out var itemsEl) ? itemsEl.ValueKind == JsonValueKind.Null ? null : itemsEl.EnumerateArray().Select(x => x.EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetInt64())).ToList() : null,
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            if (Items != null) result["items"] = new JsonArray(Items.Select(x => (JsonNode?)new JsonObject(x.Select(kvp => new KeyValuePair<string, JsonNode?>(kvp.Key, kvp.Value)))).ToArray());
            return result;
        }

        public static Inventory Clone(Inventory obj)
        {
            return new Inventory
            {
                Items = obj.Items != null ? obj.Items.Select(x => new Dictionary<string, long>(x)).ToList() : null,
            };
        }

        public static bool Equals(Inventory a, Inventory b)
        {
            return (a.Items == null && b.Items == null || a.Items != null && b.Items != null && a.Items.Count == b.Items.Count && a.Items.Zip(b.Items).All(pair => pair.First.Count == pair.Second.Count && pair.First.All(kvp => pair.Second.TryGetValue(kvp.Key, out var v) && kvp.Value == v)));
        }

        public static byte[] Encode(Inventory obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(Inventory obj, Encoder encoder)
        {
            encoder.PushOptional(obj.Items, x => encoder.PushArray(x, x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x))));
        }

        public static byte[] EncodeDiff(Inventory a, Inventory b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(Inventory a, Inventory b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushOptionalDiff<List<Dictionary<string, long>>>(a.Items, b.Items, x => encoder.PushArray(x, x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x))), (x, y) => encoder.PushArrayDiff<Dictionary<string, long>>(x, y, (x, y) => x.Count == y.Count && x.All(kvp => y.TryGetValue(kvp.Key, out var v) && kvp.Value == v), x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x)), (x, y) => encoder.PushRecordDiff<string, long>(x, y, (x, y) => x == y, x => encoder.PushString(x), x => encoder.PushInt(x), (x, y) => encoder.PushIntDiff(x, y))));
        }

        public static Inventory Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static Inventory DecodeInternal(Decoder decoder)
        {
            return new Inventory
            {
                Items = decoder.NextOptional(() => decoder.NextArray(() => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt()))),
            };
        }

        public static Inventory DecodeDiff(Inventory obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static Inventory DecodeDiffInternal(Inventory obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new Inventory
            {
                Items = decoder.NextOptionalDiff<List<Dictionary<string, long>>>(obj.Items, () => decoder.NextArray(() => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt())), x => decoder.NextArrayDiff<Dictionary<string, long>>(x, () => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt()), x => decoder.NextRecordDiff<string, long>(x, () => decoder.NextString(), () => decoder.NextInt(), x => decoder.NextIntDiff(x)))),
            };
        }
    }

    public class PlayerRegistry
    {
        public Dictionary<string, Player> Players { get; set; } = new Dictionary<string, Player>();

        public static PlayerRegistry Default() => new PlayerRegistry();

        public static PlayerRegistry FromJson(JsonElement json)
        {
            return new PlayerRegistry
            {
                Players = json.GetProperty("players").EnumerateObject().ToDictionary(p => p.Name, p => Generated.Player.FromJson(p.Value)),
            };
        }

        public JsonObject ToJson()
        {
            var result = new JsonObject();
            result["players"] = new JsonObject(Players.Select(kvp => new KeyValuePair<string, JsonNode?>(kvp.Key, kvp.Value.ToJson())));
            return result;
        }

        public static PlayerRegistry Clone(PlayerRegistry obj)
        {
            return new PlayerRegistry
            {
                Players = obj.Players.ToDictionary(kvp => kvp.Key, kvp => Generated.Player.Clone(kvp.Value)),
            };
        }

        public static bool Equals(PlayerRegistry a, PlayerRegistry b)
        {
            return a.Players.Count == b.Players.Count && a.Players.All(kvp => b.Players.TryGetValue(kvp.Key, out var v) && Generated.Player.Equals(kvp.Value, v));
        }

        public static byte[] Encode(PlayerRegistry obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(PlayerRegistry obj, Encoder encoder)
        {
            encoder.PushRecord(obj.Players, x => encoder.PushString(x), x => Generated.Player.EncodeInternal(x, encoder));
        }

        public static byte[] EncodeDiff(PlayerRegistry a, PlayerRegistry b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(PlayerRegistry a, PlayerRegistry b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
            encoder.PushRecordDiff<string, Player>(a.Players, b.Players, (x, y) => Generated.Player.Equals(x, y), x => encoder.PushString(x), x => Generated.Player.EncodeInternal(x, encoder), (x, y) => Generated.Player.EncodeDiffInternal(x, y, encoder));
        }

        public static PlayerRegistry Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static PlayerRegistry DecodeInternal(Decoder decoder)
        {
            return new PlayerRegistry
            {
                Players = decoder.NextRecord(() => decoder.NextString(), () => Generated.Player.DecodeInternal(decoder)),
            };
        }

        public static PlayerRegistry DecodeDiff(PlayerRegistry obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static PlayerRegistry DecodeDiffInternal(PlayerRegistry obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new PlayerRegistry
            {
                Players = decoder.NextRecordDiff<string, Player>(obj.Players, () => decoder.NextString(), () => Generated.Player.DecodeInternal(decoder), x => Generated.Player.DecodeDiffInternal(x, decoder)),
            };
        }
    }
}
