// Auto-generated by DeltaPack - do not edit
using System.Linq;

namespace Generated
{
    public enum Color
    {
        RED = 0,
        BLUE = 1,
        GREEN = 2,
        YELLOW = 3
    }

    public class Player
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public long Score { get; set; }
        public bool IsActive { get; set; }
        public Player? Partner { get; set; }

        public static Player Default() => new();

        public static Player FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Id = DeltaPack.JsonHelpers.ParseString(json.GetProperty("id")),
                Name = DeltaPack.JsonHelpers.ParseString(json.GetProperty("name")),
                Score = json.GetProperty("score").GetInt64(),
                IsActive = DeltaPack.JsonHelpers.ParseBoolean(json.GetProperty("isActive")),
                Partner = json.TryGetProperty("partner", out var partnerEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(partnerEl) ? null : Player.FromJson(partnerEl) : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Player obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["id"] = obj.Id;
            result["name"] = obj.Name;
            result["score"] = obj.Score;
            result["isActive"] = obj.IsActive;
            if (obj.Partner != null) result["partner"] = Player.ToJson(obj.Partner);
            return result;
        }

        public static Player Clone(Player obj)
        {
            return new()
            {
                Id = obj.Id,
                Name = obj.Name,
                Score = obj.Score,
                IsActive = obj.IsActive,
                Partner = obj.Partner != null ? Player.Clone(obj.Partner) : null,
            };
        }

        public static bool Equals(Player a, Player b)
        {
            return a.Id == b.Id &&
                a.Name == b.Name &&
                a.Score == b.Score &&
                a.IsActive == b.IsActive &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.Partner, b.Partner, (x, y) => Player.Equals(x, y));
        }

        public static byte[] Encode(Player obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Player obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.Id);
            encoder.PushString(obj.Name);
            encoder.PushInt(obj.Score);
            encoder.PushBoolean(obj.IsActive);
            encoder.PushOptional(obj.Partner, x => Player.Encode_(x, encoder));
        }

        public static byte[] EncodeDiff(Player a, Player b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Player a, Player b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<string>(a.Id, b.Id, (x, y) => x == y, (x, y) => encoder.PushStringDiff(x, y));
            encoder.PushFieldDiff<string>(a.Name, b.Name, (x, y) => x == y, (x, y) => encoder.PushStringDiff(x, y));
            encoder.PushFieldDiff<long>(a.Score, b.Score, (x, y) => x == y, (x, y) => encoder.PushIntDiff(x, y));
            encoder.PushBooleanDiff(a.IsActive, b.IsActive);
            encoder.PushFieldDiff<Player?>(a.Partner, b.Partner, (x, y) => DeltaPack.EqualityHelpers.EqualsOptional(x, y, (x, y) => Player.Equals(x, y)), (x, y) => encoder.PushOptionalDiff<Player>(x, y, x => Player.Encode_(x, encoder), (x, y) => Player.EncodeDiff_(x, y, encoder)));
        }

        public static Player Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Player Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Id = decoder.NextString(),
                Name = decoder.NextString(),
                Score = decoder.NextInt(),
                IsActive = decoder.NextBoolean(),
                Partner = decoder.NextOptional(() => Player.Decode_(decoder)),
            };
        }

        public static Player DecodeDiff(Player obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static Player DecodeDiff_(Player obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Id = decoder.NextFieldDiff(obj.Id, x => decoder.NextStringDiff(x)),
                Name = decoder.NextFieldDiff(obj.Name, x => decoder.NextStringDiff(x)),
                Score = decoder.NextFieldDiff(obj.Score, x => decoder.NextIntDiff(x)),
                IsActive = decoder.NextBooleanDiff(obj.IsActive),
                Partner = decoder.NextFieldDiff(obj.Partner, x => decoder.NextOptionalDiff<Player>(x, () => Player.Decode_(decoder), x => Player.DecodeDiff_(x, decoder))),
            };
        }
    }

    public class Position
    {
        public float X { get; set; }
        public float Y { get; set; }

        public static Position Default() => new();

        public static Position FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                X = DeltaPack.JsonHelpers.ParseFloatQuantized(json.GetProperty("x"), 0.1f),
                Y = DeltaPack.JsonHelpers.ParseFloatQuantized(json.GetProperty("y"), 0.1f),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Position obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["x"] = obj.X;
            result["y"] = obj.Y;
            return result;
        }

        public static Position Clone(Position obj)
        {
            return new()
            {
                X = obj.X,
                Y = obj.Y,
            };
        }

        public static bool Equals(Position a, Position b)
        {
            return DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.X, b.X, 0.1f) &&
                DeltaPack.EqualityHelpers.EqualsFloatQuantized(a.Y, b.Y, 0.1f);
        }

        public static byte[] Encode(Position obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Position obj, DeltaPack.Encoder encoder)
        {
            encoder.PushFloatQuantized(obj.X, 0.1f);
            encoder.PushFloatQuantized(obj.Y, 0.1f);
        }

        public static byte[] EncodeDiff(Position a, Position b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Position a, Position b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<float>(a.X, b.X, (x, y) => DeltaPack.EqualityHelpers.EqualsFloatQuantized(x, y, 0.1f), (x, y) => encoder.PushFloatQuantizedDiff(x, y, 0.1f));
            encoder.PushFieldDiff<float>(a.Y, b.Y, (x, y) => DeltaPack.EqualityHelpers.EqualsFloatQuantized(x, y, 0.1f), (x, y) => encoder.PushFloatQuantizedDiff(x, y, 0.1f));
        }

        public static Position Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Position Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextFloatQuantized(0.1f),
                Y = decoder.NextFloatQuantized(0.1f),
            };
        }

        public static Position DecodeDiff(Position obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static Position DecodeDiff_(Position obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextFieldDiff(obj.X, x => decoder.NextFloatQuantizedDiff(x, 0.1f)),
                Y = decoder.NextFieldDiff(obj.Y, x => decoder.NextFloatQuantizedDiff(x, 0.1f)),
            };
        }
    }

    public class Velocity
    {
        public float Vx { get; set; }
        public float Vy { get; set; }

        public static Velocity Default() => new();

        public static Velocity FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Vx = json.GetProperty("vx").GetSingle(),
                Vy = json.GetProperty("vy").GetSingle(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Velocity obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["vx"] = obj.Vx;
            result["vy"] = obj.Vy;
            return result;
        }

        public static Velocity Clone(Velocity obj)
        {
            return new()
            {
                Vx = obj.Vx,
                Vy = obj.Vy,
            };
        }

        public static bool Equals(Velocity a, Velocity b)
        {
            return DeltaPack.EqualityHelpers.EqualsFloat(a.Vx, b.Vx) &&
                DeltaPack.EqualityHelpers.EqualsFloat(a.Vy, b.Vy);
        }

        public static byte[] Encode(Velocity obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Velocity obj, DeltaPack.Encoder encoder)
        {
            encoder.PushFloat(obj.Vx);
            encoder.PushFloat(obj.Vy);
        }

        public static byte[] EncodeDiff(Velocity a, Velocity b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Velocity a, Velocity b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<float>(a.Vx, b.Vx, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y), (x, y) => encoder.PushFloatDiff(x, y));
            encoder.PushFieldDiff<float>(a.Vy, b.Vy, (x, y) => DeltaPack.EqualityHelpers.EqualsFloat(x, y), (x, y) => encoder.PushFloatDiff(x, y));
        }

        public static Velocity Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Velocity Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Vx = decoder.NextFloat(),
                Vy = decoder.NextFloat(),
            };
        }

        public static Velocity DecodeDiff(Velocity obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static Velocity DecodeDiff_(Velocity obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Vx = decoder.NextFieldDiff(obj.Vx, x => decoder.NextFloatDiff(x)),
                Vy = decoder.NextFieldDiff(obj.Vy, x => decoder.NextFloatDiff(x)),
            };
        }
    }

    public class Entity
    {
        public string Id { get; set; } = "";
        public Position Position { get; set; } = Position.Default();

        public static Entity Default() => new();

        public static Entity FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Id = DeltaPack.JsonHelpers.ParseString(json.GetProperty("id")),
                Position = Position.FromJson(json.GetProperty("position")),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Entity obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["id"] = obj.Id;
            result["position"] = Position.ToJson(obj.Position);
            return result;
        }

        public static Entity Clone(Entity obj)
        {
            return new()
            {
                Id = obj.Id,
                Position = Position.Clone(obj.Position),
            };
        }

        public static bool Equals(Entity a, Entity b)
        {
            return a.Id == b.Id &&
                Position.Equals(a.Position, b.Position);
        }

        public static byte[] Encode(Entity obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Entity obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.Id);
            Position.Encode_(obj.Position, encoder);
        }

        public static byte[] EncodeDiff(Entity a, Entity b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Entity a, Entity b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<string>(a.Id, b.Id, (x, y) => x == y, (x, y) => encoder.PushStringDiff(x, y));
            encoder.PushFieldDiff<Position>(a.Position, b.Position, (x, y) => Generated.Position.Equals(x, y), (x, y) => Generated.Position.EncodeDiff_(x, y, encoder));
        }

        public static Entity Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Entity Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Id = decoder.NextString(),
                Position = Position.Decode_(decoder),
            };
        }

        public static Entity DecodeDiff(Entity obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static Entity DecodeDiff_(Entity obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Id = decoder.NextFieldDiff(obj.Id, x => decoder.NextStringDiff(x)),
                Position = decoder.NextFieldDiff(obj.Position, x => Generated.Position.DecodeDiff_(x, decoder)),
            };
        }
    }

    public class MoveAction : GameAction
    {
        public override string Type => "MoveAction";

        public long X { get; set; }
        public long Y { get; set; }

        public static new MoveAction Default() => new();

        public static new MoveAction FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                X = json.GetProperty("x").GetInt64(),
                Y = json.GetProperty("y").GetInt64(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(MoveAction obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["x"] = obj.X;
            result["y"] = obj.Y;
            return result;
        }

        public static MoveAction Clone(MoveAction obj)
        {
            return new()
            {
                X = obj.X,
                Y = obj.Y,
            };
        }

        public static bool Equals(MoveAction a, MoveAction b)
        {
            return a.X == b.X &&
                a.Y == b.Y;
        }

        public static byte[] Encode(MoveAction obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(MoveAction obj, DeltaPack.Encoder encoder)
        {
            encoder.PushInt(obj.X);
            encoder.PushInt(obj.Y);
        }

        public static byte[] EncodeDiff(MoveAction a, MoveAction b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(MoveAction a, MoveAction b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<long>(a.X, b.X, (x, y) => x == y, (x, y) => encoder.PushIntDiff(x, y));
            encoder.PushFieldDiff<long>(a.Y, b.Y, (x, y) => x == y, (x, y) => encoder.PushIntDiff(x, y));
        }

        public static new MoveAction Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static new MoveAction Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextInt(),
                Y = decoder.NextInt(),
            };
        }

        public static MoveAction DecodeDiff(MoveAction obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static MoveAction DecodeDiff_(MoveAction obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                X = decoder.NextFieldDiff(obj.X, x => decoder.NextIntDiff(x)),
                Y = decoder.NextFieldDiff(obj.Y, x => decoder.NextIntDiff(x)),
            };
        }
    }

    public class AttackAction : GameAction
    {
        public override string Type => "AttackAction";

        public string TargetId { get; set; } = "";
        public long Damage { get; set; }

        public static new AttackAction Default() => new();

        public static new AttackAction FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                TargetId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("targetId")),
                Damage = json.GetProperty("damage").GetInt64(),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(AttackAction obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["targetId"] = obj.TargetId;
            result["damage"] = obj.Damage;
            return result;
        }

        public static AttackAction Clone(AttackAction obj)
        {
            return new()
            {
                TargetId = obj.TargetId,
                Damage = obj.Damage,
            };
        }

        public static bool Equals(AttackAction a, AttackAction b)
        {
            return a.TargetId == b.TargetId &&
                a.Damage == b.Damage;
        }

        public static byte[] Encode(AttackAction obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(AttackAction obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.TargetId);
            encoder.PushBoundedInt(obj.Damage, 0);
        }

        public static byte[] EncodeDiff(AttackAction a, AttackAction b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(AttackAction a, AttackAction b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<string>(a.TargetId, b.TargetId, (x, y) => x == y, (x, y) => encoder.PushStringDiff(x, y));
            encoder.PushFieldDiff<long>(a.Damage, b.Damage, (x, y) => x == y, (x, y) => encoder.PushBoundedIntDiff(x, y, 0));
        }

        public static new AttackAction Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static new AttackAction Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                TargetId = decoder.NextString(),
                Damage = decoder.NextBoundedInt(0),
            };
        }

        public static AttackAction DecodeDiff(AttackAction obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static AttackAction DecodeDiff_(AttackAction obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                TargetId = decoder.NextFieldDiff(obj.TargetId, x => decoder.NextStringDiff(x)),
                Damage = decoder.NextFieldDiff(obj.Damage, x => decoder.NextBoundedIntDiff(x, 0)),
            };
        }
    }

    public class UseItemAction : GameAction
    {
        public override string Type => "UseItemAction";

        public string ItemId { get; set; } = "";

        public static new UseItemAction Default() => new();

        public static new UseItemAction FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                ItemId = DeltaPack.JsonHelpers.ParseString(json.GetProperty("itemId")),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(UseItemAction obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["itemId"] = obj.ItemId;
            return result;
        }

        public static UseItemAction Clone(UseItemAction obj)
        {
            return new()
            {
                ItemId = obj.ItemId,
            };
        }

        public static bool Equals(UseItemAction a, UseItemAction b)
        {
            return a.ItemId == b.ItemId;
        }

        public static byte[] Encode(UseItemAction obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(UseItemAction obj, DeltaPack.Encoder encoder)
        {
            encoder.PushString(obj.ItemId);
        }

        public static byte[] EncodeDiff(UseItemAction a, UseItemAction b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(UseItemAction a, UseItemAction b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<string>(a.ItemId, b.ItemId, (x, y) => x == y, (x, y) => encoder.PushStringDiff(x, y));
        }

        public static new UseItemAction Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static new UseItemAction Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                ItemId = decoder.NextString(),
            };
        }

        public static UseItemAction DecodeDiff(UseItemAction obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static UseItemAction DecodeDiff_(UseItemAction obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                ItemId = decoder.NextFieldDiff(obj.ItemId, x => decoder.NextStringDiff(x)),
            };
        }
    }

    public abstract class GameAction
    {
        public abstract string Type { get; }

        public static GameAction Default() => MoveAction.Default();

        public static GameAction FromJson(System.Text.Json.JsonElement json)
        {
            if (json.TryGetProperty("type", out var typeEl) && json.TryGetProperty("val", out var val))
            {
                var typeName = DeltaPack.JsonHelpers.FindVariant(typeEl.GetString()!, "MoveAction", "AttackAction", "UseItemAction");
                if (typeName == "MoveAction") return MoveAction.FromJson(val);
                else if (typeName == "AttackAction") return AttackAction.FromJson(val);
                else if (typeName == "UseItemAction") return UseItemAction.FromJson(val);
                throw new System.InvalidOperationException($"Unknown GameAction type: {typeEl.GetString()}");
            }
            var prop = json.EnumerateObject().FirstOrDefault();
            if (prop.Value.ValueKind != System.Text.Json.JsonValueKind.Undefined)
            {
                var typeName = DeltaPack.JsonHelpers.FindVariant(prop.Name, "MoveAction", "AttackAction", "UseItemAction");
                var valProp = prop.Value;
                if (typeName == "MoveAction") return MoveAction.FromJson(valProp);
                else if (typeName == "AttackAction") return AttackAction.FromJson(valProp);
                else if (typeName == "UseItemAction") return UseItemAction.FromJson(valProp);
            }
            throw new System.InvalidOperationException("Invalid GameAction format");
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(GameAction obj)
        {
            if (obj is MoveAction moveAction) return new System.Text.Json.Nodes.JsonObject { ["MoveAction"] = MoveAction.ToJson(moveAction) };
            else if (obj is AttackAction attackAction) return new System.Text.Json.Nodes.JsonObject { ["AttackAction"] = AttackAction.ToJson(attackAction) };
            else if (obj is UseItemAction useItemAction) return new System.Text.Json.Nodes.JsonObject { ["UseItemAction"] = UseItemAction.ToJson(useItemAction) };
            throw new System.InvalidOperationException($"Unknown GameAction type: {obj.Type}");
        }

        public static GameAction Clone(GameAction obj)
        {
            if (obj is MoveAction moveAction) return MoveAction.Clone(moveAction);
            else if (obj is AttackAction attackAction) return AttackAction.Clone(attackAction);
            else if (obj is UseItemAction useItemAction) return UseItemAction.Clone(useItemAction);
            throw new System.InvalidOperationException($"Unknown GameAction type: {obj.Type}");
        }

        public static bool Equals(GameAction a, GameAction b)
        {
            if (a.Type != b.Type) return false;
            if (a is MoveAction moveActionA && b is MoveAction moveActionB) return MoveAction.Equals(moveActionA, moveActionB);
            else if (a is AttackAction attackActionA && b is AttackAction attackActionB) return AttackAction.Equals(attackActionA, attackActionB);
            else if (a is UseItemAction useItemActionA && b is UseItemAction useItemActionB) return UseItemAction.Equals(useItemActionA, useItemActionB);
            return false;
        }

        public static byte[] Encode(GameAction obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(GameAction obj, DeltaPack.Encoder encoder)
        {
            if (obj is MoveAction moveAction)
            {
                encoder.PushEnum(0, 2);
                MoveAction.Encode_(moveAction, encoder);
            }
            else if (obj is AttackAction attackAction)
            {
                encoder.PushEnum(1, 2);
                AttackAction.Encode_(attackAction, encoder);
            }
            else if (obj is UseItemAction useItemAction)
            {
                encoder.PushEnum(2, 2);
                UseItemAction.Encode_(useItemAction, encoder);
            }
        }

        public static byte[] EncodeDiff(GameAction a, GameAction b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(GameAction a, GameAction b, DeltaPack.Encoder encoder)
        {
            encoder.PushBoolean(a.Type == b.Type);
            if (b is MoveAction moveActionB)
            {
                if (a is MoveAction moveActionA)
                {
                    MoveAction.EncodeDiff_(moveActionA, moveActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(0, 2);
                    MoveAction.Encode_(moveActionB, encoder);
                }
            }
            else if (b is AttackAction attackActionB)
            {
                if (a is AttackAction attackActionA)
                {
                    AttackAction.EncodeDiff_(attackActionA, attackActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(1, 2);
                    AttackAction.Encode_(attackActionB, encoder);
                }
            }
            else if (b is UseItemAction useItemActionB)
            {
                if (a is UseItemAction useItemActionA)
                {
                    UseItemAction.EncodeDiff_(useItemActionA, useItemActionB, encoder);
                }
                else
                {
                    encoder.PushEnum(2, 2);
                    UseItemAction.Encode_(useItemActionB, encoder);
                }
            }
        }

        public static GameAction Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static GameAction Decode_(DeltaPack.Decoder decoder)
        {
            var type = decoder.NextEnum(2);
            if (type == 0) return MoveAction.Decode_(decoder);
            else if (type == 1) return AttackAction.Decode_(decoder);
            else if (type == 2) return UseItemAction.Decode_(decoder);
            throw new System.InvalidOperationException("Invalid GameAction union");
        }

        public static GameAction DecodeDiff(GameAction obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static GameAction DecodeDiff_(GameAction obj, DeltaPack.Decoder decoder)
        {
            var isSameType = decoder.NextBoolean();
            if (isSameType)
            {
                if (obj is MoveAction moveAction) return MoveAction.DecodeDiff_(moveAction, decoder);
                else if (obj is AttackAction attackAction) return AttackAction.DecodeDiff_(attackAction, decoder);
                else if (obj is UseItemAction useItemAction) return UseItemAction.DecodeDiff_(useItemAction, decoder);
                throw new System.InvalidOperationException("Invalid GameAction diff");
            }
            else
            {
                var type = decoder.NextEnum(2);
                if (type == 0) return MoveAction.Decode_(decoder);
                else if (type == 1) return AttackAction.Decode_(decoder);
                else if (type == 2) return UseItemAction.Decode_(decoder);
                throw new System.InvalidOperationException("Invalid GameAction diff");
            }
        }
    }

    public class GameState
    {
        public System.Collections.Generic.List<Player> Players { get; set; } = new System.Collections.Generic.List<Player>();
        public string? CurrentPlayer { get; set; }
        public long Round { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; } = new System.Collections.Generic.Dictionary<string, string>();
        public Color? WinningColor { get; set; }
        public GameAction? LastAction { get; set; }

        public static GameState Default() => new();

        public static GameState FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Players = json.GetProperty("players").EnumerateArray().Select(x => Player.FromJson(x)).ToList(),
                CurrentPlayer = json.TryGetProperty("currentPlayer", out var currentPlayerEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(currentPlayerEl) ? null : DeltaPack.JsonHelpers.ParseString(currentPlayerEl) : null,
                Round = json.GetProperty("round").GetInt64(),
                Metadata = json.GetProperty("metadata").EnumerateObject().ToDictionary(p => p.Name, p => DeltaPack.JsonHelpers.ParseString(p.Value)),
                WinningColor = json.TryGetProperty("winningColor", out var winningColorEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(winningColorEl) ? null : DeltaPack.JsonHelpers.ParseEnum<Color>(winningColorEl) : null,
                LastAction = json.TryGetProperty("lastAction", out var lastActionEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(lastActionEl) ? null : GameAction.FromJson(lastActionEl) : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(GameState obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["players"] = new System.Text.Json.Nodes.JsonArray(obj.Players.Select(x => (System.Text.Json.Nodes.JsonNode?)Player.ToJson(x)).ToArray());
            if (obj.CurrentPlayer != null) result["currentPlayer"] = obj.CurrentPlayer;
            result["round"] = obj.Round;
            result["metadata"] = new System.Text.Json.Nodes.JsonObject(obj.Metadata.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, kvp.Value)));
            if (obj.WinningColor.HasValue) result["winningColor"] = obj.WinningColor.ToString();
            if (obj.LastAction != null) result["lastAction"] = GameAction.ToJson(obj.LastAction);
            return result;
        }

        public static GameState Clone(GameState obj)
        {
            return new()
            {
                Players = obj.Players.Select(x => Player.Clone(x)).ToList(),
                CurrentPlayer = obj.CurrentPlayer,
                Round = obj.Round,
                Metadata = new System.Collections.Generic.Dictionary<string, string>(obj.Metadata),
                WinningColor = obj.WinningColor,
                LastAction = obj.LastAction != null ? GameAction.Clone(obj.LastAction) : null,
            };
        }

        public static bool Equals(GameState a, GameState b)
        {
            return a.Players.Count == b.Players.Count && a.Players.Zip(b.Players).All(pair => Player.Equals(pair.First, pair.Second)) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.CurrentPlayer, b.CurrentPlayer, (x, y) => x == y) &&
                a.Round == b.Round &&
                a.Metadata.Count == b.Metadata.Count && a.Metadata.All(kvp => b.Metadata.TryGetValue(kvp.Key, out var v) && kvp.Value == v) &&
                DeltaPack.EqualityHelpers.EqualsOptionalValue(a.WinningColor, b.WinningColor, (x, y) => x == y) &&
                DeltaPack.EqualityHelpers.EqualsOptional(a.LastAction, b.LastAction, (x, y) => GameAction.Equals(x, y));
        }

        public static byte[] Encode(GameState obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(GameState obj, DeltaPack.Encoder encoder)
        {
            encoder.PushArray(obj.Players, x => Player.Encode_(x, encoder));
            encoder.PushOptional(obj.CurrentPlayer, x => encoder.PushString(x));
            encoder.PushBoundedInt(obj.Round, 0);
            encoder.PushRecord(obj.Metadata, x => encoder.PushString(x), x => encoder.PushString(x));
            encoder.PushBoolean(obj.WinningColor.HasValue);
            if (obj.WinningColor.HasValue) encoder.PushEnum((int)obj.WinningColor.Value, 2);
            encoder.PushOptional(obj.LastAction, x => GameAction.Encode_(x, encoder));
        }

        public static byte[] EncodeDiff(GameState a, GameState b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(GameState a, GameState b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<System.Collections.Generic.List<Player>>(a.Players, b.Players, (x, y) => x.Count == y.Count && x.Zip(y).All(pair => Player.Equals(pair.First, pair.Second)), (x, y) => encoder.PushArrayDiff<Player>(x, y, (x, y) => Player.Equals(x, y), x => Player.Encode_(x, encoder), (x, y) => Player.EncodeDiff_(x, y, encoder)));
            encoder.PushFieldDiff<string?>(a.CurrentPlayer, b.CurrentPlayer, (x, y) => DeltaPack.EqualityHelpers.EqualsOptional(x, y, (x, y) => x == y), (x, y) => encoder.PushOptionalDiff<string>(x, y, x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y)));
            encoder.PushFieldDiff<long>(a.Round, b.Round, (x, y) => x == y, (x, y) => encoder.PushBoundedIntDiff(x, y, 0));
            encoder.PushFieldDiff<System.Collections.Generic.Dictionary<string, string>>(a.Metadata, b.Metadata, (x, y) => x.Count == y.Count && x.All(kvp => y.TryGetValue(kvp.Key, out var v) && kvp.Value == v), (x, y) => encoder.PushRecordDiff<string, string>(x, y, (x, y) => x == y, x => encoder.PushString(x), x => encoder.PushString(x), (x, y) => encoder.PushStringDiff(x, y)));
            encoder.PushFieldDiff<Color?>(a.WinningColor, b.WinningColor, (x, y) => DeltaPack.EqualityHelpers.EqualsOptionalValue(x, y, (x, y) => x == y), (x, y) => encoder.PushOptionalDiff<Color>(x, y, x => encoder.PushEnum((int)x, 2), (x, y) => encoder.PushEnumDiff((int)x, (int)y, 2)));
            encoder.PushFieldDiff<GameAction?>(a.LastAction, b.LastAction, (x, y) => DeltaPack.EqualityHelpers.EqualsOptional(x, y, (x, y) => GameAction.Equals(x, y)), (x, y) => encoder.PushOptionalDiff<GameAction>(x, y, x => GameAction.Encode_(x, encoder), (x, y) => GameAction.EncodeDiff_(x, y, encoder)));
        }

        public static GameState Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static GameState Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Players = decoder.NextArray(() => Player.Decode_(decoder)),
                CurrentPlayer = decoder.NextOptional(() => decoder.NextString()),
                Round = decoder.NextBoundedInt(0),
                Metadata = decoder.NextRecord(() => decoder.NextString(), () => decoder.NextString()),
                WinningColor = decoder.NextBoolean() ? (Color?)decoder.NextEnum(2) : null,
                LastAction = decoder.NextOptional(() => GameAction.Decode_(decoder)),
            };
        }

        public static GameState DecodeDiff(GameState obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static GameState DecodeDiff_(GameState obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Players = decoder.NextFieldDiff(obj.Players, x => decoder.NextArrayDiff<Player>(x, () => Player.Decode_(decoder), x => Player.DecodeDiff_(x, decoder))),
                CurrentPlayer = decoder.NextFieldDiff(obj.CurrentPlayer, x => decoder.NextOptionalDiff<string>(x, () => decoder.NextString(), x => decoder.NextStringDiff(x))),
                Round = decoder.NextFieldDiff(obj.Round, x => decoder.NextBoundedIntDiff(x, 0)),
                Metadata = decoder.NextFieldDiff(obj.Metadata, x => decoder.NextRecordDiff<string, string>(x, () => decoder.NextString(), () => decoder.NextString(), x => decoder.NextStringDiff(x))),
                WinningColor = decoder.NextFieldDiff(obj.WinningColor, x => decoder.NextOptionalDiff<Color>(x, () => (Color)decoder.NextEnum(2), x => (Color)decoder.NextEnumDiff((int)x, 2))),
                LastAction = decoder.NextFieldDiff(obj.LastAction, x => decoder.NextOptionalDiff<GameAction>(x, () => GameAction.Decode_(decoder), x => GameAction.DecodeDiff_(x, decoder))),
            };
        }
    }

    public class Inventory
    {
        public System.Collections.Generic.List<System.Collections.Generic.Dictionary<string, long>>? Items { get; set; }

        public static Inventory Default() => new();

        public static Inventory FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Items = json.TryGetProperty("items", out var itemsEl) ? DeltaPack.JsonHelpers.IsNullOrEmpty(itemsEl) ? null : itemsEl.EnumerateArray().Select(x => x.EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetInt64())).ToList() : null,
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(Inventory obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            if (obj.Items != null) result["items"] = new System.Text.Json.Nodes.JsonArray(obj.Items.Select(x => (System.Text.Json.Nodes.JsonNode?)new System.Text.Json.Nodes.JsonObject(x.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, kvp.Value)))).ToArray());
            return result;
        }

        public static Inventory Clone(Inventory obj)
        {
            return new()
            {
                Items = obj.Items != null ? obj.Items.Select(x => new System.Collections.Generic.Dictionary<string, long>(x)).ToList() : null,
            };
        }

        public static bool Equals(Inventory a, Inventory b)
        {
            return DeltaPack.EqualityHelpers.EqualsOptional(a.Items, b.Items, (x, y) => x.Count == y.Count && x.Zip(y).All(pair => pair.First.Count == pair.Second.Count && pair.First.All(kvp => pair.Second.TryGetValue(kvp.Key, out var v) && kvp.Value == v)));
        }

        public static byte[] Encode(Inventory obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(Inventory obj, DeltaPack.Encoder encoder)
        {
            encoder.PushOptional(obj.Items, x => encoder.PushArray(x, x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x))));
        }

        public static byte[] EncodeDiff(Inventory a, Inventory b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(Inventory a, Inventory b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<System.Collections.Generic.List<System.Collections.Generic.Dictionary<string, long>>?>(a.Items, b.Items, (x, y) => DeltaPack.EqualityHelpers.EqualsOptional(x, y, (x, y) => x.Count == y.Count && x.Zip(y).All(pair => pair.First.Count == pair.Second.Count && pair.First.All(kvp => pair.Second.TryGetValue(kvp.Key, out var v) && kvp.Value == v))), (x, y) => encoder.PushOptionalDiff<System.Collections.Generic.List<System.Collections.Generic.Dictionary<string, long>>>(x, y, x => encoder.PushArray(x, x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x))), (x, y) => encoder.PushArrayDiff<System.Collections.Generic.Dictionary<string, long>>(x, y, (x, y) => x.Count == y.Count && x.All(kvp => y.TryGetValue(kvp.Key, out var v) && kvp.Value == v), x => encoder.PushRecord(x, x => encoder.PushString(x), x => encoder.PushInt(x)), (x, y) => encoder.PushRecordDiff<string, long>(x, y, (x, y) => x == y, x => encoder.PushString(x), x => encoder.PushInt(x), (x, y) => encoder.PushIntDiff(x, y)))));
        }

        public static Inventory Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static Inventory Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Items = decoder.NextOptional(() => decoder.NextArray(() => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt()))),
            };
        }

        public static Inventory DecodeDiff(Inventory obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static Inventory DecodeDiff_(Inventory obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Items = decoder.NextFieldDiff(obj.Items, x => decoder.NextOptionalDiff<System.Collections.Generic.List<System.Collections.Generic.Dictionary<string, long>>>(x, () => decoder.NextArray(() => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt())), x => decoder.NextArrayDiff<System.Collections.Generic.Dictionary<string, long>>(x, () => decoder.NextRecord(() => decoder.NextString(), () => decoder.NextInt()), x => decoder.NextRecordDiff<string, long>(x, () => decoder.NextString(), () => decoder.NextInt(), x => decoder.NextIntDiff(x))))),
            };
        }
    }

    public class PlayerRegistry
    {
        public System.Collections.Generic.Dictionary<string, Player> Players { get; set; } = new System.Collections.Generic.Dictionary<string, Player>();

        public static PlayerRegistry Default() => new();

        public static PlayerRegistry FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
                Players = json.GetProperty("players").EnumerateObject().ToDictionary(p => p.Name, p => Player.FromJson(p.Value)),
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(PlayerRegistry obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
            result["players"] = new System.Text.Json.Nodes.JsonObject(obj.Players.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, Player.ToJson(kvp.Value))));
            return result;
        }

        public static PlayerRegistry Clone(PlayerRegistry obj)
        {
            return new()
            {
                Players = obj.Players.ToDictionary(kvp => kvp.Key, kvp => Player.Clone(kvp.Value)),
            };
        }

        public static bool Equals(PlayerRegistry a, PlayerRegistry b)
        {
            return a.Players.Count == b.Players.Count && a.Players.All(kvp => b.Players.TryGetValue(kvp.Key, out var v) && Player.Equals(kvp.Value, v));
        }

        public static byte[] Encode(PlayerRegistry obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(PlayerRegistry obj, DeltaPack.Encoder encoder)
        {
            encoder.PushRecord(obj.Players, x => encoder.PushString(x), x => Player.Encode_(x, encoder));
        }

        public static byte[] EncodeDiff(PlayerRegistry a, PlayerRegistry b)
        {
            var encoder = new DeltaPack.Encoder();
            encoder.PushObjectDiff(a, b, Equals, () => EncodeDiff_(a, b, encoder));
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(PlayerRegistry a, PlayerRegistry b, DeltaPack.Encoder encoder)
        {
            encoder.PushFieldDiff<System.Collections.Generic.Dictionary<string, Player>>(a.Players, b.Players, (x, y) => x.Count == y.Count && x.All(kvp => y.TryGetValue(kvp.Key, out var v) && Player.Equals(kvp.Value, v)), (x, y) => encoder.PushRecordDiff<string, Player>(x, y, (x, y) => Player.Equals(x, y), x => encoder.PushString(x), x => Player.Encode_(x, encoder), (x, y) => Player.EncodeDiff_(x, y, encoder)));
        }

        public static PlayerRegistry Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static PlayerRegistry Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
                Players = decoder.NextRecord(() => decoder.NextString(), () => Player.Decode_(decoder)),
            };
        }

        public static PlayerRegistry DecodeDiff(PlayerRegistry obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return decoder.NextObjectDiff(obj, () => DecodeDiff_(obj, decoder));
        }

        internal static PlayerRegistry DecodeDiff_(PlayerRegistry obj, DeltaPack.Decoder decoder)
        {
            return new()
            {
                Players = decoder.NextFieldDiff(obj.Players, x => decoder.NextRecordDiff<string, Player>(x, () => decoder.NextString(), () => Player.Decode_(decoder), x => Player.DecodeDiff_(x, decoder))),
            };
        }
    }
}
