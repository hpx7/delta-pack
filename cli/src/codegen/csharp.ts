import { Type, NamedType, isPrimitiveOrEnum } from "@hpx7/delta-pack";

export function codegenCsharp(
  schema: Record<string, Type>,
  namespace: string = "Generated",
): string {
  return renderSchema(schema, namespace);
}

function renderSchema(schema: Record<string, Type>, namespace: string): string {
  // Track the current type being processed for self-reference resolution
  let currentTypeName: string;

  // Qualify type name with namespace to avoid property names shadowing type names
  function qualifyType(typeName: string): string {
    return `${namespace}.${typeName}`;
  }

  // First pass: identify which types are union variants and their base types
  const variantToUnion = new Map<string, string>();
  for (const [name, type] of Object.entries(schema)) {
    if (type.type === "union") {
      for (const option of type.options) {
        variantToUnion.set(option.name!, name);
      }
    }
  }

  // Collect all types
  const enums: string[] = [];
  const classes: string[] = [];

  for (const [name, type] of Object.entries(schema)) {
    currentTypeName = name;
    if (type.type === "enum") {
      enums.push(renderEnum(name, type.options));
    } else if (type.type === "object") {
      const baseClass = variantToUnion.get(name);
      classes.push(renderObject(name, type.properties, baseClass));
    } else if (type.type === "union") {
      classes.push(renderUnion(name, type.options, type.numBits));
    }
  }

  return `// Auto-generated by DeltaPack - do not edit
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Nodes;
using DeltaPack;

namespace ${namespace}
{
${[...enums, ...classes].join("\n\n")}
}
`;

  function renderEnum(name: string, options: readonly string[]): string {
    const enumValues = options
      .map((opt, i) => `        ${toPascalCase(opt)} = ${i}`)
      .join(",\n");
    return `    public enum ${name}
    {
${enumValues}
    }`;
  }

  function renderObject(
    name: string,
    properties: Record<string, Type>,
    baseClass?: string,
  ): string {
    const props = Object.entries(properties);
    const isVariant = baseClass != null;

    // For union variants, add the Type property override
    const typeProperty = isVariant
      ? `        public override string Type => "${name}";\n\n`
      : "";

    // Properties
    const propertyLines = props
      .map(([propName, propType]) => {
        const csType = renderTypeArg(propType, propName);
        // Skip redundant defaults: numeric types default to 0, bool to false, nullable to null
        if (
          propType.type === "boolean" ||
          propType.type === "optional" ||
          propType.type === "int" ||
          propType.type === "float"
        ) {
          return `        public ${csType} ${toPascalCase(propName)} { get; set; }`;
        }
        const defaultVal = renderDefault(propType, propName);
        return `        public ${csType} ${toPascalCase(propName)} { get; set; } = ${defaultVal};`;
      })
      .join("\n");

    // Default method - use 'new' modifier for variants to hide base class method
    const newModifier = isVariant ? "new " : "";
    const defaultMethod = `        public static ${newModifier}${name} Default() => new ${name}();`;

    // FromJson method
    const fromJsonBody = props
      .map(([propName, propType]) => {
        if (propType.type === "optional") {
          // For optional types, use TryGetProperty to handle missing properties
          const varName = `${propName}El`;
          return `                ${toPascalCase(propName)} = json.TryGetProperty("${propName}", out var ${varName}) ? ${renderFromJson(propType, propName, varName)} : null,`;
        }
        return `                ${toPascalCase(propName)} = ${renderFromJson(propType, propName, `json.GetProperty("${propName}")`)},`;
      })
      .join("\n");

    const fromJsonMethod = `        public static ${newModifier}${name} FromJson(JsonElement json)
        {
            return new ${name}
            {
${fromJsonBody}
            };
        }`;

    // ToJson method - static like all other methods
    const toJsonBody = props
      .map(([propName, propType]) => {
        if (propType.type === "optional") {
          // Use .HasValue for value types, != null for reference types
          const nullCheck = isValueType(propType.value)
            ? `obj.${toPascalCase(propName)}.HasValue`
            : `obj.${toPascalCase(propName)} != null`;
          return `            if (${nullCheck}) result["${propName}"] = ${renderToJson(propType, propName, `obj.${toPascalCase(propName)}`)};`;
        }
        return `            result["${propName}"] = ${renderToJson(propType, propName, `obj.${toPascalCase(propName)}`)};`;
      })
      .join("\n");

    // ToJson doesn't need 'new' modifier for variants because the parameter type is different
    // (e.g., EmailContact.ToJson(EmailContact) vs Contact.ToJson(Contact))
    const toJsonMethod = `        public static JsonObject ToJson(${name} obj)
        {
            var result = new JsonObject();
${toJsonBody}
            return result;
        }`;

    // Clone method
    const cloneBody = props
      .map(([propName, propType]) => {
        return `                ${toPascalCase(propName)} = ${renderClone(propType, propName, `obj.${toPascalCase(propName)}`)},`;
      })
      .join("\n");

    const cloneMethod = `        public static ${name} Clone(${name} obj)
        {
            return new ${name}
            {
${cloneBody}
            };
        }`;

    // Equals method
    const equalsBody = props.map(([propName, propType]) => {
      return renderEquals(
        propType,
        propName,
        `a.${toPascalCase(propName)}`,
        `b.${toPascalCase(propName)}`,
      );
    });

    // Use 'new' only for classes that inherit from object (which has Equals)
    // For variants inheriting from union base, we don't need 'new' since base doesn't have a static Equals(T, T)
    const equalsMethod = `        public static bool Equals(${name} a, ${name} b)
        {
            return ${equalsBody.length > 0 ? equalsBody.join(" &&\n                ") : "true"};
        }`;

    // Encode method
    const encodeMethod = `        public static byte[] Encode(${name} obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }`;

    // EncodeInternal method
    const encodeInternalBody = props
      .map(([propName, propType]) => {
        return `            ${renderEncode(propType, propName, `obj.${toPascalCase(propName)}`)};`;
      })
      .join("\n");

    const encodeInternalMethod = `        internal static void EncodeInternal(${name} obj, Encoder encoder)
        {
${encodeInternalBody}
        }`;

    // EncodeDiff method
    const encodeDiffMethod = `        public static byte[] EncodeDiff(${name} a, ${name} b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }`;

    // EncodeDiffInternal method
    const encodeDiffInternalBody = props
      .map(([propName, propType]) => {
        const encoded = renderEncodeDiff(
          propType,
          propName,
          `a.${toPascalCase(propName)}`,
          `b.${toPascalCase(propName)}`,
        );
        // Don't add semicolon after block statements
        const suffix = encoded.trimStart().startsWith("{") ? "" : ";";
        return `            ${encoded}${suffix}`;
      })
      .join("\n");

    const encodeDiffInternalMethod = `        internal static void EncodeDiffInternal(${name} a, ${name} b, Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
${encodeDiffInternalBody}
        }`;

    // Decode method - use 'new' for variants to hide base class method
    const decodeMethod = `        public static ${newModifier}${name} Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }`;

    // DecodeInternal method - use 'new' for variants to hide base class method
    const decodeInternalBody = props
      .map(([propName, propType]) => {
        return `                ${toPascalCase(propName)} = ${renderDecode(propType, propName)},`;
      })
      .join("\n");

    const decodeInternalMethod = `        internal static ${newModifier}${name} DecodeInternal(Decoder decoder)
        {
            return new ${name}
            {
${decodeInternalBody}
            };
        }`;

    // DecodeDiff method - no 'new' needed, signature differs from base (different obj type)
    const decodeDiffMethod = `        public static ${name} DecodeDiff(${name} obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }`;

    // DecodeDiffInternal method - no 'new' needed, signature differs from base (different obj type)
    const decodeDiffInternalBody = props
      .map(([propName, propType]) => {
        return `                ${toPascalCase(propName)} = ${renderDecodeDiff(propType, propName, `obj.${toPascalCase(propName)}`)},`;
      })
      .join("\n");

    const decodeDiffInternalMethod = `        internal static ${name} DecodeDiffInternal(${name} obj, Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new ${name}
            {
${decodeDiffInternalBody}
            };
        }`;

    const classDeclaration = baseClass
      ? `    public class ${name} : ${baseClass}`
      : `    public class ${name}`;

    return `${classDeclaration}
    {
${typeProperty}${propertyLines}

${defaultMethod}

${fromJsonMethod}

${toJsonMethod}

${cloneMethod}

${equalsMethod}

${encodeMethod}

${encodeInternalMethod}

${encodeDiffMethod}

${encodeDiffInternalMethod}

${decodeMethod}

${decodeInternalMethod}

${decodeDiffMethod}

${decodeDiffInternalMethod}
    }`;
  }

  function renderUnion(
    name: string,
    options: readonly NamedType[],
    numBits: number,
  ): string {
    // Generate abstract base class

    // FromJson dispatches to variants
    const fromJsonCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        return `${i > 0 ? "                else " : "                "}if (typeName == "${variantName}") return ${variantName}.FromJson(val);`;
      })
      .join("\n");

    // FromJson for protobuf format (uses valProp variable)
    const fromJsonCasesProp = options
      .map((opt, i) => {
        const variantName = opt.name!;
        return `${i > 0 ? "                else " : "                "}if (typeName == "${variantName}") return ${variantName}.FromJson(valProp);`;
      })
      .join("\n");

    // Encode dispatches based on Type property
    const encodeCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `            ${i > 0 ? "else " : ""}if (obj is ${variantName} ${varName})
            {
                encoder.PushEnum(${i}, ${numBits});
                ${variantName}.EncodeInternal(${varName}, encoder);
            }`;
      })
      .join("\n");

    // Decode dispatches based on enum value
    const decodeCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        return `            ${i > 0 ? "else " : ""}if (type == ${i}) return ${variantName}.DecodeInternal(decoder);`;
      })
      .join("\n");

    // EncodeDiff
    const encodeDiffCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `            ${i > 0 ? "else " : ""}if (b is ${variantName} ${varName}B)
            {
                if (a is ${variantName} ${varName}A)
                {
                    ${variantName}.EncodeDiffInternal(${varName}A, ${varName}B, encoder);
                }
                else
                {
                    encoder.PushEnum(${i}, ${numBits});
                    ${variantName}.EncodeInternal(${varName}B, encoder);
                }
            }`;
      })
      .join("\n");

    // DecodeDiff - same type case
    const decodeDiffSameTypeCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `                ${i > 0 ? "else " : ""}if (obj is ${variantName} ${varName}) return ${variantName}.DecodeDiffInternal(${varName}, decoder);`;
      })
      .join("\n");

    // DecodeDiff - different type case
    const decodeDiffNewTypeCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        return `                ${i > 0 ? "else " : ""}if (type == ${i}) return ${variantName}.DecodeInternal(decoder);`;
      })
      .join("\n");

    // Equals
    const equalsCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `            ${i > 0 ? "else " : ""}if (a is ${variantName} ${varName}A && b is ${variantName} ${varName}B) return ${variantName}.Equals(${varName}A, ${varName}B);`;
      })
      .join("\n");

    // Clone
    const cloneCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `            ${i > 0 ? "else " : ""}if (obj is ${variantName} ${varName}) return ${variantName}.Clone(${varName});`;
      })
      .join("\n");

    // ToJson
    const toJsonCases = options
      .map((opt, i) => {
        const variantName = opt.name!;
        const varName = toCamelCase(variantName);
        return `            ${i > 0 ? "else " : ""}if (obj is ${variantName} ${varName}) return new JsonObject { ["${variantName}"] = ${variantName}.ToJson(${varName}) };`;
      })
      .join("\n");

    const baseClass = `    public abstract class ${name}
    {
        public abstract string Type { get; }

        public static ${name} Default() => ${options[0]!.name}.Default();

        public static ${name} FromJson(JsonElement json)
        {
            if (json.TryGetProperty("type", out var typeEl) && json.TryGetProperty("val", out var val))
            {
                var typeName = typeEl.GetString();
${fromJsonCases}
                throw new InvalidOperationException($"Unknown ${name} type: {typeName}");
            }
            // Protobuf format: { "TypeName": {...} }
            var prop = json.EnumerateObject().FirstOrDefault();
            if (prop.Value.ValueKind != JsonValueKind.Undefined)
            {
                var typeName = prop.Name;
                var valProp = prop.Value;
${fromJsonCasesProp}
            }
            throw new InvalidOperationException("Invalid ${name} format");
        }

        public static JsonObject ToJson(${name} obj)
        {
${toJsonCases}
            throw new InvalidOperationException($"Unknown ${name} type: {obj.Type}");
        }

        public static ${name} Clone(${name} obj)
        {
${cloneCases}
            throw new InvalidOperationException($"Unknown ${name} type: {obj.Type}");
        }

        public static bool Equals(${name} a, ${name} b)
        {
            if (a.Type != b.Type) return false;
${equalsCases}
            return false;
        }

        public static byte[] Encode(${name} obj)
        {
            var encoder = new Encoder();
            EncodeInternal(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeInternal(${name} obj, Encoder encoder)
        {
${encodeCases}
        }

        public static byte[] EncodeDiff(${name} a, ${name} b)
        {
            var encoder = new Encoder();
            EncodeDiffInternal(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiffInternal(${name} a, ${name} b, Encoder encoder)
        {
            encoder.PushBoolean(a.Type == b.Type);
${encodeDiffCases}
        }

        public static ${name} Decode(byte[] buf)
        {
            var decoder = new Decoder(buf);
            return DecodeInternal(decoder);
        }

        internal static ${name} DecodeInternal(Decoder decoder)
        {
            var type = decoder.NextEnum(${numBits});
${decodeCases}
            throw new InvalidOperationException("Invalid ${name} union");
        }

        public static ${name} DecodeDiff(${name} obj, byte[] diff)
        {
            var decoder = new Decoder(diff);
            return DecodeDiffInternal(obj, decoder);
        }

        internal static ${name} DecodeDiffInternal(${name} obj, Decoder decoder)
        {
            var isSameType = decoder.NextBoolean();
            if (isSameType)
            {
${decodeDiffSameTypeCases}
                throw new InvalidOperationException("Invalid ${name} diff");
            }
            else
            {
                var type = decoder.NextEnum(${numBits});
${decodeDiffNewTypeCases}
                throw new InvalidOperationException("Invalid ${name} diff");
            }
        }
    }`;

    // Variant classes are generated as standalone classes with inheritance
    // via renderObject with baseClass parameter, so we only return the base class here
    return baseClass;
  }

  // ============ Helper Functions ============

  function renderTypeArg(type: Type, name: string): string {
    if (type.type === "string") {
      return "string";
    } else if (type.type === "int") {
      return "long";
    } else if (type.type === "float") {
      return "float";
    } else if (type.type === "boolean") {
      return "bool";
    } else if (type.type === "enum") {
      return type.name!;
    } else if (type.type === "array") {
      return `List<${renderTypeArg(type.value, name)}>`;
    } else if (type.type === "optional") {
      const inner = renderTypeArg(type.value, name);
      // Value types need ? suffix, reference types are already nullable
      if (isValueType(type.value)) {
        return `${inner}?`;
      }
      return `${inner}?`;
    } else if (type.type === "record") {
      return `Dictionary<${renderTypeArg(type.key, name)}, ${renderTypeArg(type.value, name)}>`;
    } else if (type.type === "reference") {
      return type.ref.name!;
    } else if (type.type === "self-reference") {
      return currentTypeName;
    }
    return "object";
  }

  function isValueType(type: Type): boolean {
    // Resolve reference types
    if (type.type === "reference") {
      return isValueType(type.ref);
    }
    return (
      type.type === "int" ||
      type.type === "float" ||
      type.type === "boolean" ||
      type.type === "enum"
    );
  }

  function renderDefault(type: Type, name: string): string {
    if (type.type === "string") {
      return '""';
    } else if (type.type === "int") {
      return "0";
    } else if (type.type === "float") {
      return "0f";
    } else if (type.type === "boolean") {
      return "false";
    } else if (type.type === "enum") {
      // Enums don't need namespace qualification in defaults (no shadowing risk)
      return `${type.name!}.${toPascalCase(type.options[0]!)}`;
    } else if (type.type === "array") {
      return `new List<${renderTypeArg(type.value, name)}>()`;
    } else if (type.type === "optional") {
      return "null";
    } else if (type.type === "record") {
      return `new Dictionary<${renderTypeArg(type.key, name)}, ${renderTypeArg(type.value, name)}>()`;
    } else if (type.type === "reference") {
      return renderDefault(type.ref, type.ref.name!);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.Default()`;
    }
    return `${qualifyType(name)}.Default()`;
  }

  function renderFromJson(type: Type, name: string, key: string): string {
    if (type.type === "string") {
      return `${key}.GetString() ?? ""`;
    } else if (type.type === "int") {
      return `${key}.GetInt64()`;
    } else if (type.type === "float") {
      return `${key}.GetSingle()`;
    } else if (type.type === "boolean") {
      return `${key}.GetBoolean()`;
    } else if (type.type === "enum") {
      return `Enum.Parse<${type.name!}>(${key}.GetString()!, true)`;
    } else if (type.type === "array") {
      return `${key}.EnumerateArray().Select(x => ${renderFromJson(type.value, name, "x")}).ToList()`;
    } else if (type.type === "optional") {
      return `${key}.ValueKind == JsonValueKind.Null ? null : ${renderFromJson(type.value, name, key)}`;
    } else if (type.type === "record") {
      if (type.key.type === "string") {
        return `${key}.EnumerateObject().ToDictionary(p => p.Name, p => ${renderFromJson(type.value, name, "p.Value")})`;
      } else {
        return `${key}.EnumerateObject().ToDictionary(p => long.Parse(p.Name), p => ${renderFromJson(type.value, name, "p.Value")})`;
      }
    } else if (type.type === "reference") {
      return renderFromJson(type.ref, type.ref.name!, key);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.FromJson(${key})`;
    }
    return `${qualifyType(name)}.FromJson(${key})`;
  }

  function renderToJson(type: Type, name: string, key: string): string {
    if (
      type.type === "string" ||
      type.type === "int" ||
      type.type === "float" ||
      type.type === "boolean"
    ) {
      return key;
    } else if (type.type === "enum") {
      return `${key}.ToString()`;
    } else if (type.type === "array") {
      const innerJson = renderToJson(type.value, name, "x");
      return `new JsonArray(${key}.Select(x => (JsonNode?)${innerJson}).ToArray())`;
    } else if (type.type === "optional") {
      return renderToJson(type.value, name, key);
    } else if (type.type === "record") {
      if (type.key.type === "string") {
        return `new JsonObject(${key}.Select(kvp => new KeyValuePair<string, JsonNode?>(kvp.Key, ${renderToJson(type.value, name, "kvp.Value")})))`;
      } else {
        return `new JsonObject(${key}.Select(kvp => new KeyValuePair<string, JsonNode?>(kvp.Key.ToString(), ${renderToJson(type.value, name, "kvp.Value")})))`;
      }
    } else if (type.type === "reference") {
      // Delegate to the referenced type
      return renderToJson(type.ref, type.ref.name!, key);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.ToJson(${key})`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.ToJson(${key})`;
    }
    return `${qualifyType(name)}.ToJson(${key})`;
  }

  function renderClone(type: Type, name: string, key: string): string {
    if (
      type.type === "string" ||
      type.type === "int" ||
      type.type === "float" ||
      type.type === "boolean" ||
      type.type === "enum"
    ) {
      return key;
    } else if (type.type === "array") {
      // For primitives, use new List<T>(source) instead of Select(x => x).ToList()
      if (isPrimitiveOrEnum(type.value)) {
        return `new List<${renderTypeArg(type.value, name)}>(${key})`;
      }
      return `${key}.Select(x => ${renderClone(type.value, name, "x")}).ToList()`;
    } else if (type.type === "optional") {
      // For primitives/enums, just return the value directly (no need to clone)
      if (isPrimitiveOrEnum(type.value)) {
        return key;
      }
      return `${key} != null ? ${renderClone(type.value, name, key)} : null`;
    } else if (type.type === "record") {
      // For primitive values, use Dictionary constructor; otherwise need to clone values
      if (isPrimitiveOrEnum(type.value)) {
        return `new Dictionary<${renderTypeArg(type.key, name)}, ${renderTypeArg(type.value, name)}>(${key})`;
      }
      return `${key}.ToDictionary(kvp => kvp.Key, kvp => ${renderClone(type.value, name, "kvp.Value")})`;
    } else if (type.type === "reference") {
      return renderClone(type.ref, type.ref.name!, key);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.Clone(${key})`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.Clone(${key})`;
    }
    return `${qualifyType(name)}.Clone(${key})`;
  }

  function renderEquals(
    type: Type,
    name: string,
    keyA: string,
    keyB: string,
  ): string {
    if (
      type.type === "string" ||
      type.type === "int" ||
      type.type === "boolean" ||
      type.type === "enum"
    ) {
      return `${keyA} == ${keyB}`;
    } else if (type.type === "float") {
      if (type.precision) {
        return `Math.Abs(${keyA} - ${keyB}) < ${type.precision / 2}f`;
      }
      return `${keyA} == ${keyB}`;
    } else if (type.type === "array") {
      return `${keyA}.Count == ${keyB}.Count && ${keyA}.Zip(${keyB}).All(pair => ${renderEquals(type.value, name, "pair.First", "pair.Second")})`;
    } else if (type.type === "optional") {
      // For value types and primitives (including string), == works correctly
      if (isValueType(type.value) || isPrimitiveOrEnum(type.value)) {
        return `${keyA} == ${keyB}`;
      }
      return `(${keyA} == null && ${keyB} == null || ${keyA} != null && ${keyB} != null && ${renderEquals(type.value, name, keyA, keyB)})`;
    } else if (type.type === "record") {
      return `${keyA}.Count == ${keyB}.Count && ${keyA}.All(kvp => ${keyB}.TryGetValue(kvp.Key, out var v) && ${renderEquals(type.value, name, "kvp.Value", "v")})`;
    } else if (type.type === "reference") {
      return renderEquals(type.ref, type.ref.name!, keyA, keyB);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.Equals(${keyA}, ${keyB})`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.Equals(${keyA}, ${keyB})`;
    }
    return `${qualifyType(name)}.Equals(${keyA}, ${keyB})`;
  }

  function renderEncode(type: Type, name: string, key: string): string {
    if (type.type === "string") {
      return `encoder.PushString(${key})`;
    } else if (type.type === "int") {
      if (type.min != null && type.min >= 0) {
        return `encoder.PushBoundedInt(${key}, ${type.min})`;
      }
      return `encoder.PushInt(${key})`;
    } else if (type.type === "float") {
      if (type.precision) {
        return `encoder.PushFloatQuantized(${key}, ${type.precision}f)`;
      }
      return `encoder.PushFloat(${key})`;
    } else if (type.type === "boolean") {
      return `encoder.PushBoolean(${key})`;
    } else if (type.type === "enum") {
      return `encoder.PushEnum((int)${key}, ${type.numBits})`;
    } else if (type.type === "array") {
      return `encoder.PushArray(${key}, x => ${renderEncode(type.value, name, "x")})`;
    } else if (type.type === "optional") {
      // For nullable value types (enums, ints, floats, bools), we need inline encoding
      // since PushOptional requires reference types
      if (isValueType(type.value)) {
        const innerEncode = renderEncode(type.value, name, `${key}.Value`);
        return `encoder.PushBoolean(${key}.HasValue);\n            if (${key}.HasValue) ${innerEncode}`;
      }
      return `encoder.PushOptional(${key}, x => ${renderEncode(type.value, name, "x")})`;
    } else if (type.type === "record") {
      const encodeKey = renderEncode(type.key, name, "x");
      const encodeVal = renderEncode(type.value, name, "x");
      return `encoder.PushRecord(${key}, x => ${encodeKey}, x => ${encodeVal})`;
    } else if (type.type === "reference") {
      return renderEncode(type.ref, type.ref.name!, key);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.EncodeInternal(${key}, encoder)`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.EncodeInternal(${key}, encoder)`;
    }
    return `${qualifyType(name)}.EncodeInternal(${key}, encoder)`;
  }

  function renderDecode(type: Type, name: string): string {
    if (type.type === "string") {
      return `decoder.NextString()`;
    } else if (type.type === "int") {
      if (type.min != null && type.min >= 0) {
        return `decoder.NextBoundedInt(${type.min})`;
      }
      return `decoder.NextInt()`;
    } else if (type.type === "float") {
      if (type.precision) {
        return `decoder.NextFloatQuantized(${type.precision}f)`;
      }
      return `decoder.NextFloat()`;
    } else if (type.type === "boolean") {
      return `decoder.NextBoolean()`;
    } else if (type.type === "enum") {
      return `(${type.name!})decoder.NextEnum(${type.numBits})`;
    } else if (type.type === "array") {
      return `decoder.NextArray(() => ${renderDecode(type.value, name)})`;
    } else if (type.type === "optional") {
      // For nullable value types (enums, ints, floats, bools), we need inline decoding
      // since NextOptional requires reference types
      if (isValueType(type.value)) {
        const csType = renderTypeArg(type.value, name);
        // Resolve reference to get the underlying type
        const innerType =
          type.value.type === "reference" ? type.value.ref : type.value;
        // For enums, cast int directly to nullable enum to avoid double cast
        if (innerType.type === "enum") {
          return `decoder.NextBoolean() ? (${csType}?)decoder.NextEnum(${innerType.numBits}) : null`;
        }
        const innerDecode = renderDecode(type.value, name);
        return `decoder.NextBoolean() ? (${csType}?)${innerDecode} : null`;
      }
      return `decoder.NextOptional(() => ${renderDecode(type.value, name)})`;
    } else if (type.type === "record") {
      const decodeKey = renderDecode(type.key, name);
      const decodeVal = renderDecode(type.value, name);
      return `decoder.NextRecord(() => ${decodeKey}, () => ${decodeVal})`;
    } else if (type.type === "reference") {
      return renderDecode(type.ref, type.ref.name!);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.DecodeInternal(decoder)`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.DecodeInternal(decoder)`;
    }
    return `${qualifyType(name)}.DecodeInternal(decoder)`;
  }

  function renderEncodeDiff(
    type: Type,
    name: string,
    keyA: string,
    keyB: string,
  ): string {
    if (type.type === "string") {
      return `encoder.PushStringDiff(${keyA}, ${keyB})`;
    } else if (type.type === "int") {
      if (type.min != null && type.min >= 0) {
        return `encoder.PushBoundedIntDiff(${keyA}, ${keyB}, ${type.min})`;
      }
      return `encoder.PushIntDiff(${keyA}, ${keyB})`;
    } else if (type.type === "float") {
      if (type.precision) {
        return `encoder.PushFloatQuantizedDiff(${keyA}, ${keyB}, ${type.precision}f)`;
      }
      return `encoder.PushFloatDiff(${keyA}, ${keyB})`;
    } else if (type.type === "boolean") {
      return `encoder.PushBooleanDiff(${keyA}, ${keyB})`;
    } else if (type.type === "enum") {
      return `encoder.PushEnumDiff((int)${keyA}, (int)${keyB}, ${type.numBits})`;
    } else if (type.type === "array") {
      const elemType = renderTypeArg(type.value, name);
      const equalsFn = renderEquals(type.value, name, "x", "y");
      const encodeFn = renderEncode(type.value, name, "x");
      const encodeDiffFn = renderEncodeDiff(type.value, name, "x", "y");
      return `encoder.PushArrayDiff<${elemType}>(${keyA}, ${keyB}, (x, y) => ${equalsFn}, x => ${encodeFn}, (x, y) => ${encodeDiffFn})`;
    } else if (type.type === "optional") {
      const elemType = renderTypeArg(type.value, name);
      const encodeFn = renderEncode(type.value, name, "x");
      // For nullable value types, generate inline diff encoding
      if (isValueType(type.value)) {
        const innerEncode = renderEncode(type.value, name, `${keyB}.Value`);
        return `{
                var eq = ${keyA} == ${keyB};
                encoder.PushBoolean(!eq);
                if (!eq)
                {
                    encoder.PushBoolean(${keyB}.HasValue);
                    if (${keyB}.HasValue) ${innerEncode};
                }
            }`;
      }
      if (isPrimitiveOrEnum(type.value)) {
        return `encoder.PushOptionalDiffPrimitive<${elemType}>(${keyA}, ${keyB}, x => ${encodeFn})`;
      } else {
        const encodeDiffFn = renderEncodeDiff(type.value, name, "x", "y");
        return `encoder.PushOptionalDiff<${elemType}>(${keyA}, ${keyB}, x => ${encodeFn}, (x, y) => ${encodeDiffFn})`;
      }
    } else if (type.type === "record") {
      const keyType = renderTypeArg(type.key, name);
      const valType = renderTypeArg(type.value, name);
      const equalsFn = renderEquals(type.value, name, "x", "y");
      const encodeKeyFn = renderEncode(type.key, name, "x");
      const encodeValFn = renderEncode(type.value, name, "x");
      const encodeDiffFn = renderEncodeDiff(type.value, name, "x", "y");
      return `encoder.PushRecordDiff<${keyType}, ${valType}>(${keyA}, ${keyB}, (x, y) => ${equalsFn}, x => ${encodeKeyFn}, x => ${encodeValFn}, (x, y) => ${encodeDiffFn})`;
    } else if (type.type === "reference") {
      return renderEncodeDiff(type.ref, type.ref.name!, keyA, keyB);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.EncodeDiffInternal(${keyA}, ${keyB}, encoder)`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.EncodeDiffInternal(${keyA}, ${keyB}, encoder)`;
    }
    return `${qualifyType(name)}.EncodeDiffInternal(${keyA}, ${keyB}, encoder)`;
  }

  function renderDecodeDiff(type: Type, name: string, key: string): string {
    if (type.type === "string") {
      return `decoder.NextStringDiff(${key})`;
    } else if (type.type === "int") {
      if (type.min != null && type.min >= 0) {
        return `decoder.NextBoundedIntDiff(${key}, ${type.min})`;
      }
      return `decoder.NextIntDiff(${key})`;
    } else if (type.type === "float") {
      if (type.precision) {
        return `decoder.NextFloatQuantizedDiff(${key}, ${type.precision}f)`;
      }
      return `decoder.NextFloatDiff(${key})`;
    } else if (type.type === "boolean") {
      return `decoder.NextBooleanDiff(${key})`;
    } else if (type.type === "enum") {
      return `(${type.name!})decoder.NextEnumDiff((int)${key}, ${type.numBits})`;
    } else if (type.type === "array") {
      const elemType = renderTypeArg(type.value, name);
      const decodeFn = renderDecode(type.value, name);
      const decodeDiffFn = renderDecodeDiff(type.value, name, "x");
      return `decoder.NextArrayDiff<${elemType}>(${key}, () => ${decodeFn}, x => ${decodeDiffFn})`;
    } else if (type.type === "optional") {
      const elemType = renderTypeArg(type.value, name);
      const decodeFn = renderDecode(type.value, name);
      // For nullable value types, generate inline diff decoding
      if (isValueType(type.value)) {
        // Resolve reference to get the underlying type
        const innerType =
          type.value.type === "reference" ? type.value.ref : type.value;
        // For enums, cast int directly to nullable enum to avoid double cast
        if (innerType.type === "enum") {
          return `decoder.NextBoolean() ? (decoder.NextBoolean() ? (${elemType}?)decoder.NextEnum(${innerType.numBits}) : null) : ${key}`;
        }
        return `decoder.NextBoolean() ? (decoder.NextBoolean() ? (${elemType}?)${decodeFn} : null) : ${key}`;
      }
      if (isPrimitiveOrEnum(type.value)) {
        return `decoder.NextOptionalDiffPrimitive<${elemType}>(${key}, () => ${decodeFn})`;
      } else {
        const decodeDiffFn = renderDecodeDiff(type.value, name, "x");
        return `decoder.NextOptionalDiff<${elemType}>(${key}, () => ${decodeFn}, x => ${decodeDiffFn})`;
      }
    } else if (type.type === "record") {
      const keyType = renderTypeArg(type.key, name);
      const valType = renderTypeArg(type.value, name);
      const decodeKeyFn = renderDecode(type.key, name);
      const decodeValFn = renderDecode(type.value, name);
      const decodeDiffFn = renderDecodeDiff(type.value, name, "x");
      return `decoder.NextRecordDiff<${keyType}, ${valType}>(${key}, () => ${decodeKeyFn}, () => ${decodeValFn}, x => ${decodeDiffFn})`;
    } else if (type.type === "reference") {
      return renderDecodeDiff(type.ref, type.ref.name!, key);
    } else if (type.type === "self-reference") {
      return `${qualifyType(currentTypeName)}.DecodeDiffInternal(${key}, decoder)`;
    }
    if (type.type === "union") {
      return `${qualifyType(type.name!)}.DecodeDiffInternal(${key}, decoder)`;
    }
    return `${qualifyType(name)}.DecodeDiffInternal(${key}, decoder)`;
  }
}

function toPascalCase(str: string): string {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function toCamelCase(str: string): string {
  if (!str) return str;
  return str.charAt(0).toLowerCase() + str.slice(1);
}
