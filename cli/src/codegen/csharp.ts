import { Type, NamedType, isPrimitiveOrEnum } from "@hpx7/delta-pack";

export function codegenCsharp(
  schema: Record<string, Type>,
  namespace: string = "Generated",
): string {
  const ctx = createContext(schema, namespace);
  return renderSchema(ctx);
}

// ============ Context ============

interface GeneratorContext {
  schema: Record<string, Type>;
  namespace: string;
  currentTypeName: string;
  currentTypeProperties: Set<string>;
  variantToUnion: Map<string, string>;
}

function createContext(
  schema: Record<string, Type>,
  namespace: string,
): GeneratorContext {
  const variantToUnion = new Map<string, string>();
  for (const [name, type] of Object.entries(schema)) {
    if (type.type === "union") {
      for (const option of type.options) {
        variantToUnion.set(option.name!, name);
      }
    }
  }
  return {
    schema,
    namespace,
    currentTypeName: "",
    currentTypeProperties: new Set(),
    variantToUnion,
  };
}

// ============ Utilities ============

function ifElseChain<T>(
  items: readonly T[],
  render: (item: T, i: number, prefix: string) => string,
): string {
  return items
    .map((item, i) => render(item, i, i > 0 ? "else " : ""))
    .join("\n");
}

function toPascalCase(str: string): string {
  return str ? str.charAt(0).toUpperCase() + str.slice(1) : str;
}

function toCamelCase(str: string): string {
  return str ? str.charAt(0).toLowerCase() + str.slice(1) : str;
}

// Qualify type name with namespace when it conflicts with a property name
// (only needed inside lambdas where C# captures the object initializer context)
function qualifyType(ctx: GeneratorContext, typeName: string): string {
  return ctx.currentTypeProperties.has(typeName)
    ? `${ctx.namespace}.${typeName}`
    : typeName;
}

// ============ Main Renderer ============

function renderSchema(ctx: GeneratorContext): string {
  const enums: string[] = [];
  const classes: string[] = [];

  for (const [name, type] of Object.entries(ctx.schema)) {
    ctx.currentTypeName = name;
    ctx.currentTypeProperties = new Set(
      type.type === "object"
        ? Object.keys(type.properties).map(toPascalCase)
        : [],
    );
    if (type.type === "enum") {
      enums.push(renderEnum(name, type.options));
    } else if (type.type === "object") {
      classes.push(
        renderObject(ctx, name, type.properties, ctx.variantToUnion.get(name)),
      );
    } else if (type.type === "union") {
      classes.push(renderUnion(ctx, name, type.options, type.numBits));
    }
  }

  return `// Auto-generated by DeltaPack - do not edit
using System.Linq;

namespace ${ctx.namespace}
{
${[...enums, ...classes].join("\n\n")}
}
`;
}

// ============ Enum Renderer ============

function renderEnum(name: string, options: readonly string[]): string {
  const values = options
    .map((opt, i) => `        ${toPascalCase(opt)} = ${i}`)
    .join(",\n");
  return `    public enum ${name}
    {
${values}
    }`;
}

// ============ Object Renderer ============

function renderObject(
  ctx: GeneratorContext,
  name: string,
  properties: Record<string, Type>,
  baseClass?: string,
): string {
  const props = Object.entries(properties);
  const isVariant = baseClass != null;
  const mod = isVariant ? "new " : "";
  const p = (fn: (n: string, t: Type) => string) =>
    props.map(([n, t]) => fn(n, t)).join("\n");

  const propLines = p((n, t) => {
    const csType = renderType(ctx, t, n);
    const needsDefault =
      t.type !== "boolean" &&
      t.type !== "optional" &&
      t.type !== "int" &&
      t.type !== "float";
    return needsDefault
      ? `        public ${csType} ${toPascalCase(n)} { get; set; } = ${renderDefault(ctx, t, n)};`
      : `        public ${csType} ${toPascalCase(n)} { get; set; }`;
  });

  const fromJsonBody = p((n, t) => {
    const pc = toPascalCase(n);
    return t.type === "optional"
      ? `                ${pc} = json.TryGetProperty("${n}", out var ${n}El) ? ${renderFromJson(ctx, t, n, `${n}El`)} : null,`
      : `                ${pc} = ${renderFromJson(ctx, t, n, `json.GetProperty("${n}")`)},`;
  });

  const toJsonBody = p((n, t) => {
    const pc = toPascalCase(n);
    if (t.type === "optional") {
      const check = isValueType(t.value)
        ? `obj.${pc}.HasValue`
        : `obj.${pc} != null`;
      return `            if (${check}) result["${n}"] = ${renderToJson(ctx, t, n, `obj.${pc}`)};`;
    }
    return `            result["${n}"] = ${renderToJson(ctx, t, n, `obj.${pc}`)};`;
  });

  const cloneBody = p((n, t) => {
    const pc = toPascalCase(n);
    return `                ${pc} = ${renderClone(ctx, t, n, `obj.${pc}`)},`;
  });

  const equalsBody = props
    .map(([n, t]) => {
      const pc = toPascalCase(n);
      return renderEquals(ctx, t, n, `a.${pc}`, `b.${pc}`);
    })
    .join(" &&\n                ");

  const encodeBody = p(
    (n, t) =>
      `            ${renderEncode(ctx, t, n, `obj.${toPascalCase(n)}`)};`,
  );

  const encodeDiffBody = p((n, t) => {
    const pc = toPascalCase(n);
    const enc = renderEncodeDiff(ctx, t, n, `a.${pc}`, `b.${pc}`);
    const suffix = enc.trimStart().startsWith("{") ? "" : ";";
    return `            ${enc}${suffix}`;
  });

  const decodeBody = p(
    (n, t) =>
      `                ${toPascalCase(n)} = ${renderDecode(ctx, t, n)},`,
  );

  const decodeDiffBody = p((n, t) => {
    const pc = toPascalCase(n);
    return `                ${pc} = ${renderDecodeDiff(ctx, t, n, `obj.${pc}`)},`;
  });

  const classDecl = baseClass
    ? `    public class ${name} : ${baseClass}`
    : `    public class ${name}`;
  const typeOverride = isVariant
    ? `        public override string Type => "${name}";\n\n`
    : "";

  return `${classDecl}
    {
${typeOverride}${propLines}

        public static ${mod}${name} Default() => new();

        public static ${mod}${name} FromJson(System.Text.Json.JsonElement json)
        {
            return new()
            {
${fromJsonBody}
            };
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(${name} obj)
        {
            var result = new System.Text.Json.Nodes.JsonObject();
${toJsonBody}
            return result;
        }

        public static ${name} Clone(${name} obj)
        {
            return new()
            {
${cloneBody}
            };
        }

        public static bool Equals(${name} a, ${name} b)
        {
            return ${equalsBody || "true"};
        }

        public static byte[] Encode(${name} obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(${name} obj, DeltaPack.Encoder encoder)
        {
${encodeBody}
        }

        public static byte[] EncodeDiff(${name} a, ${name} b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(${name} a, ${name} b, DeltaPack.Encoder encoder)
        {
            var changed = !Equals(a, b);
            encoder.PushBoolean(changed);
            if (!changed) return;
${encodeDiffBody}
        }

        public static ${mod}${name} Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static ${mod}${name} Decode_(DeltaPack.Decoder decoder)
        {
            return new()
            {
${decodeBody}
            };
        }

        public static ${name} DecodeDiff(${name} obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static ${name} DecodeDiff_(${name} obj, DeltaPack.Decoder decoder)
        {
            var changed = decoder.NextBoolean();
            if (!changed) return obj;
            return new()
            {
${decodeDiffBody}
            };
        }
    }`;
}

// ============ Union Renderer ============

function renderUnion(
  ctx: GeneratorContext,
  name: string,
  options: readonly NamedType[],
  numBits: number,
): string {
  const first = options[0]!.name;

  const variantNames = options.map((opt) => `"${opt.name}"`).join(", ");
  const fromJsonCases = ifElseChain(
    options,
    (opt, _, p) =>
      `                ${p}if (typeName == "${opt.name}") return ${opt.name}.FromJson(val);`,
  );
  const fromJsonPropCases = ifElseChain(
    options,
    (opt, _, p) =>
      `                ${p}if (typeName == "${opt.name}") return ${opt.name}.FromJson(valProp);`,
  );
  const toJsonCases = ifElseChain(options, (opt, _, p) => {
    const v = toCamelCase(opt.name!);
    return `            ${p}if (obj is ${opt.name} ${v}) return new System.Text.Json.Nodes.JsonObject { ["${opt.name}"] = ${opt.name}.ToJson(${v}) };`;
  });
  const cloneCases = ifElseChain(options, (opt, _, p) => {
    const v = toCamelCase(opt.name!);
    return `            ${p}if (obj is ${opt.name} ${v}) return ${opt.name}.Clone(${v});`;
  });
  const equalsCases = ifElseChain(options, (opt, _, p) => {
    const v = toCamelCase(opt.name!);
    return `            ${p}if (a is ${opt.name} ${v}A && b is ${opt.name} ${v}B) return ${opt.name}.Equals(${v}A, ${v}B);`;
  });
  const encodeCases = ifElseChain(options, (opt, i, p) => {
    const v = toCamelCase(opt.name!);
    return `            ${p}if (obj is ${opt.name} ${v})
            {
                encoder.PushEnum(${i}, ${numBits});
                ${opt.name}.Encode_(${v}, encoder);
            }`;
  });
  const encodeDiffCases = ifElseChain(options, (opt, i, p) => {
    const v = toCamelCase(opt.name!);
    return `            ${p}if (b is ${opt.name} ${v}B)
            {
                if (a is ${opt.name} ${v}A)
                {
                    ${opt.name}.EncodeDiff_(${v}A, ${v}B, encoder);
                }
                else
                {
                    encoder.PushEnum(${i}, ${numBits});
                    ${opt.name}.Encode_(${v}B, encoder);
                }
            }`;
  });
  const decodeCases = ifElseChain(
    options,
    (opt, i, p) =>
      `            ${p}if (type == ${i}) return ${opt.name}.Decode_(decoder);`,
  );
  const decodeDiffSameCases = ifElseChain(options, (opt, _, p) => {
    const v = toCamelCase(opt.name!);
    return `                ${p}if (obj is ${opt.name} ${v}) return ${opt.name}.DecodeDiff_(${v}, decoder);`;
  });
  const decodeDiffNewCases = ifElseChain(
    options,
    (opt, i, p) =>
      `                ${p}if (type == ${i}) return ${opt.name}.Decode_(decoder);`,
  );

  return `    public abstract class ${name}
    {
        public abstract string Type { get; }

        public static ${name} Default() => ${first}.Default();

        public static ${name} FromJson(System.Text.Json.JsonElement json)
        {
            if (json.TryGetProperty("type", out var typeEl) && json.TryGetProperty("val", out var val))
            {
                var typeName = DeltaPack.JsonHelpers.FindVariant(typeEl.GetString()!, ${variantNames});
${fromJsonCases}
                throw new System.InvalidOperationException($"Unknown ${name} type: {typeEl.GetString()}");
            }
            var prop = json.EnumerateObject().FirstOrDefault();
            if (prop.Value.ValueKind != System.Text.Json.JsonValueKind.Undefined)
            {
                var typeName = DeltaPack.JsonHelpers.FindVariant(prop.Name, ${variantNames});
                var valProp = prop.Value;
${fromJsonPropCases}
            }
            throw new System.InvalidOperationException("Invalid ${name} format");
        }

        public static System.Text.Json.Nodes.JsonObject ToJson(${name} obj)
        {
${toJsonCases}
            throw new System.InvalidOperationException($"Unknown ${name} type: {obj.Type}");
        }

        public static ${name} Clone(${name} obj)
        {
${cloneCases}
            throw new System.InvalidOperationException($"Unknown ${name} type: {obj.Type}");
        }

        public static bool Equals(${name} a, ${name} b)
        {
            if (a.Type != b.Type) return false;
${equalsCases}
            return false;
        }

        public static byte[] Encode(${name} obj)
        {
            var encoder = new DeltaPack.Encoder();
            Encode_(obj, encoder);
            return encoder.ToBuffer();
        }

        internal static void Encode_(${name} obj, DeltaPack.Encoder encoder)
        {
${encodeCases}
        }

        public static byte[] EncodeDiff(${name} a, ${name} b)
        {
            var encoder = new DeltaPack.Encoder();
            EncodeDiff_(a, b, encoder);
            return encoder.ToBuffer();
        }

        internal static void EncodeDiff_(${name} a, ${name} b, DeltaPack.Encoder encoder)
        {
            encoder.PushBoolean(a.Type == b.Type);
${encodeDiffCases}
        }

        public static ${name} Decode(byte[] buf)
        {
            var decoder = new DeltaPack.Decoder(buf);
            return Decode_(decoder);
        }

        internal static ${name} Decode_(DeltaPack.Decoder decoder)
        {
            var type = decoder.NextEnum(${numBits});
${decodeCases}
            throw new System.InvalidOperationException("Invalid ${name} union");
        }

        public static ${name} DecodeDiff(${name} obj, byte[] diff)
        {
            var decoder = new DeltaPack.Decoder(diff);
            return DecodeDiff_(obj, decoder);
        }

        internal static ${name} DecodeDiff_(${name} obj, DeltaPack.Decoder decoder)
        {
            var isSameType = decoder.NextBoolean();
            if (isSameType)
            {
${decodeDiffSameCases}
                throw new System.InvalidOperationException("Invalid ${name} diff");
            }
            else
            {
                var type = decoder.NextEnum(${numBits});
${decodeDiffNewCases}
                throw new System.InvalidOperationException("Invalid ${name} diff");
            }
        }
    }`;
}

// ============ Type Helpers ============

function isValueType(type: Type): boolean {
  if (type.type === "reference") return isValueType(type.ref);
  return (
    type.type === "int" ||
    type.type === "float" ||
    type.type === "boolean" ||
    type.type === "enum"
  );
}

function renderType(ctx: GeneratorContext, type: Type, name: string): string {
  switch (type.type) {
    case "string":
      return "string";
    case "int":
      return "long";
    case "float":
      return "float";
    case "boolean":
      return "bool";
    case "enum":
      return type.name!;
    case "array":
      return `System.Collections.Generic.List<${renderType(ctx, type.value, name)}>`;
    case "optional":
      return `${renderType(ctx, type.value, name)}?`;
    case "record":
      return `System.Collections.Generic.Dictionary<${renderType(ctx, type.key, name)}, ${renderType(ctx, type.value, name)}>`;
    case "reference":
      return type.ref.name!;
    case "self-reference":
      return ctx.currentTypeName;
    default:
      throw new Error(`Unexpected type in renderType: ${type.type}`);
  }
}

function renderDefault(
  ctx: GeneratorContext,
  type: Type,
  name: string,
): string {
  switch (type.type) {
    case "string":
      return '""';
    case "int":
      return "0";
    case "float":
      return "0f";
    case "boolean":
      return "false";
    case "enum":
      return `${type.name!}.${toPascalCase(type.options[0]!)}`;
    case "array":
      return `new System.Collections.Generic.List<${renderType(ctx, type.value, name)}>()`;
    case "optional":
      return "null";
    case "record":
      return `new System.Collections.Generic.Dictionary<${renderType(ctx, type.key, name)}, ${renderType(ctx, type.value, name)}>()`;
    case "reference":
      return renderDefault(ctx, type.ref, type.ref.name!);
    case "self-reference":
      return `${ctx.currentTypeName}.Default()`;
    default:
      return `${name}.Default()`;
  }
}

function renderFromJson(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  key: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
      return `DeltaPack.JsonHelpers.ParseString(${key})`;
    case "int":
      return `${key}.GetInt64()`;
    case "float":
      return type.precision !== undefined
        ? `DeltaPack.JsonHelpers.ParseFloatQuantized(${key}, ${type.precision}f)`
        : `${key}.GetSingle()`;
    case "boolean":
      return `DeltaPack.JsonHelpers.ParseBoolean(${key})`;
    case "enum":
      return `DeltaPack.JsonHelpers.ParseEnum<${type.name!}>(${key})`;
    case "array":
      return `${key}.EnumerateArray().Select(x => ${renderFromJson(ctx, type.value, name, "x", true)}).ToList()`;
    case "optional":
      return `DeltaPack.JsonHelpers.IsNullOrEmpty(${key}) ? null : ${renderFromJson(ctx, type.value, name, key, inLambda)}`;
    case "record":
      return type.key.type === "string"
        ? `${key}.EnumerateObject().ToDictionary(p => p.Name, p => ${renderFromJson(ctx, type.value, name, "p.Value", true)})`
        : `${key}.EnumerateObject().ToDictionary(p => long.Parse(p.Name), p => ${renderFromJson(ctx, type.value, name, "p.Value", true)})`;
    case "reference":
      return renderFromJson(ctx, type.ref, type.ref.name!, key, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.FromJson(${key})`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.FromJson(${key})`;
  }
}

function renderToJson(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  key: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
    case "int":
    case "float":
    case "boolean":
      return key;
    case "enum":
      return `${key}.ToString()`;
    case "array":
      return `new System.Text.Json.Nodes.JsonArray(${key}.Select(x => (System.Text.Json.Nodes.JsonNode?)${renderToJson(ctx, type.value, name, "x", true)}).ToArray())`;
    case "optional":
      return renderToJson(ctx, type.value, name, key, inLambda);
    case "record":
      return type.key.type === "string"
        ? `new System.Text.Json.Nodes.JsonObject(${key}.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key, ${renderToJson(ctx, type.value, name, "kvp.Value", true)})))`
        : `new System.Text.Json.Nodes.JsonObject(${key}.Select(kvp => new System.Collections.Generic.KeyValuePair<string, System.Text.Json.Nodes.JsonNode?>(kvp.Key.ToString(), ${renderToJson(ctx, type.value, name, "kvp.Value", true)})))`;
    case "reference":
      return renderToJson(ctx, type.ref, type.ref.name!, key, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.ToJson(${key})`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.ToJson(${key})`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.ToJson(${key})`;
  }
}

function renderClone(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  key: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
    case "int":
    case "float":
    case "boolean":
    case "enum":
      return key;
    case "array":
      return isPrimitiveOrEnum(type.value)
        ? `new System.Collections.Generic.List<${renderType(ctx, type.value, name)}>(${key})`
        : `${key}.Select(x => ${renderClone(ctx, type.value, name, "x", true)}).ToList()`;
    case "optional":
      return isPrimitiveOrEnum(type.value)
        ? key
        : `${key} != null ? ${renderClone(ctx, type.value, name, key, inLambda)} : null`;
    case "record":
      return isPrimitiveOrEnum(type.value)
        ? `new System.Collections.Generic.Dictionary<${renderType(ctx, type.key, name)}, ${renderType(ctx, type.value, name)}>(${key})`
        : `${key}.ToDictionary(kvp => kvp.Key, kvp => ${renderClone(ctx, type.value, name, "kvp.Value", true)})`;
    case "reference":
      return renderClone(ctx, type.ref, type.ref.name!, key, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.Clone(${key})`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.Clone(${key})`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.Clone(${key})`;
  }
}

function renderEquals(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  a: string,
  b: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
    case "int":
    case "boolean":
    case "enum":
      return `${a} == ${b}`;
    case "float":
      return type.precision !== undefined
        ? `DeltaPack.EqualityHelpers.EqualsFloatQuantized(${a}, ${b}, ${type.precision}f)`
        : `DeltaPack.EqualityHelpers.EqualsFloat(${a}, ${b})`;
    case "array":
      return `${a}.Count == ${b}.Count && ${a}.Zip(${b}).All(pair => ${renderEquals(ctx, type.value, name, "pair.First", "pair.Second", true)})`;
    case "optional":
      if (isValueType(type.value)) {
        return `DeltaPack.EqualityHelpers.EqualsOptionalValue(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)})`;
      }
      return `DeltaPack.EqualityHelpers.EqualsOptional(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)})`;
    case "record":
      return `${a}.Count == ${b}.Count && ${a}.All(kvp => ${b}.TryGetValue(kvp.Key, out var v) && ${renderEquals(ctx, type.value, name, "kvp.Value", "v", true)})`;
    case "reference":
      return renderEquals(ctx, type.ref, type.ref.name!, a, b, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.Equals(${a}, ${b})`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.Equals(${a}, ${b})`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.Equals(${a}, ${b})`;
  }
}

function renderEncode(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  key: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
      return `encoder.PushString(${key})`;
    case "int":
      return type.min != null && type.min >= 0
        ? `encoder.PushBoundedInt(${key}, ${type.min})`
        : `encoder.PushInt(${key})`;
    case "float":
      return type.precision
        ? `encoder.PushFloatQuantized(${key}, ${type.precision}f)`
        : `encoder.PushFloat(${key})`;
    case "boolean":
      return `encoder.PushBoolean(${key})`;
    case "enum":
      return `encoder.PushEnum((int)${key}, ${type.numBits})`;
    case "array":
      return `encoder.PushArray(${key}, x => ${renderEncode(ctx, type.value, name, "x", true)})`;
    case "optional":
      if (isValueType(type.value)) {
        return `encoder.PushBoolean(${key}.HasValue);\n            if (${key}.HasValue) ${renderEncode(ctx, type.value, name, `${key}.Value`, inLambda)}`;
      }
      return `encoder.PushOptional(${key}, x => ${renderEncode(ctx, type.value, name, "x", true)})`;
    case "record":
      return `encoder.PushRecord(${key}, x => ${renderEncode(ctx, type.key, name, "x", true)}, x => ${renderEncode(ctx, type.value, name, "x", true)})`;
    case "reference":
      return renderEncode(ctx, type.ref, type.ref.name!, key, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.Encode_(${key}, encoder)`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.Encode_(${key}, encoder)`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.Encode_(${key}, encoder)`;
  }
}

function renderDecode(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
      return `decoder.NextString()`;
    case "int":
      return type.min != null && type.min >= 0
        ? `decoder.NextBoundedInt(${type.min})`
        : `decoder.NextInt()`;
    case "float":
      return type.precision
        ? `decoder.NextFloatQuantized(${type.precision}f)`
        : `decoder.NextFloat()`;
    case "boolean":
      return `decoder.NextBoolean()`;
    case "enum":
      return `(${type.name!})decoder.NextEnum(${type.numBits})`;
    case "array":
      return `decoder.NextArray(() => ${renderDecode(ctx, type.value, name, true)})`;
    case "optional":
      if (isValueType(type.value)) {
        const t = renderType(ctx, type.value, name);
        const inner =
          type.value.type === "reference" ? type.value.ref : type.value;
        if (inner.type === "enum") {
          return `decoder.NextBoolean() ? (${t}?)decoder.NextEnum(${inner.numBits}) : null`;
        }
        return `decoder.NextBoolean() ? (${t}?)${renderDecode(ctx, type.value, name, inLambda)} : null`;
      }
      return `decoder.NextOptional(() => ${renderDecode(ctx, type.value, name, true)})`;
    case "record":
      return `decoder.NextRecord(() => ${renderDecode(ctx, type.key, name, true)}, () => ${renderDecode(ctx, type.value, name, true)})`;
    case "reference":
      return renderDecode(ctx, type.ref, type.ref.name!, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.Decode_(decoder)`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.Decode_(decoder)`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.Decode_(decoder)`;
  }
}

function renderEncodeDiff(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  a: string,
  b: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
      return `encoder.PushStringDiff(${a}, ${b})`;
    case "int":
      return type.min != null && type.min >= 0
        ? `encoder.PushBoundedIntDiff(${a}, ${b}, ${type.min})`
        : `encoder.PushIntDiff(${a}, ${b})`;
    case "float":
      return type.precision
        ? `encoder.PushFloatQuantizedDiff(${a}, ${b}, ${type.precision}f)`
        : `encoder.PushFloatDiff(${a}, ${b})`;
    case "boolean":
      return `encoder.PushBooleanDiff(${a}, ${b})`;
    case "enum":
      return `encoder.PushEnumDiff((int)${a}, (int)${b}, ${type.numBits})`;
    case "array": {
      const t = renderType(ctx, type.value, name);
      return `encoder.PushArrayDiff<${t}>(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)}, x => ${renderEncode(ctx, type.value, name, "x", true)}, (x, y) => ${renderEncodeDiff(ctx, type.value, name, "x", "y", true)})`;
    }
    case "optional": {
      const t = renderType(ctx, type.value, name);
      if (isValueType(type.value)) {
        return `encoder.PushOptionalDiffValue<${t}>(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)}, x => ${renderEncode(ctx, type.value, name, "x", true)})`;
      }
      return isPrimitiveOrEnum(type.value)
        ? `encoder.PushOptionalDiffPrimitive<${t}>(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)}, x => ${renderEncode(ctx, type.value, name, "x", true)})`
        : `encoder.PushOptionalDiff<${t}>(${a}, ${b}, x => ${renderEncode(ctx, type.value, name, "x", true)}, (x, y) => ${renderEncodeDiff(ctx, type.value, name, "x", "y", true)})`;
    }
    case "record": {
      const kt = renderType(ctx, type.key, name);
      const vt = renderType(ctx, type.value, name);
      return `encoder.PushRecordDiff<${kt}, ${vt}>(${a}, ${b}, (x, y) => ${renderEquals(ctx, type.value, name, "x", "y", true)}, x => ${renderEncode(ctx, type.key, name, "x", true)}, x => ${renderEncode(ctx, type.value, name, "x", true)}, (x, y) => ${renderEncodeDiff(ctx, type.value, name, "x", "y", true)})`;
    }
    case "reference":
      return renderEncodeDiff(ctx, type.ref, type.ref.name!, a, b, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.EncodeDiff_(${a}, ${b}, encoder)`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.EncodeDiff_(${a}, ${b}, encoder)`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.EncodeDiff_(${a}, ${b}, encoder)`;
  }
}

function renderDecodeDiff(
  ctx: GeneratorContext,
  type: Type,
  name: string,
  key: string,
  inLambda = false,
): string {
  switch (type.type) {
    case "string":
      return `decoder.NextStringDiff(${key})`;
    case "int":
      return type.min != null && type.min >= 0
        ? `decoder.NextBoundedIntDiff(${key}, ${type.min})`
        : `decoder.NextIntDiff(${key})`;
    case "float":
      return type.precision
        ? `decoder.NextFloatQuantizedDiff(${key}, ${type.precision}f)`
        : `decoder.NextFloatDiff(${key})`;
    case "boolean":
      return `decoder.NextBooleanDiff(${key})`;
    case "enum":
      return `(${type.name!})decoder.NextEnumDiff((int)${key}, ${type.numBits})`;
    case "array": {
      const t = renderType(ctx, type.value, name);
      return `decoder.NextArrayDiff<${t}>(${key}, () => ${renderDecode(ctx, type.value, name, true)}, x => ${renderDecodeDiff(ctx, type.value, name, "x", true)})`;
    }
    case "optional": {
      const t = renderType(ctx, type.value, name);
      if (isValueType(type.value)) {
        // Use NextOptionalDiffValue for value types
        return `decoder.NextOptionalDiffValue<${t}>(${key}, () => ${renderDecode(ctx, type.value, name, true)})`;
      }
      return isPrimitiveOrEnum(type.value)
        ? `decoder.NextOptionalDiffPrimitive<${t}>(${key}, () => ${renderDecode(ctx, type.value, name, true)})`
        : `decoder.NextOptionalDiff<${t}>(${key}, () => ${renderDecode(ctx, type.value, name, true)}, x => ${renderDecodeDiff(ctx, type.value, name, "x", true)})`;
    }
    case "record": {
      const kt = renderType(ctx, type.key, name);
      const vt = renderType(ctx, type.value, name);
      return `decoder.NextRecordDiff<${kt}, ${vt}>(${key}, () => ${renderDecode(ctx, type.key, name, true)}, () => ${renderDecode(ctx, type.value, name, true)}, x => ${renderDecodeDiff(ctx, type.value, name, "x", true)})`;
    }
    case "reference":
      return renderDecodeDiff(ctx, type.ref, type.ref.name!, key, inLambda);
    case "self-reference":
      return `${ctx.currentTypeName}.DecodeDiff_(${key}, decoder)`;
    case "union":
      return `${inLambda ? qualifyType(ctx, type.name!) : type.name!}.DecodeDiff_(${key}, decoder)`;
    default:
      return `${inLambda ? qualifyType(ctx, name) : name}.DecodeDiff_(${key}, decoder)`;
  }
}
