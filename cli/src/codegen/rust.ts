import { Type, NamedType, isPrimitiveOrEnum } from "@hpx7/delta-pack";

export function codegenRust(
  schema: Record<string, Type>,
  _namespace?: string,
): string {
  const ctx = createContext(schema);
  return renderSchema(ctx);
}

// ============ Context ============

interface GeneratorContext {
  schema: Record<string, Type>;
  currentTypeName: string;
  variantToUnion: Map<string, string>;
}

function createContext(schema: Record<string, Type>): GeneratorContext {
  const variantToUnion = new Map<string, string>();
  for (const [name, type] of Object.entries(schema)) {
    if (type.type === "union") {
      for (const option of type.options) {
        variantToUnion.set(option.name!, name);
      }
    }
  }
  return {
    schema,
    currentTypeName: "",
    variantToUnion,
  };
}

// ============ Utilities ============

// Rust reserved keywords that need escaping
const RUST_KEYWORDS = new Set([
  "as", "break", "const", "continue", "crate", "else", "enum", "extern",
  "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
  "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct",
  "super", "trait", "true", "type", "unsafe", "use", "where", "while",
  "async", "await", "dyn", "bool", "str", "f32", "f64",
]);

function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, "_$1")
    .toLowerCase()
    .replace(/^_/, "");
}

// Returns [rustFieldName, needsRename] - adds _ suffix for keywords
function toRustFieldName(str: string): [string, boolean] {
  const snake = toSnakeCase(str);
  if (RUST_KEYWORDS.has(snake)) {
    return [`${snake}_`, true];
  }
  return [snake, false];
}

function toPascalCase(str: string): string {
  return str ? str.charAt(0).toUpperCase() + str.slice(1) : str;
}

// ============ Main Renderer ============

function renderSchema(ctx: GeneratorContext): string {
  const enums: string[] = [];
  const structs: string[] = [];

  for (const [name, type] of Object.entries(ctx.schema)) {
    ctx.currentTypeName = name;
    if (type.type === "enum") {
      enums.push(renderEnum(name, type.options, type.numBits));
    } else if (type.type === "object") {
      structs.push(
        renderObject(ctx, name, type.properties, ctx.variantToUnion.get(name)),
      );
    } else if (type.type === "union") {
      structs.push(renderUnion(ctx, name, type.options, type.numBits));
    }
  }

  return `// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

${[...enums, ...structs].join("\n\n")}
`;
}

// ============ Enum Renderer ============

function renderEnum(
  name: string,
  options: readonly string[],
  numBits: number,
): string {
  // Add serde rename if PascalCase differs from original (preserves JSON interop)
  const variants = options
    .map((opt) => {
      const pascal = toPascalCase(opt);
      if (pascal !== opt) {
        return `    #[serde(rename = "${opt}")]\n    ${pascal},`;
      }
      return `    ${pascal},`;
    })
    .join("\n");

  const fromU32Cases = options
    .map((opt, i) => `            ${i} => ${name}::${toPascalCase(opt)},`)
    .join("\n");

  const toU32Cases = options
    .map((opt, i) => `            ${name}::${toPascalCase(opt)} => ${i},`)
    .join("\n");

  return `#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ${name} {
${variants}
}

impl ${name} {
    pub const NUM_BITS: u8 = ${numBits};

    pub fn from_u32(val: u32) -> Self {
        match val {
${fromU32Cases}
            _ => panic!("Invalid ${name} value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
${toU32Cases}
        }
    }
}

impl Default for ${name} {
    fn default() -> Self {
        ${name}::${toPascalCase(options[0]!)}
    }
}`;
}

// ============ Object Renderer ============

function renderObject(
  ctx: GeneratorContext,
  name: string,
  properties: Record<string, Type>,
  _baseUnion?: string,
): string {
  const props = Object.entries(properties);

  // Pre-compute rust field names with rename info
  // Add serde rename if the snake_case name differs from original (handles camelCase and keywords)
  const fieldInfo = props.map(([n, t]) => {
    const [rustName, isKeyword] = toRustFieldName(n);
    const needsRename = isKeyword || rustName !== n;
    return { originalName: n, rustName, needsRename, type: t };
  });

  const p = (fn: (info: (typeof fieldInfo)[0]) => string) =>
    fieldInfo.map(fn).join("\n");

  const fieldLines = p((info) => {
    const rustType = renderType(ctx, info.type);
    const renameAttr = info.needsRename
      ? `    #[serde(rename = "${info.originalName}")]\n`
      : "";
    return `${renameAttr}    pub ${info.rustName}: ${rustType},`;
  });

  const defaultLines = p((info) => {
    return `            ${info.rustName}: ${renderDefault(ctx, info.type)},`;
  });

  const cloneLines = p((info) => {
    const field = `self.${info.rustName}`;
    return `            ${info.rustName}: ${renderClone(ctx, info.type, field)},`;
  });

  const equalsExprs = fieldInfo.map((info) => {
    return renderEquals(
      ctx,
      info.type,
      `self.${info.rustName}`,
      `other.${info.rustName}`,
    );
  });
  const equalsLines =
    equalsExprs.length <= 1
      ? equalsExprs.join("")
      : equalsExprs.join("\n            && ");

  const encodeLines = p((info) => {
    const field = `self.${info.rustName}`;
    return `        ${renderEncode(ctx, info.type, field)};`;
  });

  const encodeDiffLines = p((info) => {
    if (hasOwnChangeBit(info.type)) {
      // Type handles its own change bit
      return `        ${renderEncodeDiff(ctx, info.type, `a.${info.rustName}`, `b.${info.rustName}`)};`;
    } else {
      // Use push_field_diff helper
      const eq = renderEquals(ctx, info.type, "x", "y", true);
      const diffCb = renderEncodeDiffCallback(ctx, info.type);
      return `        encoder.push_field_diff(&a.${info.rustName}, &b.${info.rustName}, |x, y| ${eq}, ${diffCb});`;
    }
  });

  const decodeLines = p((info) => {
    return `            ${info.rustName}: ${renderDecode(ctx, info.type)},`;
  });

  const decodeDiffLines = p((info) => {
    const field = `obj.${info.rustName}`;
    if (hasOwnChangeBit(info.type)) {
      // Type handles its own change bit
      return `            ${info.rustName}: ${renderDecodeDiff(ctx, info.type, field)},`;
    } else {
      // Use next_field_diff helper
      const diffCb = renderDecodeDiffCallback(ctx, info.type);
      return `            ${info.rustName}: decoder.next_field_diff(&${field}, ${diffCb}),`;
    }
  });

  return `#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ${name} {
${fieldLines}
}

impl Default for ${name} {
    fn default() -> Self {
        Self {
${defaultLines}
        }
    }
}

impl ${name} {
    pub fn equals(&self, other: &Self) -> bool {
        ${equalsLines || "true"}
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
${encodeLines}
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            encoder.push_object_diff(a, b, |x, y| x.equals(y), |enc| {
                Self::encode_diff_into(a, b, enc);
            });
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
${encodeDiffLines}
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
${decodeLines}
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| {
            decoder.next_object_diff(obj, |dec| Self::decode_diff_from(obj, dec))
        })
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
${decodeDiffLines}
        }
    }
}`;
}

// ============ Union Renderer ============

function renderUnion(
  ctx: GeneratorContext,
  name: string,
  options: readonly NamedType[],
  numBits: number,
): string {
  const variants = options
    .map((opt) => `    ${opt.name}(${opt.name}),`)
    .join("\n");

  const defaultVariant = options[0]!.name;

  const cloneCases = options
    .map(
      (opt) =>
        `            ${name}::${opt.name}(v) => ${name}::${opt.name}(v.clone()),`,
    )
    .join("\n");

  const equalsCases = options
    .map(
      (opt) =>
        `            (${name}::${opt.name}(a), ${name}::${opt.name}(b)) => a.equals(b),`,
    )
    .join("\n");

  const encodeCases = options
    .map(
      (opt, i) =>
        `            ${name}::${opt.name}(v) => {
                encoder.push_enum(${i}, ${numBits});
                v.encode_into(encoder);
            }`,
    )
    .join("\n");

  const encodeDiffCases = options
    .map(
      (opt, i) =>
        `            ${name}::${opt.name}(b_val) => {
                if let ${name}::${opt.name}(a_val) = a {
                    ${opt.name}::encode_diff_into(a_val, b_val, encoder);
                } else {
                    encoder.push_enum(${i}, ${numBits});
                    b_val.encode_into(encoder);
                }
            }`,
    )
    .join("\n");

  const decodeCases = options
    .map(
      (opt, i) =>
        `            ${i} => ${name}::${opt.name}(${opt.name}::decode_from(decoder)),`,
    )
    .join("\n");

  const decodeDiffSameCases = options
    .map(
      (opt) =>
        `                ${name}::${opt.name}(v) => ${name}::${opt.name}(${opt.name}::decode_diff_from(v, decoder)),`,
    )
    .join("\n");

  const decodeDiffNewCases = options
    .map(
      (opt, i) =>
        `                ${i} => ${name}::${opt.name}(${opt.name}::decode_from(decoder)),`,
    )
    .join("\n");

  return `#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ${name} {
${variants}
}

impl Default for ${name} {
    fn default() -> Self {
        ${name}::${defaultVariant}(${defaultVariant}::default())
    }
}

impl ${name} {
    pub fn equals(&self, other: &Self) -> bool {
        match (self, other) {
${equalsCases}
            _ => false,
        }
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        match self {
${encodeCases}
        }
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let same_type = std::mem::discriminant(a) == std::mem::discriminant(b);
        encoder.push_boolean(same_type);
        match b {
${encodeDiffCases}
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        let variant = decoder.next_enum(${numBits});
        match variant {
${decodeCases}
            _ => panic!("Invalid ${name} variant: {}", variant),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let same_type = decoder.next_boolean();
        if same_type {
            match obj {
${decodeDiffSameCases}
            }
        } else {
            let variant = decoder.next_enum(${numBits});
            match variant {
${decodeDiffNewCases}
                _ => panic!("Invalid ${name} variant: {}", variant),
            }
        }
    }
}`;
}

// ============ Type Helpers ============

// Types that handle their own change bit in diff encoding
function hasOwnChangeBit(type: Type): boolean {
  if (type.type === "boolean") return true;
  if (type.type === "reference") {
    return type.ref.type === "union";
  }
  return false;
}

// Check if a type needs dereferencing when accessed through a reference
// Only numeric/bool primitives need this - strings are Clone, enums have auto-deref on methods
function needsDeref(type: Type): boolean {
  if (type.type === "int" || type.type === "float" || type.type === "boolean") {
    return true;
  }
  if (type.type === "reference" && type.ref.type !== "enum") {
    return false;
  }
  return false;
}

function renderType(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return "String";
    case "int":
      return type.min != null && type.min >= 0 ? "u64" : "i64";
    case "float":
      return "f32";
    case "boolean":
      return "bool";
    case "enum":
      return type.name!;
    case "array":
      return `Vec<${renderType(ctx, type.value)}>`;
    case "optional":
      return `Option<${renderType(ctx, type.value)}>`;
    case "record":
      return `HashMap<${renderType(ctx, type.key)}, ${renderType(ctx, type.value)}>`;
    case "object":
      return type.name!;
    case "reference":
      return type.ref.name!;
    case "self-reference":
      return `Box<${ctx.currentTypeName}>`;
    default:
      throw new Error(`Unexpected type in renderType: ${type.type}`);
  }
}

function renderDefault(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return "String::new()";
    case "int":
      return "0";
    case "float":
      return "0.0";
    case "boolean":
      return "false";
    case "enum":
      return `${type.name!}::default()`;
    case "array":
      return "Vec::new()";
    case "optional":
      return "None";
    case "record":
      return "HashMap::new()";
    case "reference":
      return `${type.ref.name!}::default()`;
    case "self-reference":
      return `Box::new(${ctx.currentTypeName}::default())`;
    default:
      throw new Error(`Unexpected type in renderDefault: ${type.type}`);
  }
}

function renderClone(ctx: GeneratorContext, type: Type, key: string): string {
  switch (type.type) {
    case "string":
      return `${key}.clone()`;
    case "int":
    case "float":
    case "boolean":
    case "enum":
      return key;
    case "array":
      return isPrimitiveOrEnum(type.value)
        ? `${key}.clone()`
        : `${key}.iter().map(|x| ${renderClone(ctx, type.value, "x.clone()")}).collect()`;
    case "optional":
      return isPrimitiveOrEnum(type.value)
        ? `${key}.clone()`
        : `${key}.as_ref().map(|x| ${renderClone(ctx, type.value, "x.clone()")})`;
    case "record":
      return isPrimitiveOrEnum(type.value)
        ? `${key}.clone()`
        : `${key}.iter().map(|(k, v)| (k.clone(), ${renderClone(ctx, type.value, "v.clone()")})).collect()`;
    case "reference":
      return `${key}.clone()`;
    case "self-reference":
      return `Box::new((**${key}).clone())`;
    default:
      throw new Error(`Unexpected type in renderClone: ${type.type}`);
  }
}

// inClosure: when true, a and b are already references (closure params)
function renderEquals(
  ctx: GeneratorContext,
  type: Type,
  a: string,
  b: string,
  inClosure = false,
): string {
  switch (type.type) {
    case "string":
    case "int":
    case "boolean":
    case "enum":
      return `${a} == ${b}`;
    case "float": {
      // In closures, a and b are references that need dereferencing for float comparison
      const aExpr = inClosure ? `*${a}` : a;
      const bExpr = inClosure ? `*${b}` : b;
      return type.precision
        ? `delta_pack::equals_float_quantized(${aExpr}, ${bExpr}, ${type.precision}_f32)`
        : `delta_pack::equals_float(${aExpr}, ${bExpr})`;
    }
    case "array":
      return isPrimitiveOrEnum(type.value)
        ? `${a} == ${b}`
        : `delta_pack::equals_array(&${a}, &${b}, |x, y| ${renderEquals(ctx, type.value, "x", "y", true)})`;
    case "optional":
      return isPrimitiveOrEnum(type.value)
        ? `${a} == ${b}`
        : `delta_pack::equals_optional(&${a}, &${b}, |x, y| ${renderEquals(ctx, type.value, "x", "y", true)})`;
    case "record":
      return isPrimitiveOrEnum(type.value)
        ? `${a} == ${b}`
        : `delta_pack::equals_record(&${a}, &${b}, |x, y| ${renderEquals(ctx, type.value, "x", "y", true)})`;
    case "reference":
      // For enum references, use == since they implement PartialEq
      if (type.ref.type === "enum") {
        return `${a} == ${b}`;
      }
      // In closures, params are already refs; in struct fields, need explicit &
      return inClosure ? `${a}.equals(${b})` : `${a}.equals(&${b})`;
    case "self-reference":
      return inClosure ? `${a}.equals(${b})` : `${a}.equals(&${b})`;
    default:
      throw new Error(`Unexpected type in renderEquals: ${type.type}`);
  }
}

// Generate a closure for encoding a single value (used by push_array, push_optional, push_record)
function renderEncodeCallback(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return `|enc, item| enc.push_string(item)`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `|enc, &item| enc.push_uint(item)`
          : `|enc, &item| enc.push_uint(item - ${type.min})`;
      }
      return `|enc, &item| enc.push_int(item)`;
    case "float":
      return type.precision
        ? `|enc, &item| enc.push_float_quantized(item, ${type.precision}_f32)`
        : `|enc, &item| enc.push_float(item)`;
    case "boolean":
      return `|enc, &item| enc.push_boolean(item)`;
    case "enum":
      return `|enc, &item| enc.push_enum(item.to_u32(), ${type.numBits})`;
    case "array": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      return `|enc, item| enc.push_array(item, ${innerEncode})`;
    }
    case "optional": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      return `|enc, item| enc.push_optional(item, ${innerEncode})`;
    }
    case "record": {
      const keyEncode = renderEncodeCallback(ctx, type.key);
      const valEncode = renderEncodeCallback(ctx, type.value);
      return `|enc, item| enc.push_record(item, ${keyEncode}, ${valEncode})`;
    }
    case "reference":
      if (type.ref.type === "enum") {
        return `|enc, &item| enc.push_enum(item.to_u32(), ${type.ref.numBits})`;
      }
      return `|enc, item| item.encode_into(enc)`;
    case "self-reference":
      return `|enc, item| item.encode_into(enc)`;
    default:
      throw new Error(`Unexpected type in renderEncodeCallback: ${type.type}`);
  }
}

function renderEncode(ctx: GeneratorContext, type: Type, key: string): string {
  switch (type.type) {
    case "string":
      return `encoder.push_string(&${key})`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `encoder.push_uint(${key})`
          : `encoder.push_uint(${key} - ${type.min})`;
      }
      return `encoder.push_int(${key})`;
    case "float":
      return type.precision
        ? `encoder.push_float_quantized(${key}, ${type.precision}_f32)`
        : `encoder.push_float(${key})`;
    case "boolean":
      return `encoder.push_boolean(${key})`;
    case "enum":
      return `encoder.push_enum(${key}.to_u32(), ${type.numBits})`;
    case "array": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      return `encoder.push_array(&${key}, ${innerEncode})`;
    }
    case "optional": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      return `encoder.push_optional(&${key}, ${innerEncode})`;
    }
    case "record": {
      const keyEncode = renderEncodeCallback(ctx, type.key);
      const valEncode = renderEncodeCallback(ctx, type.value);
      return `encoder.push_record(&${key}, ${keyEncode}, ${valEncode})`;
    }
    case "reference":
      // For enum references, use push_enum
      if (type.ref.type === "enum") {
        return `encoder.push_enum(${key}.to_u32(), ${type.ref.numBits})`;
      }
      return `${key}.encode_into(encoder)`;
    case "self-reference":
      return `${key}.encode_into(encoder)`;
    default:
      throw new Error(`Unexpected type in renderEncode: ${type.type}`);
  }
}

// Generate a closure for decoding a single value (used by next_array, next_optional, next_record)
function renderDecodeCallback(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return `|dec| dec.next_string()`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `|dec| dec.next_uint()`
          : `|dec| dec.next_uint() + ${type.min}`;
      }
      return `|dec| dec.next_int()`;
    case "float":
      return type.precision
        ? `|dec| dec.next_float_quantized(${type.precision}_f32)`
        : `|dec| dec.next_float()`;
    case "boolean":
      return `|dec| dec.next_boolean()`;
    case "enum":
      return `|dec| ${type.name!}::from_u32(dec.next_enum(${type.numBits}))`;
    case "array": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      return `|dec| dec.next_array(${innerDecode})`;
    }
    case "optional": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      return `|dec| dec.next_optional(${innerDecode})`;
    }
    case "record": {
      const keyDecode = renderDecodeCallback(ctx, type.key);
      const valDecode = renderDecodeCallback(ctx, type.value);
      return `|dec| dec.next_record(${keyDecode}, ${valDecode})`;
    }
    case "reference":
      if (type.ref.type === "enum") {
        return `|dec| ${type.ref.name!}::from_u32(dec.next_enum(${type.ref.numBits}))`;
      }
      return `|dec| ${type.ref.name!}::decode_from(dec)`;
    case "self-reference":
      return `|dec| Box::new(${ctx.currentTypeName}::decode_from(dec))`;
    default:
      throw new Error(`Unexpected type in renderDecodeCallback: ${type.type}`);
  }
}

// Generate a closure for encoding diff of a single value (used by push_array_diff, push_optional_diff)
// Takes (encoder, &old, &new) and encodes the diff
function renderEncodeDiffCallback(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return `|enc, a, b| enc.push_string_diff(a, b)`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `|enc, &a, &b| enc.push_uint_diff(a, b)`
          : `|enc, &a, &b| enc.push_uint_diff(a - ${type.min}, b - ${type.min})`;
      }
      return `|enc, &a, &b| enc.push_int_diff(a, b)`;
    case "float":
      return type.precision
        ? `|enc, &a, &b| enc.push_float_quantized_diff(a, b, ${type.precision}_f32)`
        : `|enc, &a, &b| enc.push_float_diff(a, b)`;
    case "boolean":
      return `|enc, &a, &b| enc.push_boolean_diff(a, b)`;
    case "enum":
      return `|enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), ${type.numBits})`;
    case "array": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      const innerEquals = renderEqualsCallback(ctx, type.value);
      const innerDiff = renderEncodeDiffCallback(ctx, type.value);
      return `|enc, a, b| enc.push_array_diff(a, b, ${innerEquals}, ${innerEncode}, ${innerDiff})`;
    }
    case "optional": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      const innerDiff = renderEncodeDiffCallback(ctx, type.value);
      return `|enc, a, b| enc.push_optional_diff(a, b, ${innerEncode}, ${innerDiff})`;
    }
    case "record": {
      const keyEncode = renderEncodeCallback(ctx, type.key);
      const valEncode = renderEncodeCallback(ctx, type.value);
      const valEquals = renderEqualsCallback(ctx, type.value);
      const valDiff = renderEncodeDiffCallback(ctx, type.value);
      return `|enc, a, b| enc.push_record_diff(a, b, ${valEquals}, ${keyEncode}, ${valEncode}, ${valDiff})`;
    }
    case "object":
      return `|enc, a, b| ${type.name!}::encode_diff_into(a, b, enc)`;
    case "reference":
      if (type.ref.type === "enum") {
        return `|enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), ${type.ref.numBits})`;
      }
      // Objects use field-only methods; unions use regular diff (includes same_type bit)
      if (type.ref.type === "union") {
        return `|enc, a, b| ${type.ref.name!}::encode_diff_into(a, b, enc)`;
      }
      return `|enc, a, b| ${type.ref.name!}::encode_diff_into(a, b, enc)`;
    case "self-reference":
      return `|enc, a, b| ${ctx.currentTypeName}::encode_diff_into(a, b, enc)`;
    default:
      throw new Error(`Unexpected type in renderEncodeDiffCallback: ${type.type}`);
  }
}

// Generate a closure for decoding diff of a single value (used by next_array_diff, next_optional_diff)
// Takes (decoder, &old) and returns new value
function renderDecodeDiffCallback(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return `|dec, a| dec.next_string_diff(a)`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `|dec, &a| dec.next_uint_diff(a)`
          : `|dec, &a| dec.next_uint_diff(a - ${type.min}) + ${type.min}`;
      }
      return `|dec, &a| dec.next_int_diff(a)`;
    case "float":
      return type.precision
        ? `|dec, &a| dec.next_float_quantized_diff(a, ${type.precision}_f32)`
        : `|dec, &a| dec.next_float_diff(a)`;
    case "boolean":
      return `|dec, &a| dec.next_boolean_diff(a)`;
    case "enum":
      return `|dec, &a| ${type.name!}::from_u32(dec.next_enum_diff(a.to_u32(), ${type.numBits}))`;
    case "array": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      const innerDiff = renderDecodeDiffCallback(ctx, type.value);
      return `|dec, a| dec.next_array_diff(a, ${innerDecode}, ${innerDiff})`;
    }
    case "optional": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      const innerDiff = renderDecodeDiffCallback(ctx, type.value);
      return `|dec, a| dec.next_optional_diff(a, ${innerDecode}, ${innerDiff})`;
    }
    case "record": {
      const keyDecode = renderDecodeCallback(ctx, type.key);
      const valDecode = renderDecodeCallback(ctx, type.value);
      const valDiff = renderDecodeDiffCallback(ctx, type.value);
      return `|dec, a| dec.next_record_diff(a, ${keyDecode}, ${valDecode}, ${valDiff})`;
    }
    case "object":
      return `|dec, a| ${type.name!}::decode_diff_from(a, dec)`;
    case "reference":
      if (type.ref.type === "enum") {
        return `|dec, &a| ${type.ref.name!}::from_u32(dec.next_enum_diff(a.to_u32(), ${type.ref.numBits}))`;
      }
      // Objects use field-only methods; unions use regular diff (includes same_type bit)
      if (type.ref.type === "union") {
        return `|dec, a| ${type.ref.name!}::decode_diff_from(a, dec)`;
      }
      return `|dec, a| ${type.ref.name!}::decode_diff_from(a, dec)`;
    case "self-reference":
      return `|dec, a| Box::new(${ctx.currentTypeName}::decode_diff_from(a, dec))`;
    default:
      throw new Error(`Unexpected type in renderDecodeDiffCallback: ${type.type}`);
  }
}

// Generate an equals closure for use with push_array_diff and push_field_diff
function renderEqualsCallback(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
    case "int":
    case "boolean":
    case "enum":
      return `|x, y| x == y`;
    case "float":
      return type.precision
        ? `|&x, &y| delta_pack::equals_float_quantized(x, y, ${type.precision}_f32)`
        : `|&x, &y| delta_pack::equals_float(x, y)`;
    case "array":
      return isPrimitiveOrEnum(type.value)
        ? `|x, y| x == y`
        : `|x, y| delta_pack::equals_array(x, y, ${renderEqualsCallback(ctx, type.value)})`;
    case "optional":
      return isPrimitiveOrEnum(type.value)
        ? `|x, y| x == y`
        : `|x, y| delta_pack::equals_optional(x, y, ${renderEqualsCallback(ctx, type.value)})`;
    case "record":
      return isPrimitiveOrEnum(type.value)
        ? `|x, y| x == y`
        : `|x, y| delta_pack::equals_record(x, y, ${renderEqualsCallback(ctx, type.value)})`;
    case "object":
      return `|x, y| x.equals(y)`;
    case "reference":
      if (type.ref.type === "enum") {
        return `|x, y| x == y`;
      }
      return `|x, y| x.equals(y)`;
    case "self-reference":
      return `|x, y| x.equals(y)`;
    default:
      throw new Error(`Unexpected type in renderEqualsCallback: ${type.type}`);
  }
}

function renderDecode(ctx: GeneratorContext, type: Type): string {
  switch (type.type) {
    case "string":
      return `decoder.next_string()`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `decoder.next_uint()`
          : `decoder.next_uint() + ${type.min}`;
      }
      return `decoder.next_int()`;
    case "float":
      return type.precision
        ? `decoder.next_float_quantized(${type.precision}_f32)`
        : `decoder.next_float()`;
    case "boolean":
      return `decoder.next_boolean()`;
    case "enum":
      return `${type.name!}::from_u32(decoder.next_enum(${type.numBits}))`;
    case "array": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      return `decoder.next_array(${innerDecode})`;
    }
    case "optional": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      return `decoder.next_optional(${innerDecode})`;
    }
    case "record": {
      const keyDecode = renderDecodeCallback(ctx, type.key);
      const valDecode = renderDecodeCallback(ctx, type.value);
      return `decoder.next_record(${keyDecode}, ${valDecode})`;
    }
    case "reference":
      // For enum references, use next_enum
      if (type.ref.type === "enum") {
        return `${type.ref.name!}::from_u32(decoder.next_enum(${type.ref.numBits}))`;
      }
      return `${type.ref.name!}::decode_from(decoder)`;
    case "self-reference":
      return `Box::new(${ctx.currentTypeName}::decode_from(decoder))`;
    default:
      throw new Error(`Unexpected type in renderDecode: ${type.type}`);
  }
}

function renderEncodeDiff(
  ctx: GeneratorContext,
  type: Type,
  a: string,
  b: string,
): string {
  switch (type.type) {
    case "string":
      return `encoder.push_string_diff(&${a}, &${b})`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `encoder.push_uint_diff(${a}, ${b})`
          : `encoder.push_uint_diff(${a} - ${type.min}, ${b} - ${type.min})`;
      }
      return `encoder.push_int_diff(${a}, ${b})`;
    case "float":
      return type.precision
        ? `encoder.push_float_quantized_diff(${a}, ${b}, ${type.precision}_f32)`
        : `encoder.push_float_diff(${a}, ${b})`;
    case "boolean":
      return `encoder.push_boolean_diff(${a}, ${b})`;
    case "enum":
      return `encoder.push_enum_diff(${a}.to_u32(), ${b}.to_u32(), ${type.numBits})`;
    case "array": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      const innerEquals = renderEqualsCallback(ctx, type.value);
      const innerDiff = renderEncodeDiffCallback(ctx, type.value);
      return `encoder.push_array_diff(&${a}, &${b}, ${innerEquals}, ${innerEncode}, ${innerDiff})`;
    }
    case "optional": {
      const innerEncode = renderEncodeCallback(ctx, type.value);
      const innerDiff = renderEncodeDiffCallback(ctx, type.value);
      return `encoder.push_optional_diff(&${a}, &${b}, ${innerEncode}, ${innerDiff})`;
    }
    case "record": {
      const keyEncode = renderEncodeCallback(ctx, type.key);
      const valEncode = renderEncodeCallback(ctx, type.value);
      const valEquals = renderEqualsCallback(ctx, type.value);
      const valDiff = renderEncodeDiffCallback(ctx, type.value);
      return `encoder.push_record_diff(&${a}, &${b}, ${valEquals}, ${keyEncode}, ${valEncode}, ${valDiff})`;
    }
    case "reference":
      // For enum references, use push_enum_diff
      if (type.ref.type === "enum") {
        return `encoder.push_enum_diff(${a}.to_u32(), ${b}.to_u32(), ${type.ref.numBits})`;
      }
      return `${type.ref.name!}::encode_diff_into(&${a}, &${b}, encoder)`;
    case "self-reference":
      return `${ctx.currentTypeName}::encode_diff_into(&${a}, &${b}, encoder)`;
    default:
      throw new Error(`Unexpected type in renderEncodeDiff: ${type.type}`);
  }
}

function renderDecodeDiff(
  ctx: GeneratorContext,
  type: Type,
  key: string,
): string {
  switch (type.type) {
    case "string":
      return `decoder.next_string_diff(&${key})`;
    case "int":
      if (type.min != null && type.min >= 0) {
        return type.min === 0
          ? `decoder.next_uint_diff(${key})`
          : `decoder.next_uint_diff(${key} - ${type.min}) + ${type.min}`;
      }
      return `decoder.next_int_diff(${key})`;
    case "float":
      return type.precision
        ? `decoder.next_float_quantized_diff(${key}, ${type.precision}_f32)`
        : `decoder.next_float_diff(${key})`;
    case "boolean":
      return `decoder.next_boolean_diff(${key})`;
    case "enum":
      return `${type.name!}::from_u32(decoder.next_enum_diff(${key}.to_u32(), ${type.numBits}))`;
    case "array": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      const innerDiff = renderDecodeDiffCallback(ctx, type.value);
      return `decoder.next_array_diff(&${key}, ${innerDecode}, ${innerDiff})`;
    }
    case "optional": {
      const innerDecode = renderDecodeCallback(ctx, type.value);
      const innerDiff = renderDecodeDiffCallback(ctx, type.value);
      return `decoder.next_optional_diff(&${key}, ${innerDecode}, ${innerDiff})`;
    }
    case "record": {
      const keyDecode = renderDecodeCallback(ctx, type.key);
      const valDecode = renderDecodeCallback(ctx, type.value);
      const valDiff = renderDecodeDiffCallback(ctx, type.value);
      return `decoder.next_record_diff(&${key}, ${keyDecode}, ${valDecode}, ${valDiff})`;
    }
    case "reference":
      // For enum references, use next_enum_diff
      if (type.ref.type === "enum") {
        return `${type.ref.name!}::from_u32(decoder.next_enum_diff(${key}.to_u32(), ${type.ref.numBits}))`;
      }
      return `${type.ref.name!}::decode_diff_from(&${key}, decoder)`;
    case "self-reference":
      return `Box::new(${ctx.currentTypeName}::decode_diff_from(&${key}, decoder))`;
    default:
      throw new Error(`Unexpected type in renderDecodeDiff: ${type.type}`);
  }
}
