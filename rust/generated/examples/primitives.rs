// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Primitives {
    #[serde(rename = "stringField")]
    pub string_field: String,
    #[serde(rename = "signedIntField")]
    pub signed_int_field: i64,
    #[serde(rename = "unsignedIntField")]
    pub unsigned_int_field: u64,
    #[serde(rename = "floatField")]
    pub float_field: f32,
    #[serde(rename = "booleanField")]
    pub boolean_field: bool,
}

impl Default for Primitives {
    fn default() -> Self {
        Self {
            string_field: String::new(),
            signed_int_field: 0,
            unsigned_int_field: 0,
            float_field: 0.0,
            boolean_field: false,
        }
    }
}

impl Primitives {
    pub fn equals(&self, other: &Self) -> bool {
        self.string_field == other.string_field
            && self.signed_int_field == other.signed_int_field
            && self.unsigned_int_field == other.unsigned_int_field
            && delta_pack::equals_float(self.float_field, other.float_field)
            && self.boolean_field == other.boolean_field
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.string_field);
        encoder.push_int(self.signed_int_field);
        encoder.push_uint(self.unsigned_int_field);
        encoder.push_float(self.float_field);
        encoder.push_boolean(self.boolean_field);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.string_field == b.string_field);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.string_field, &b.string_field);
        }
        let changed = !(a.signed_int_field == b.signed_int_field);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.signed_int_field, b.signed_int_field);
        }
        let changed = !(a.unsigned_int_field == b.unsigned_int_field);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.unsigned_int_field, b.unsigned_int_field);
        }
        let changed = !(delta_pack::equals_float(a.float_field, b.float_field));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.float_field, b.float_field);
        }
        encoder.push_boolean_diff(a.boolean_field, b.boolean_field);
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            string_field: decoder.next_string(),
            signed_int_field: decoder.next_int(),
            unsigned_int_field: decoder.next_uint(),
            float_field: decoder.next_float(),
            boolean_field: decoder.next_boolean(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            string_field: if decoder.next_boolean() {
                decoder.next_string_diff(&obj.string_field)
            } else {
                obj.string_field.clone()
            },
            signed_int_field: if decoder.next_boolean() {
                decoder.next_int_diff(obj.signed_int_field)
            } else {
                obj.signed_int_field.clone()
            },
            unsigned_int_field: if decoder.next_boolean() {
                decoder.next_uint_diff(obj.unsigned_int_field)
            } else {
                obj.unsigned_int_field.clone()
            },
            float_field: if decoder.next_boolean() {
                decoder.next_float_diff(obj.float_field)
            } else {
                obj.float_field.clone()
            },
            boolean_field: decoder.next_boolean_diff(obj.boolean_field),
        }
    }
}
