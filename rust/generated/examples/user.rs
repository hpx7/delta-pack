// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum HairColor {
    BLACK,
    BROWN,
    BLOND,
    RED,
    WHITE,
    OTHER,
}

impl HairColor {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => HairColor::BLACK,
            1 => HairColor::BROWN,
            2 => HairColor::BLOND,
            3 => HairColor::RED,
            4 => HairColor::WHITE,
            5 => HairColor::OTHER,
            _ => panic!("Invalid HairColor value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            HairColor::BLACK => 0,
            HairColor::BROWN => 1,
            HairColor::BLOND => 2,
            HairColor::RED => 3,
            HairColor::WHITE => 4,
            HairColor::OTHER => 5,
        }
    }
}

impl Default for HairColor {
    fn default() -> Self {
        HairColor::BLACK
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Address {
    pub street: String,
    pub zip: String,
    pub state: String,
}

impl Default for Address {
    fn default() -> Self {
        Self {
            street: String::new(),
            zip: String::new(),
            state: String::new(),
        }
    }
}

impl Address {
    pub fn equals(&self, other: &Self) -> bool {
        self.street == other.street
            && self.zip == other.zip
            && self.state == other.state
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.street);
        encoder.push_string(&self.zip);
        encoder.push_string(&self.state);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.street == b.street);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.street, &b.street);
        }
        let changed = !(a.zip == b.zip);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.zip, &b.zip);
        }
        let changed = !(a.state == b.state);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.state, &b.state);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            street: decoder.next_string(),
            zip: decoder.next_string(),
            state: decoder.next_string(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            street: if decoder.next_boolean() { decoder.next_string_diff(&obj.street) } else { obj.street.clone() },
            zip: if decoder.next_boolean() { decoder.next_string_diff(&obj.zip) } else { obj.zip.clone() },
            state: if decoder.next_boolean() { decoder.next_string_diff(&obj.state) } else { obj.state.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EmailContact {
    pub email: String,
}

impl Default for EmailContact {
    fn default() -> Self {
        Self {
            email: String::new(),
        }
    }
}

impl EmailContact {
    pub fn equals(&self, other: &Self) -> bool {
        self.email == other.email
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.email);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.email == b.email);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.email, &b.email);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            email: decoder.next_string(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            email: if decoder.next_boolean() { decoder.next_string_diff(&obj.email) } else { obj.email.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PhoneContact {
    pub phone: String,
    pub extension: Option<u64>,
}

impl Default for PhoneContact {
    fn default() -> Self {
        Self {
            phone: String::new(),
            extension: None,
        }
    }
}

impl PhoneContact {
    pub fn equals(&self, other: &Self) -> bool {
        self.phone == other.phone
            && self.extension == other.extension
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.phone);
        encoder.push_optional(&self.extension, |enc, &item| enc.push_uint(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.phone == b.phone);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.phone, &b.phone);
        }
        let changed = !(a.extension == b.extension);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.extension, &b.extension, |enc, &item| enc.push_uint(item), |enc, &a, &b| enc.push_uint_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            phone: decoder.next_string(),
            extension: decoder.next_optional(|dec| dec.next_uint()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            phone: if decoder.next_boolean() { decoder.next_string_diff(&obj.phone) } else { obj.phone.clone() },
            extension: if decoder.next_boolean() { decoder.next_optional_diff(&obj.extension, |dec| dec.next_uint(), |dec, &a| dec.next_uint_diff(a)) } else { obj.extension.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Contact {
    EmailContact(EmailContact),
    PhoneContact(PhoneContact),
}

impl Default for Contact {
    fn default() -> Self {
        Contact::EmailContact(EmailContact::default())
    }
}

impl Contact {
    pub fn equals(&self, other: &Self) -> bool {
        match (self, other) {
            (Contact::EmailContact(a), Contact::EmailContact(b)) => a.equals(b),
            (Contact::PhoneContact(a), Contact::PhoneContact(b)) => a.equals(b),
            _ => false,
        }
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        match self {
            Contact::EmailContact(v) => {
                encoder.push_enum(0, 1);
                v.encode_into(encoder);
            }
            Contact::PhoneContact(v) => {
                encoder.push_enum(1, 1);
                v.encode_into(encoder);
            }
        }
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let same_type = std::mem::discriminant(a) == std::mem::discriminant(b);
        encoder.push_boolean(same_type);
        match b {
            Contact::EmailContact(b_val) => {
                if let Contact::EmailContact(a_val) = a {
                    EmailContact::encode_diff_fields_into(a_val, b_val, encoder);
                } else {
                    encoder.push_enum(0, 1);
                    b_val.encode_into(encoder);
                }
            }
            Contact::PhoneContact(b_val) => {
                if let Contact::PhoneContact(a_val) = a {
                    PhoneContact::encode_diff_fields_into(a_val, b_val, encoder);
                } else {
                    encoder.push_enum(1, 1);
                    b_val.encode_into(encoder);
                }
            }
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        let variant = decoder.next_enum(1);
        match variant {
            0 => Contact::EmailContact(EmailContact::decode_from(decoder)),
            1 => Contact::PhoneContact(PhoneContact::decode_from(decoder)),
            _ => panic!("Invalid Contact variant: {}", variant),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let same_type = decoder.next_boolean();
        if same_type {
            match obj {
                Contact::EmailContact(v) => Contact::EmailContact(EmailContact::decode_diff_fields_from(v, decoder)),
                Contact::PhoneContact(v) => Contact::PhoneContact(PhoneContact::decode_diff_fields_from(v, decoder)),
            }
        } else {
            let variant = decoder.next_enum(1);
            match variant {
                0 => Contact::EmailContact(EmailContact::decode_from(decoder)),
                1 => Contact::PhoneContact(PhoneContact::decode_from(decoder)),
                _ => panic!("Invalid Contact variant: {}", variant),
            }
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub name: String,
    pub age: u64,
    pub weight: f32,
    pub married: bool,
    #[serde(rename = "hairColor")]
    pub hair_color: HairColor,
    pub address: Option<Address>,
    pub children: Vec<Box<User>>,
    pub metadata: HashMap<String, String>,
    #[serde(rename = "preferredContact")]
    pub preferred_contact: Option<Contact>,
}

impl Default for User {
    fn default() -> Self {
        Self {
            id: String::new(),
            name: String::new(),
            age: 0,
            weight: 0.0,
            married: false,
            hair_color: HairColor::default(),
            address: None,
            children: Vec::new(),
            metadata: HashMap::new(),
            preferred_contact: None,
        }
    }
}

impl User {
    pub fn equals(&self, other: &Self) -> bool {
        self.id == other.id
            && self.name == other.name
            && self.age == other.age
            && delta_pack::equals_float(self.weight, other.weight)
            && self.married == other.married
            && self.hair_color == other.hair_color
            && delta_pack::equals_optional(&self.address, &other.address, |x, y| x.equals(y))
            && delta_pack::equals_array(&self.children, &other.children, |x, y| x.equals(y))
            && self.metadata == other.metadata
            && delta_pack::equals_optional(&self.preferred_contact, &other.preferred_contact, |x, y| x.equals(y))
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.id);
        encoder.push_string(&self.name);
        encoder.push_uint(self.age);
        encoder.push_float(self.weight);
        encoder.push_boolean(self.married);
        encoder.push_enum(self.hair_color.to_u32(), 3);
        encoder.push_optional(&self.address, |enc, item| item.encode_into(enc));
        encoder.push_array(&self.children, |enc, item| item.encode_into(enc));
        encoder.push_record(&self.metadata, |enc, item| enc.push_string(item), |enc, item| enc.push_string(item));
        encoder.push_optional(&self.preferred_contact, |enc, item| item.encode_into(enc));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.id == b.id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.id, &b.id);
        }
        let changed = !(a.name == b.name);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.name, &b.name);
        }
        let changed = !(a.age == b.age);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.age, b.age);
        }
        let changed = !(delta_pack::equals_float(a.weight, b.weight));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.weight, b.weight);
        }
        encoder.push_boolean_diff(a.married, b.married);
        let changed = !(a.hair_color == b.hair_color);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.hair_color.to_u32(), b.hair_color.to_u32(), 3);
        }
        let changed = !(delta_pack::equals_optional(&a.address, &b.address, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.address, &b.address, |enc, item| item.encode_into(enc), |enc, a, b| Address::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_array(&a.children, &b.children, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.children, &b.children, |x, y| x.equals(y), |enc, item| item.encode_into(enc), |enc, a, b| User::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(a.metadata == b.metadata);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.metadata, &b.metadata, |x, y| x == y, |enc, item| enc.push_string(item), |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
        let changed = !(delta_pack::equals_optional(&a.preferred_contact, &b.preferred_contact, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.preferred_contact, &b.preferred_contact, |enc, item| item.encode_into(enc), |enc, a, b| Contact::encode_diff_into(a, b, enc));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            id: decoder.next_string(),
            name: decoder.next_string(),
            age: decoder.next_uint(),
            weight: decoder.next_float(),
            married: decoder.next_boolean(),
            hair_color: HairColor::from_u32(decoder.next_enum(3)),
            address: decoder.next_optional(|dec| Address::decode_from(dec)),
            children: decoder.next_array(|dec| Box::new(User::decode_from(dec))),
            metadata: decoder.next_record(|dec| dec.next_string(), |dec| dec.next_string()),
            preferred_contact: decoder.next_optional(|dec| Contact::decode_from(dec)),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            id: if decoder.next_boolean() { decoder.next_string_diff(&obj.id) } else { obj.id.clone() },
            name: if decoder.next_boolean() { decoder.next_string_diff(&obj.name) } else { obj.name.clone() },
            age: if decoder.next_boolean() { decoder.next_uint_diff(obj.age) } else { obj.age.clone() },
            weight: if decoder.next_boolean() { decoder.next_float_diff(obj.weight) } else { obj.weight.clone() },
            married: decoder.next_boolean_diff(obj.married),
            hair_color: if decoder.next_boolean() { HairColor::from_u32(decoder.next_enum_diff(obj.hair_color.to_u32(), 3)) } else { obj.hair_color.clone() },
            address: if decoder.next_boolean() { decoder.next_optional_diff(&obj.address, |dec| Address::decode_from(dec), |dec, a| Address::decode_diff_fields_from(a, dec)) } else { obj.address.clone() },
            children: if decoder.next_boolean() { decoder.next_array_diff(&obj.children, |dec| Box::new(User::decode_from(dec)), |dec, a| Box::new(User::decode_diff_fields_from(a, dec))) } else { obj.children.clone() },
            metadata: if decoder.next_boolean() { decoder.next_record_diff(&obj.metadata, |dec| dec.next_string(), |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.metadata.clone() },
            preferred_contact: if decoder.next_boolean() { decoder.next_optional_diff(&obj.preferred_contact, |dec| Contact::decode_from(dec), |dec, a| Contact::decode_diff_from(a, dec)) } else { obj.preferred_contact.clone() },
        }
    }
}
