// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Team {
    RED,
    BLUE,
    GREEN,
    YELLOW,
}

impl Team {
    pub const NUM_BITS: u8 = 2;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => Team::RED,
            1 => Team::BLUE,
            2 => Team::GREEN,
            3 => Team::YELLOW,
            _ => panic!("Invalid Team value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            Team::RED => 0,
            Team::BLUE => 1,
            Team::GREEN => 2,
            Team::YELLOW => 3,
        }
    }
}

impl Default for Team {
    fn default() -> Self {
        Team::RED
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PlayerStatus {
    ALIVE,
    DEAD,
    SPECTATING,
    DISCONNECTED,
}

impl PlayerStatus {
    pub const NUM_BITS: u8 = 2;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => PlayerStatus::ALIVE,
            1 => PlayerStatus::DEAD,
            2 => PlayerStatus::SPECTATING,
            3 => PlayerStatus::DISCONNECTED,
            _ => panic!("Invalid PlayerStatus value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            PlayerStatus::ALIVE => 0,
            PlayerStatus::DEAD => 1,
            PlayerStatus::SPECTATING => 2,
            PlayerStatus::DISCONNECTED => 3,
        }
    }
}

impl Default for PlayerStatus {
    fn default() -> Self {
        PlayerStatus::ALIVE
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum WeaponType {
    SWORD,
    BOW,
    STAFF,
    DAGGER,
    AXE,
}

impl WeaponType {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => WeaponType::SWORD,
            1 => WeaponType::BOW,
            2 => WeaponType::STAFF,
            3 => WeaponType::DAGGER,
            4 => WeaponType::AXE,
            _ => panic!("Invalid WeaponType value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            WeaponType::SWORD => 0,
            WeaponType::BOW => 1,
            WeaponType::STAFF => 2,
            WeaponType::DAGGER => 3,
            WeaponType::AXE => 4,
        }
    }
}

impl Default for WeaponType {
    fn default() -> Self {
        WeaponType::SWORD
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ItemRarity {
    COMMON,
    UNCOMMON,
    RARE,
    EPIC,
    LEGENDARY,
}

impl ItemRarity {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => ItemRarity::COMMON,
            1 => ItemRarity::UNCOMMON,
            2 => ItemRarity::RARE,
            3 => ItemRarity::EPIC,
            4 => ItemRarity::LEGENDARY,
            _ => panic!("Invalid ItemRarity value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            ItemRarity::COMMON => 0,
            ItemRarity::UNCOMMON => 1,
            ItemRarity::RARE => 2,
            ItemRarity::EPIC => 3,
            ItemRarity::LEGENDARY => 4,
        }
    }
}

impl Default for ItemRarity {
    fn default() -> Self {
        ItemRarity::COMMON
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum AbilityType {
    HEAL,
    DAMAGE,
    SHIELD,
    BUFF,
    DEBUFF,
    TELEPORT,
}

impl AbilityType {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => AbilityType::HEAL,
            1 => AbilityType::DAMAGE,
            2 => AbilityType::SHIELD,
            3 => AbilityType::BUFF,
            4 => AbilityType::DEBUFF,
            5 => AbilityType::TELEPORT,
            _ => panic!("Invalid AbilityType value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            AbilityType::HEAL => 0,
            AbilityType::DAMAGE => 1,
            AbilityType::SHIELD => 2,
            AbilityType::BUFF => 3,
            AbilityType::DEBUFF => 4,
            AbilityType::TELEPORT => 5,
        }
    }
}

impl Default for AbilityType {
    fn default() -> Self {
        AbilityType::HEAL
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum EffectType {
    POISON,
    BURN,
    FREEZE,
    STUN,
    REGEN,
    HASTE,
}

impl EffectType {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => EffectType::POISON,
            1 => EffectType::BURN,
            2 => EffectType::FREEZE,
            3 => EffectType::STUN,
            4 => EffectType::REGEN,
            5 => EffectType::HASTE,
            _ => panic!("Invalid EffectType value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            EffectType::POISON => 0,
            EffectType::BURN => 1,
            EffectType::FREEZE => 2,
            EffectType::STUN => 3,
            EffectType::REGEN => 4,
            EffectType::HASTE => 5,
        }
    }
}

impl Default for EffectType {
    fn default() -> Self {
        EffectType::POISON
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Position {
    pub x: f32,
    pub y: f32,
}

impl Default for Position {
    fn default() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
        }
    }
}

impl Position {
    pub fn equals(&self, other: &Self) -> bool {
        delta_pack::equals_float_quantized(self.x, other.x, 0.1_f32)
            && delta_pack::equals_float_quantized(self.y, other.y, 0.1_f32)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_float_quantized(self.x, 0.1_f32);
        encoder.push_float_quantized(self.y, 0.1_f32);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(delta_pack::equals_float_quantized(a.x, b.x, 0.1_f32));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_quantized_diff(a.x, b.x, 0.1_f32);
        }
        let changed = !(delta_pack::equals_float_quantized(a.y, b.y, 0.1_f32));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_quantized_diff(a.y, b.y, 0.1_f32);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            x: decoder.next_float_quantized(0.1_f32),
            y: decoder.next_float_quantized(0.1_f32),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            x: if decoder.next_boolean() { decoder.next_float_quantized_diff(obj.x, 0.1_f32) } else { obj.x.clone() },
            y: if decoder.next_boolean() { decoder.next_float_quantized_diff(obj.y, 0.1_f32) } else { obj.y.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Velocity {
    pub vx: f32,
    pub vy: f32,
}

impl Default for Velocity {
    fn default() -> Self {
        Self {
            vx: 0.0,
            vy: 0.0,
        }
    }
}

impl Velocity {
    pub fn equals(&self, other: &Self) -> bool {
        delta_pack::equals_float(self.vx, other.vx)
            && delta_pack::equals_float(self.vy, other.vy)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_float(self.vx);
        encoder.push_float(self.vy);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(delta_pack::equals_float(a.vx, b.vx));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.vx, b.vx);
        }
        let changed = !(delta_pack::equals_float(a.vy, b.vy));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.vy, b.vy);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            vx: decoder.next_float(),
            vy: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            vx: if decoder.next_boolean() { decoder.next_float_diff(obj.vx) } else { obj.vx.clone() },
            vy: if decoder.next_boolean() { decoder.next_float_diff(obj.vy) } else { obj.vy.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct InventoryItem {
    #[serde(rename = "itemId")]
    pub item_id: String,
    pub name: String,
    pub quantity: u64,
    pub rarity: ItemRarity,
    pub durability: Option<u64>,
    #[serde(rename = "enchantmentLevel")]
    pub enchantment_level: Option<u64>,
}

impl Default for InventoryItem {
    fn default() -> Self {
        Self {
            item_id: String::new(),
            name: String::new(),
            quantity: 0,
            rarity: ItemRarity::default(),
            durability: None,
            enchantment_level: None,
        }
    }
}

impl InventoryItem {
    pub fn equals(&self, other: &Self) -> bool {
        self.item_id == other.item_id
            && self.name == other.name
            && self.quantity == other.quantity
            && self.rarity == other.rarity
            && self.durability == other.durability
            && self.enchantment_level == other.enchantment_level
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.item_id);
        encoder.push_string(&self.name);
        encoder.push_uint(self.quantity);
        encoder.push_enum(self.rarity.to_u32(), 3);
        encoder.push_optional(&self.durability, |enc, &item| enc.push_uint(item));
        encoder.push_optional(&self.enchantment_level, |enc, &item| enc.push_uint(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.item_id == b.item_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.item_id, &b.item_id);
        }
        let changed = !(a.name == b.name);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.name, &b.name);
        }
        let changed = !(a.quantity == b.quantity);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.quantity, b.quantity);
        }
        let changed = !(a.rarity == b.rarity);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.rarity.to_u32(), b.rarity.to_u32(), 3);
        }
        let changed = !(a.durability == b.durability);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.durability, &b.durability, |enc, &item| enc.push_uint(item), |enc, &a, &b| enc.push_uint_diff(a, b));
        }
        let changed = !(a.enchantment_level == b.enchantment_level);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.enchantment_level, &b.enchantment_level, |enc, &item| enc.push_uint(item), |enc, &a, &b| enc.push_uint_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            item_id: decoder.next_string(),
            name: decoder.next_string(),
            quantity: decoder.next_uint(),
            rarity: ItemRarity::from_u32(decoder.next_enum(3)),
            durability: decoder.next_optional(|dec| dec.next_uint()),
            enchantment_level: decoder.next_optional(|dec| dec.next_uint()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            item_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.item_id) } else { obj.item_id.clone() },
            name: if decoder.next_boolean() { decoder.next_string_diff(&obj.name) } else { obj.name.clone() },
            quantity: if decoder.next_boolean() { decoder.next_uint_diff(obj.quantity) } else { obj.quantity.clone() },
            rarity: if decoder.next_boolean() { ItemRarity::from_u32(decoder.next_enum_diff(obj.rarity.to_u32(), 3)) } else { obj.rarity.clone() },
            durability: if decoder.next_boolean() { decoder.next_optional_diff(&obj.durability, |dec| dec.next_uint(), |dec, &a| dec.next_uint_diff(a)) } else { obj.durability.clone() },
            enchantment_level: if decoder.next_boolean() { decoder.next_optional_diff(&obj.enchantment_level, |dec| dec.next_uint(), |dec, &a| dec.next_uint_diff(a)) } else { obj.enchantment_level.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Equipment {
    pub weapon: Option<WeaponType>,
    pub armor: Option<String>,
    pub accessory1: Option<String>,
    pub accessory2: Option<String>,
}

impl Default for Equipment {
    fn default() -> Self {
        Self {
            weapon: None,
            armor: None,
            accessory1: None,
            accessory2: None,
        }
    }
}

impl Equipment {
    pub fn equals(&self, other: &Self) -> bool {
        self.weapon == other.weapon
            && self.armor == other.armor
            && self.accessory1 == other.accessory1
            && self.accessory2 == other.accessory2
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_optional(&self.weapon, |enc, &item| enc.push_enum(item.to_u32(), 3));
        encoder.push_optional(&self.armor, |enc, item| enc.push_string(item));
        encoder.push_optional(&self.accessory1, |enc, item| enc.push_string(item));
        encoder.push_optional(&self.accessory2, |enc, item| enc.push_string(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.weapon == b.weapon);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.weapon, &b.weapon, |enc, &item| enc.push_enum(item.to_u32(), 3), |enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), 3));
        }
        let changed = !(a.armor == b.armor);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.armor, &b.armor, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
        let changed = !(a.accessory1 == b.accessory1);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.accessory1, &b.accessory1, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
        let changed = !(a.accessory2 == b.accessory2);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.accessory2, &b.accessory2, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            weapon: decoder.next_optional(|dec| WeaponType::from_u32(dec.next_enum(3))),
            armor: decoder.next_optional(|dec| dec.next_string()),
            accessory1: decoder.next_optional(|dec| dec.next_string()),
            accessory2: decoder.next_optional(|dec| dec.next_string()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            weapon: if decoder.next_boolean() { decoder.next_optional_diff(&obj.weapon, |dec| WeaponType::from_u32(dec.next_enum(3)), |dec, &a| WeaponType::from_u32(dec.next_enum_diff(a.to_u32(), 3))) } else { obj.weapon.clone() },
            armor: if decoder.next_boolean() { decoder.next_optional_diff(&obj.armor, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.armor.clone() },
            accessory1: if decoder.next_boolean() { decoder.next_optional_diff(&obj.accessory1, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.accessory1.clone() },
            accessory2: if decoder.next_boolean() { decoder.next_optional_diff(&obj.accessory2, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.accessory2.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PlayerStats {
    pub health: u64,
    #[serde(rename = "maxHealth")]
    pub max_health: u64,
    pub mana: u64,
    #[serde(rename = "maxMana")]
    pub max_mana: u64,
    pub stamina: u64,
    #[serde(rename = "maxStamina")]
    pub max_stamina: u64,
    pub level: u64,
    pub experience: u64,
    pub strength: u64,
    pub agility: u64,
    pub intelligence: u64,
    pub defense: u64,
}

impl Default for PlayerStats {
    fn default() -> Self {
        Self {
            health: 0,
            max_health: 0,
            mana: 0,
            max_mana: 0,
            stamina: 0,
            max_stamina: 0,
            level: 0,
            experience: 0,
            strength: 0,
            agility: 0,
            intelligence: 0,
            defense: 0,
        }
    }
}

impl PlayerStats {
    pub fn equals(&self, other: &Self) -> bool {
        self.health == other.health
            && self.max_health == other.max_health
            && self.mana == other.mana
            && self.max_mana == other.max_mana
            && self.stamina == other.stamina
            && self.max_stamina == other.max_stamina
            && self.level == other.level
            && self.experience == other.experience
            && self.strength == other.strength
            && self.agility == other.agility
            && self.intelligence == other.intelligence
            && self.defense == other.defense
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_uint(self.health);
        encoder.push_uint(self.max_health);
        encoder.push_uint(self.mana);
        encoder.push_uint(self.max_mana);
        encoder.push_uint(self.stamina);
        encoder.push_uint(self.max_stamina);
        encoder.push_uint(self.level);
        encoder.push_uint(self.experience);
        encoder.push_uint(self.strength);
        encoder.push_uint(self.agility);
        encoder.push_uint(self.intelligence);
        encoder.push_uint(self.defense);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.health == b.health);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.health, b.health);
        }
        let changed = !(a.max_health == b.max_health);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.max_health, b.max_health);
        }
        let changed = !(a.mana == b.mana);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.mana, b.mana);
        }
        let changed = !(a.max_mana == b.max_mana);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.max_mana, b.max_mana);
        }
        let changed = !(a.stamina == b.stamina);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.stamina, b.stamina);
        }
        let changed = !(a.max_stamina == b.max_stamina);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.max_stamina, b.max_stamina);
        }
        let changed = !(a.level == b.level);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.level, b.level);
        }
        let changed = !(a.experience == b.experience);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.experience, b.experience);
        }
        let changed = !(a.strength == b.strength);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.strength, b.strength);
        }
        let changed = !(a.agility == b.agility);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.agility, b.agility);
        }
        let changed = !(a.intelligence == b.intelligence);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.intelligence, b.intelligence);
        }
        let changed = !(a.defense == b.defense);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.defense, b.defense);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            health: decoder.next_uint(),
            max_health: decoder.next_uint(),
            mana: decoder.next_uint(),
            max_mana: decoder.next_uint(),
            stamina: decoder.next_uint(),
            max_stamina: decoder.next_uint(),
            level: decoder.next_uint(),
            experience: decoder.next_uint(),
            strength: decoder.next_uint(),
            agility: decoder.next_uint(),
            intelligence: decoder.next_uint(),
            defense: decoder.next_uint(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            health: if decoder.next_boolean() { decoder.next_uint_diff(obj.health) } else { obj.health.clone() },
            max_health: if decoder.next_boolean() { decoder.next_uint_diff(obj.max_health) } else { obj.max_health.clone() },
            mana: if decoder.next_boolean() { decoder.next_uint_diff(obj.mana) } else { obj.mana.clone() },
            max_mana: if decoder.next_boolean() { decoder.next_uint_diff(obj.max_mana) } else { obj.max_mana.clone() },
            stamina: if decoder.next_boolean() { decoder.next_uint_diff(obj.stamina) } else { obj.stamina.clone() },
            max_stamina: if decoder.next_boolean() { decoder.next_uint_diff(obj.max_stamina) } else { obj.max_stamina.clone() },
            level: if decoder.next_boolean() { decoder.next_uint_diff(obj.level) } else { obj.level.clone() },
            experience: if decoder.next_boolean() { decoder.next_uint_diff(obj.experience) } else { obj.experience.clone() },
            strength: if decoder.next_boolean() { decoder.next_uint_diff(obj.strength) } else { obj.strength.clone() },
            agility: if decoder.next_boolean() { decoder.next_uint_diff(obj.agility) } else { obj.agility.clone() },
            intelligence: if decoder.next_boolean() { decoder.next_uint_diff(obj.intelligence) } else { obj.intelligence.clone() },
            defense: if decoder.next_boolean() { decoder.next_uint_diff(obj.defense) } else { obj.defense.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActiveEffect {
    #[serde(rename = "effectType")]
    pub effect_type: EffectType,
    pub duration: f32,
    pub strength: u64,
    #[serde(rename = "stackCount")]
    pub stack_count: u64,
}

impl Default for ActiveEffect {
    fn default() -> Self {
        Self {
            effect_type: EffectType::default(),
            duration: 0.0,
            strength: 0,
            stack_count: 0,
        }
    }
}

impl ActiveEffect {
    pub fn equals(&self, other: &Self) -> bool {
        self.effect_type == other.effect_type
            && delta_pack::equals_float(self.duration, other.duration)
            && self.strength == other.strength
            && self.stack_count == other.stack_count
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_enum(self.effect_type.to_u32(), 3);
        encoder.push_float(self.duration);
        encoder.push_uint(self.strength);
        encoder.push_uint(self.stack_count);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.effect_type == b.effect_type);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.effect_type.to_u32(), b.effect_type.to_u32(), 3);
        }
        let changed = !(delta_pack::equals_float(a.duration, b.duration));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.duration, b.duration);
        }
        let changed = !(a.strength == b.strength);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.strength, b.strength);
        }
        let changed = !(a.stack_count == b.stack_count);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.stack_count, b.stack_count);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            effect_type: EffectType::from_u32(decoder.next_enum(3)),
            duration: decoder.next_float(),
            strength: decoder.next_uint(),
            stack_count: decoder.next_uint(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            effect_type: if decoder.next_boolean() { EffectType::from_u32(decoder.next_enum_diff(obj.effect_type.to_u32(), 3)) } else { obj.effect_type.clone() },
            duration: if decoder.next_boolean() { decoder.next_float_diff(obj.duration) } else { obj.duration.clone() },
            strength: if decoder.next_boolean() { decoder.next_uint_diff(obj.strength) } else { obj.strength.clone() },
            stack_count: if decoder.next_boolean() { decoder.next_uint_diff(obj.stack_count) } else { obj.stack_count.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AbilityCooldown {
    #[serde(rename = "abilityId")]
    pub ability_id: String,
    #[serde(rename = "abilityType")]
    pub ability_type: AbilityType,
    #[serde(rename = "remainingCooldown")]
    pub remaining_cooldown: f32,
}

impl Default for AbilityCooldown {
    fn default() -> Self {
        Self {
            ability_id: String::new(),
            ability_type: AbilityType::default(),
            remaining_cooldown: 0.0,
        }
    }
}

impl AbilityCooldown {
    pub fn equals(&self, other: &Self) -> bool {
        self.ability_id == other.ability_id
            && self.ability_type == other.ability_type
            && delta_pack::equals_float(self.remaining_cooldown, other.remaining_cooldown)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.ability_id);
        encoder.push_enum(self.ability_type.to_u32(), 3);
        encoder.push_float(self.remaining_cooldown);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.ability_id == b.ability_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.ability_id, &b.ability_id);
        }
        let changed = !(a.ability_type == b.ability_type);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.ability_type.to_u32(), b.ability_type.to_u32(), 3);
        }
        let changed = !(delta_pack::equals_float(a.remaining_cooldown, b.remaining_cooldown));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.remaining_cooldown, b.remaining_cooldown);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            ability_id: decoder.next_string(),
            ability_type: AbilityType::from_u32(decoder.next_enum(3)),
            remaining_cooldown: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            ability_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.ability_id) } else { obj.ability_id.clone() },
            ability_type: if decoder.next_boolean() { AbilityType::from_u32(decoder.next_enum_diff(obj.ability_type.to_u32(), 3)) } else { obj.ability_type.clone() },
            remaining_cooldown: if decoder.next_boolean() { decoder.next_float_diff(obj.remaining_cooldown) } else { obj.remaining_cooldown.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Player {
    #[serde(rename = "playerId")]
    pub player_id: String,
    pub username: String,
    pub team: Option<Team>,
    pub status: PlayerStatus,
    pub position: Position,
    pub velocity: Velocity,
    pub rotation: f32,
    pub stats: PlayerStats,
    pub inventory: Vec<InventoryItem>,
    pub equipment: Equipment,
    #[serde(rename = "activeEffects")]
    pub active_effects: Vec<ActiveEffect>,
    #[serde(rename = "abilityCooldowns")]
    pub ability_cooldowns: Vec<AbilityCooldown>,
    pub kills: u64,
    pub deaths: u64,
    pub assists: u64,
    pub gold: u64,
    pub score: i64,
    pub ping: u64,
    #[serde(rename = "isJumping")]
    pub is_jumping: bool,
    #[serde(rename = "isCrouching")]
    pub is_crouching: bool,
    #[serde(rename = "isAiming")]
    pub is_aiming: bool,
    #[serde(rename = "lastDamageTime")]
    pub last_damage_time: Option<f32>,
    #[serde(rename = "respawnTime")]
    pub respawn_time: Option<f32>,
}

impl Default for Player {
    fn default() -> Self {
        Self {
            player_id: String::new(),
            username: String::new(),
            team: None,
            status: PlayerStatus::default(),
            position: Position::default(),
            velocity: Velocity::default(),
            rotation: 0.0,
            stats: PlayerStats::default(),
            inventory: Vec::new(),
            equipment: Equipment::default(),
            active_effects: Vec::new(),
            ability_cooldowns: Vec::new(),
            kills: 0,
            deaths: 0,
            assists: 0,
            gold: 0,
            score: 0,
            ping: 0,
            is_jumping: false,
            is_crouching: false,
            is_aiming: false,
            last_damage_time: None,
            respawn_time: None,
        }
    }
}

impl Player {
    pub fn equals(&self, other: &Self) -> bool {
        self.player_id == other.player_id
            && self.username == other.username
            && self.team == other.team
            && self.status == other.status
            && self.position.equals(&other.position)
            && self.velocity.equals(&other.velocity)
            && delta_pack::equals_float(self.rotation, other.rotation)
            && self.stats.equals(&other.stats)
            && delta_pack::equals_array(&self.inventory, &other.inventory, |x, y| x.equals(y))
            && self.equipment.equals(&other.equipment)
            && delta_pack::equals_array(&self.active_effects, &other.active_effects, |x, y| x.equals(y))
            && delta_pack::equals_array(&self.ability_cooldowns, &other.ability_cooldowns, |x, y| x.equals(y))
            && self.kills == other.kills
            && self.deaths == other.deaths
            && self.assists == other.assists
            && self.gold == other.gold
            && self.score == other.score
            && self.ping == other.ping
            && self.is_jumping == other.is_jumping
            && self.is_crouching == other.is_crouching
            && self.is_aiming == other.is_aiming
            && self.last_damage_time == other.last_damage_time
            && self.respawn_time == other.respawn_time
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.player_id);
        encoder.push_string(&self.username);
        encoder.push_optional(&self.team, |enc, &item| enc.push_enum(item.to_u32(), 2));
        encoder.push_enum(self.status.to_u32(), 2);
        self.position.encode_into(encoder);
        self.velocity.encode_into(encoder);
        encoder.push_float(self.rotation);
        self.stats.encode_into(encoder);
        encoder.push_array(&self.inventory, |enc, item| item.encode_into(enc));
        self.equipment.encode_into(encoder);
        encoder.push_array(&self.active_effects, |enc, item| item.encode_into(enc));
        encoder.push_array(&self.ability_cooldowns, |enc, item| item.encode_into(enc));
        encoder.push_uint(self.kills);
        encoder.push_uint(self.deaths);
        encoder.push_uint(self.assists);
        encoder.push_uint(self.gold);
        encoder.push_int(self.score);
        encoder.push_uint(self.ping);
        encoder.push_boolean(self.is_jumping);
        encoder.push_boolean(self.is_crouching);
        encoder.push_boolean(self.is_aiming);
        encoder.push_optional(&self.last_damage_time, |enc, &item| enc.push_float(item));
        encoder.push_optional(&self.respawn_time, |enc, &item| enc.push_float(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.player_id == b.player_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.player_id, &b.player_id);
        }
        let changed = !(a.username == b.username);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.username, &b.username);
        }
        let changed = !(a.team == b.team);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.team, &b.team, |enc, &item| enc.push_enum(item.to_u32(), 2), |enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), 2));
        }
        let changed = !(a.status == b.status);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.status.to_u32(), b.status.to_u32(), 2);
        }
        Position::encode_diff_into(&a.position, &b.position, encoder);
        Velocity::encode_diff_into(&a.velocity, &b.velocity, encoder);
        let changed = !(delta_pack::equals_float(a.rotation, b.rotation));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.rotation, b.rotation);
        }
        PlayerStats::encode_diff_into(&a.stats, &b.stats, encoder);
        let changed = !(delta_pack::equals_array(&a.inventory, &b.inventory, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.inventory, &b.inventory, |x, y| x.equals(y), |enc, item| item.encode_into(enc), |enc, a, b| InventoryItem::encode_diff_fields_into(a, b, enc));
        }
        Equipment::encode_diff_into(&a.equipment, &b.equipment, encoder);
        let changed = !(delta_pack::equals_array(&a.active_effects, &b.active_effects, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.active_effects, &b.active_effects, |x, y| x.equals(y), |enc, item| item.encode_into(enc), |enc, a, b| ActiveEffect::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_array(&a.ability_cooldowns, &b.ability_cooldowns, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.ability_cooldowns, &b.ability_cooldowns, |x, y| x.equals(y), |enc, item| item.encode_into(enc), |enc, a, b| AbilityCooldown::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(a.kills == b.kills);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.kills, b.kills);
        }
        let changed = !(a.deaths == b.deaths);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.deaths, b.deaths);
        }
        let changed = !(a.assists == b.assists);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.assists, b.assists);
        }
        let changed = !(a.gold == b.gold);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.gold, b.gold);
        }
        let changed = !(a.score == b.score);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.score, b.score);
        }
        let changed = !(a.ping == b.ping);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.ping, b.ping);
        }
        encoder.push_boolean_diff(a.is_jumping, b.is_jumping);
        encoder.push_boolean_diff(a.is_crouching, b.is_crouching);
        encoder.push_boolean_diff(a.is_aiming, b.is_aiming);
        let changed = !(a.last_damage_time == b.last_damage_time);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.last_damage_time, &b.last_damage_time, |enc, &item| enc.push_float(item), |enc, &a, &b| enc.push_float_diff(a, b));
        }
        let changed = !(a.respawn_time == b.respawn_time);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.respawn_time, &b.respawn_time, |enc, &item| enc.push_float(item), |enc, &a, &b| enc.push_float_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            player_id: decoder.next_string(),
            username: decoder.next_string(),
            team: decoder.next_optional(|dec| Team::from_u32(dec.next_enum(2))),
            status: PlayerStatus::from_u32(decoder.next_enum(2)),
            position: Position::decode_from(decoder),
            velocity: Velocity::decode_from(decoder),
            rotation: decoder.next_float(),
            stats: PlayerStats::decode_from(decoder),
            inventory: decoder.next_array(|dec| InventoryItem::decode_from(dec)),
            equipment: Equipment::decode_from(decoder),
            active_effects: decoder.next_array(|dec| ActiveEffect::decode_from(dec)),
            ability_cooldowns: decoder.next_array(|dec| AbilityCooldown::decode_from(dec)),
            kills: decoder.next_uint(),
            deaths: decoder.next_uint(),
            assists: decoder.next_uint(),
            gold: decoder.next_uint(),
            score: decoder.next_int(),
            ping: decoder.next_uint(),
            is_jumping: decoder.next_boolean(),
            is_crouching: decoder.next_boolean(),
            is_aiming: decoder.next_boolean(),
            last_damage_time: decoder.next_optional(|dec| dec.next_float()),
            respawn_time: decoder.next_optional(|dec| dec.next_float()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            player_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.player_id) } else { obj.player_id.clone() },
            username: if decoder.next_boolean() { decoder.next_string_diff(&obj.username) } else { obj.username.clone() },
            team: if decoder.next_boolean() { decoder.next_optional_diff(&obj.team, |dec| Team::from_u32(dec.next_enum(2)), |dec, &a| Team::from_u32(dec.next_enum_diff(a.to_u32(), 2))) } else { obj.team.clone() },
            status: if decoder.next_boolean() { PlayerStatus::from_u32(decoder.next_enum_diff(obj.status.to_u32(), 2)) } else { obj.status.clone() },
            position: Position::decode_diff_from(&obj.position, decoder),
            velocity: Velocity::decode_diff_from(&obj.velocity, decoder),
            rotation: if decoder.next_boolean() { decoder.next_float_diff(obj.rotation) } else { obj.rotation.clone() },
            stats: PlayerStats::decode_diff_from(&obj.stats, decoder),
            inventory: if decoder.next_boolean() { decoder.next_array_diff(&obj.inventory, |dec| InventoryItem::decode_from(dec), |dec, a| InventoryItem::decode_diff_fields_from(a, dec)) } else { obj.inventory.clone() },
            equipment: Equipment::decode_diff_from(&obj.equipment, decoder),
            active_effects: if decoder.next_boolean() { decoder.next_array_diff(&obj.active_effects, |dec| ActiveEffect::decode_from(dec), |dec, a| ActiveEffect::decode_diff_fields_from(a, dec)) } else { obj.active_effects.clone() },
            ability_cooldowns: if decoder.next_boolean() { decoder.next_array_diff(&obj.ability_cooldowns, |dec| AbilityCooldown::decode_from(dec), |dec, a| AbilityCooldown::decode_diff_fields_from(a, dec)) } else { obj.ability_cooldowns.clone() },
            kills: if decoder.next_boolean() { decoder.next_uint_diff(obj.kills) } else { obj.kills.clone() },
            deaths: if decoder.next_boolean() { decoder.next_uint_diff(obj.deaths) } else { obj.deaths.clone() },
            assists: if decoder.next_boolean() { decoder.next_uint_diff(obj.assists) } else { obj.assists.clone() },
            gold: if decoder.next_boolean() { decoder.next_uint_diff(obj.gold) } else { obj.gold.clone() },
            score: if decoder.next_boolean() { decoder.next_int_diff(obj.score) } else { obj.score.clone() },
            ping: if decoder.next_boolean() { decoder.next_uint_diff(obj.ping) } else { obj.ping.clone() },
            is_jumping: decoder.next_boolean_diff(obj.is_jumping),
            is_crouching: decoder.next_boolean_diff(obj.is_crouching),
            is_aiming: decoder.next_boolean_diff(obj.is_aiming),
            last_damage_time: if decoder.next_boolean() { decoder.next_optional_diff(&obj.last_damage_time, |dec| dec.next_float(), |dec, &a| dec.next_float_diff(a)) } else { obj.last_damage_time.clone() },
            respawn_time: if decoder.next_boolean() { decoder.next_optional_diff(&obj.respawn_time, |dec| dec.next_float(), |dec, &a| dec.next_float_diff(a)) } else { obj.respawn_time.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Enemy {
    #[serde(rename = "enemyId")]
    pub enemy_id: String,
    pub name: String,
    pub position: Position,
    pub velocity: Velocity,
    pub health: u64,
    #[serde(rename = "maxHealth")]
    pub max_health: u64,
    pub level: u64,
    #[serde(rename = "isAggro")]
    pub is_aggro: bool,
    #[serde(rename = "targetPlayerId")]
    pub target_player_id: Option<String>,
    #[serde(rename = "lastAttackTime")]
    pub last_attack_time: f32,
    #[serde(rename = "lootTableId")]
    pub loot_table_id: Option<String>,
}

impl Default for Enemy {
    fn default() -> Self {
        Self {
            enemy_id: String::new(),
            name: String::new(),
            position: Position::default(),
            velocity: Velocity::default(),
            health: 0,
            max_health: 0,
            level: 0,
            is_aggro: false,
            target_player_id: None,
            last_attack_time: 0.0,
            loot_table_id: None,
        }
    }
}

impl Enemy {
    pub fn equals(&self, other: &Self) -> bool {
        self.enemy_id == other.enemy_id
            && self.name == other.name
            && self.position.equals(&other.position)
            && self.velocity.equals(&other.velocity)
            && self.health == other.health
            && self.max_health == other.max_health
            && self.level == other.level
            && self.is_aggro == other.is_aggro
            && self.target_player_id == other.target_player_id
            && delta_pack::equals_float(self.last_attack_time, other.last_attack_time)
            && self.loot_table_id == other.loot_table_id
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.enemy_id);
        encoder.push_string(&self.name);
        self.position.encode_into(encoder);
        self.velocity.encode_into(encoder);
        encoder.push_uint(self.health);
        encoder.push_uint(self.max_health);
        encoder.push_uint(self.level);
        encoder.push_boolean(self.is_aggro);
        encoder.push_optional(&self.target_player_id, |enc, item| enc.push_string(item));
        encoder.push_float(self.last_attack_time);
        encoder.push_optional(&self.loot_table_id, |enc, item| enc.push_string(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.enemy_id == b.enemy_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.enemy_id, &b.enemy_id);
        }
        let changed = !(a.name == b.name);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.name, &b.name);
        }
        Position::encode_diff_into(&a.position, &b.position, encoder);
        Velocity::encode_diff_into(&a.velocity, &b.velocity, encoder);
        let changed = !(a.health == b.health);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.health, b.health);
        }
        let changed = !(a.max_health == b.max_health);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.max_health, b.max_health);
        }
        let changed = !(a.level == b.level);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.level, b.level);
        }
        encoder.push_boolean_diff(a.is_aggro, b.is_aggro);
        let changed = !(a.target_player_id == b.target_player_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.target_player_id, &b.target_player_id, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
        let changed = !(delta_pack::equals_float(a.last_attack_time, b.last_attack_time));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.last_attack_time, b.last_attack_time);
        }
        let changed = !(a.loot_table_id == b.loot_table_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.loot_table_id, &b.loot_table_id, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            enemy_id: decoder.next_string(),
            name: decoder.next_string(),
            position: Position::decode_from(decoder),
            velocity: Velocity::decode_from(decoder),
            health: decoder.next_uint(),
            max_health: decoder.next_uint(),
            level: decoder.next_uint(),
            is_aggro: decoder.next_boolean(),
            target_player_id: decoder.next_optional(|dec| dec.next_string()),
            last_attack_time: decoder.next_float(),
            loot_table_id: decoder.next_optional(|dec| dec.next_string()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            enemy_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.enemy_id) } else { obj.enemy_id.clone() },
            name: if decoder.next_boolean() { decoder.next_string_diff(&obj.name) } else { obj.name.clone() },
            position: Position::decode_diff_from(&obj.position, decoder),
            velocity: Velocity::decode_diff_from(&obj.velocity, decoder),
            health: if decoder.next_boolean() { decoder.next_uint_diff(obj.health) } else { obj.health.clone() },
            max_health: if decoder.next_boolean() { decoder.next_uint_diff(obj.max_health) } else { obj.max_health.clone() },
            level: if decoder.next_boolean() { decoder.next_uint_diff(obj.level) } else { obj.level.clone() },
            is_aggro: decoder.next_boolean_diff(obj.is_aggro),
            target_player_id: if decoder.next_boolean() { decoder.next_optional_diff(&obj.target_player_id, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.target_player_id.clone() },
            last_attack_time: if decoder.next_boolean() { decoder.next_float_diff(obj.last_attack_time) } else { obj.last_attack_time.clone() },
            loot_table_id: if decoder.next_boolean() { decoder.next_optional_diff(&obj.loot_table_id, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.loot_table_id.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Projectile {
    #[serde(rename = "projectileId")]
    pub projectile_id: String,
    #[serde(rename = "ownerId")]
    pub owner_id: String,
    pub position: Position,
    pub velocity: Velocity,
    pub damage: u64,
    pub penetration: u64,
    #[serde(rename = "timeToLive")]
    pub time_to_live: f32,
    #[serde(rename = "hitPlayers")]
    pub hit_players: Vec<String>,
}

impl Default for Projectile {
    fn default() -> Self {
        Self {
            projectile_id: String::new(),
            owner_id: String::new(),
            position: Position::default(),
            velocity: Velocity::default(),
            damage: 0,
            penetration: 0,
            time_to_live: 0.0,
            hit_players: Vec::new(),
        }
    }
}

impl Projectile {
    pub fn equals(&self, other: &Self) -> bool {
        self.projectile_id == other.projectile_id
            && self.owner_id == other.owner_id
            && self.position.equals(&other.position)
            && self.velocity.equals(&other.velocity)
            && self.damage == other.damage
            && self.penetration == other.penetration
            && delta_pack::equals_float(self.time_to_live, other.time_to_live)
            && self.hit_players == other.hit_players
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.projectile_id);
        encoder.push_string(&self.owner_id);
        self.position.encode_into(encoder);
        self.velocity.encode_into(encoder);
        encoder.push_uint(self.damage);
        encoder.push_uint(self.penetration);
        encoder.push_float(self.time_to_live);
        encoder.push_array(&self.hit_players, |enc, item| enc.push_string(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.projectile_id == b.projectile_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.projectile_id, &b.projectile_id);
        }
        let changed = !(a.owner_id == b.owner_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.owner_id, &b.owner_id);
        }
        Position::encode_diff_into(&a.position, &b.position, encoder);
        Velocity::encode_diff_into(&a.velocity, &b.velocity, encoder);
        let changed = !(a.damage == b.damage);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.damage, b.damage);
        }
        let changed = !(a.penetration == b.penetration);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.penetration, b.penetration);
        }
        let changed = !(delta_pack::equals_float(a.time_to_live, b.time_to_live));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.time_to_live, b.time_to_live);
        }
        let changed = !(a.hit_players == b.hit_players);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.hit_players, &b.hit_players, |x, y| x == y, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            projectile_id: decoder.next_string(),
            owner_id: decoder.next_string(),
            position: Position::decode_from(decoder),
            velocity: Velocity::decode_from(decoder),
            damage: decoder.next_uint(),
            penetration: decoder.next_uint(),
            time_to_live: decoder.next_float(),
            hit_players: decoder.next_array(|dec| dec.next_string()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            projectile_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.projectile_id) } else { obj.projectile_id.clone() },
            owner_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.owner_id) } else { obj.owner_id.clone() },
            position: Position::decode_diff_from(&obj.position, decoder),
            velocity: Velocity::decode_diff_from(&obj.velocity, decoder),
            damage: if decoder.next_boolean() { decoder.next_uint_diff(obj.damage) } else { obj.damage.clone() },
            penetration: if decoder.next_boolean() { decoder.next_uint_diff(obj.penetration) } else { obj.penetration.clone() },
            time_to_live: if decoder.next_boolean() { decoder.next_float_diff(obj.time_to_live) } else { obj.time_to_live.clone() },
            hit_players: if decoder.next_boolean() { decoder.next_array_diff(&obj.hit_players, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.hit_players.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DroppedLoot {
    #[serde(rename = "lootId")]
    pub loot_id: String,
    pub position: Position,
    pub item: InventoryItem,
    #[serde(rename = "despawnTime")]
    pub despawn_time: f32,
}

impl Default for DroppedLoot {
    fn default() -> Self {
        Self {
            loot_id: String::new(),
            position: Position::default(),
            item: InventoryItem::default(),
            despawn_time: 0.0,
        }
    }
}

impl DroppedLoot {
    pub fn equals(&self, other: &Self) -> bool {
        self.loot_id == other.loot_id
            && self.position.equals(&other.position)
            && self.item.equals(&other.item)
            && delta_pack::equals_float(self.despawn_time, other.despawn_time)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.loot_id);
        self.position.encode_into(encoder);
        self.item.encode_into(encoder);
        encoder.push_float(self.despawn_time);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.loot_id == b.loot_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.loot_id, &b.loot_id);
        }
        Position::encode_diff_into(&a.position, &b.position, encoder);
        InventoryItem::encode_diff_into(&a.item, &b.item, encoder);
        let changed = !(delta_pack::equals_float(a.despawn_time, b.despawn_time));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.despawn_time, b.despawn_time);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            loot_id: decoder.next_string(),
            position: Position::decode_from(decoder),
            item: InventoryItem::decode_from(decoder),
            despawn_time: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            loot_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.loot_id) } else { obj.loot_id.clone() },
            position: Position::decode_diff_from(&obj.position, decoder),
            item: InventoryItem::decode_diff_from(&obj.item, decoder),
            despawn_time: if decoder.next_boolean() { decoder.next_float_diff(obj.despawn_time) } else { obj.despawn_time.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct WorldObject {
    #[serde(rename = "objectId")]
    pub object_id: String,
    #[serde(rename = "objectType")]
    pub object_type: String,
    pub position: Position,
    pub health: Option<u64>,
    #[serde(rename = "isDestroyed")]
    pub is_destroyed: bool,
    #[serde(rename = "isInteractable")]
    pub is_interactable: bool,
    #[serde(rename = "interactedBy")]
    pub interacted_by: Option<String>,
}

impl Default for WorldObject {
    fn default() -> Self {
        Self {
            object_id: String::new(),
            object_type: String::new(),
            position: Position::default(),
            health: None,
            is_destroyed: false,
            is_interactable: false,
            interacted_by: None,
        }
    }
}

impl WorldObject {
    pub fn equals(&self, other: &Self) -> bool {
        self.object_id == other.object_id
            && self.object_type == other.object_type
            && self.position.equals(&other.position)
            && self.health == other.health
            && self.is_destroyed == other.is_destroyed
            && self.is_interactable == other.is_interactable
            && self.interacted_by == other.interacted_by
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.object_id);
        encoder.push_string(&self.object_type);
        self.position.encode_into(encoder);
        encoder.push_optional(&self.health, |enc, &item| enc.push_uint(item));
        encoder.push_boolean(self.is_destroyed);
        encoder.push_boolean(self.is_interactable);
        encoder.push_optional(&self.interacted_by, |enc, item| enc.push_string(item));
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.object_id == b.object_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.object_id, &b.object_id);
        }
        let changed = !(a.object_type == b.object_type);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.object_type, &b.object_type);
        }
        Position::encode_diff_into(&a.position, &b.position, encoder);
        let changed = !(a.health == b.health);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.health, &b.health, |enc, &item| enc.push_uint(item), |enc, &a, &b| enc.push_uint_diff(a, b));
        }
        encoder.push_boolean_diff(a.is_destroyed, b.is_destroyed);
        encoder.push_boolean_diff(a.is_interactable, b.is_interactable);
        let changed = !(a.interacted_by == b.interacted_by);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.interacted_by, &b.interacted_by, |enc, item| enc.push_string(item), |enc, a, b| enc.push_string_diff(a, b));
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            object_id: decoder.next_string(),
            object_type: decoder.next_string(),
            position: Position::decode_from(decoder),
            health: decoder.next_optional(|dec| dec.next_uint()),
            is_destroyed: decoder.next_boolean(),
            is_interactable: decoder.next_boolean(),
            interacted_by: decoder.next_optional(|dec| dec.next_string()),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            object_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.object_id) } else { obj.object_id.clone() },
            object_type: if decoder.next_boolean() { decoder.next_string_diff(&obj.object_type) } else { obj.object_type.clone() },
            position: Position::decode_diff_from(&obj.position, decoder),
            health: if decoder.next_boolean() { decoder.next_optional_diff(&obj.health, |dec| dec.next_uint(), |dec, &a| dec.next_uint_diff(a)) } else { obj.health.clone() },
            is_destroyed: decoder.next_boolean_diff(obj.is_destroyed),
            is_interactable: decoder.next_boolean_diff(obj.is_interactable),
            interacted_by: if decoder.next_boolean() { decoder.next_optional_diff(&obj.interacted_by, |dec| dec.next_string(), |dec, a| dec.next_string_diff(a)) } else { obj.interacted_by.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MatchStats {
    #[serde(rename = "totalKills")]
    pub total_kills: u64,
    #[serde(rename = "totalDeaths")]
    pub total_deaths: u64,
    #[serde(rename = "totalDamageDealt")]
    pub total_damage_dealt: u64,
    #[serde(rename = "totalHealingDone")]
    pub total_healing_done: u64,
    #[serde(rename = "longestKillStreak")]
    pub longest_kill_streak: u64,
    #[serde(rename = "matchDuration")]
    pub match_duration: f32,
}

impl Default for MatchStats {
    fn default() -> Self {
        Self {
            total_kills: 0,
            total_deaths: 0,
            total_damage_dealt: 0,
            total_healing_done: 0,
            longest_kill_streak: 0,
            match_duration: 0.0,
        }
    }
}

impl MatchStats {
    pub fn equals(&self, other: &Self) -> bool {
        self.total_kills == other.total_kills
            && self.total_deaths == other.total_deaths
            && self.total_damage_dealt == other.total_damage_dealt
            && self.total_healing_done == other.total_healing_done
            && self.longest_kill_streak == other.longest_kill_streak
            && delta_pack::equals_float(self.match_duration, other.match_duration)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_uint(self.total_kills);
        encoder.push_uint(self.total_deaths);
        encoder.push_uint(self.total_damage_dealt);
        encoder.push_uint(self.total_healing_done);
        encoder.push_uint(self.longest_kill_streak);
        encoder.push_float(self.match_duration);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.total_kills == b.total_kills);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.total_kills, b.total_kills);
        }
        let changed = !(a.total_deaths == b.total_deaths);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.total_deaths, b.total_deaths);
        }
        let changed = !(a.total_damage_dealt == b.total_damage_dealt);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.total_damage_dealt, b.total_damage_dealt);
        }
        let changed = !(a.total_healing_done == b.total_healing_done);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.total_healing_done, b.total_healing_done);
        }
        let changed = !(a.longest_kill_streak == b.longest_kill_streak);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.longest_kill_streak, b.longest_kill_streak);
        }
        let changed = !(delta_pack::equals_float(a.match_duration, b.match_duration));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.match_duration, b.match_duration);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            total_kills: decoder.next_uint(),
            total_deaths: decoder.next_uint(),
            total_damage_dealt: decoder.next_uint(),
            total_healing_done: decoder.next_uint(),
            longest_kill_streak: decoder.next_uint(),
            match_duration: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            total_kills: if decoder.next_boolean() { decoder.next_uint_diff(obj.total_kills) } else { obj.total_kills.clone() },
            total_deaths: if decoder.next_boolean() { decoder.next_uint_diff(obj.total_deaths) } else { obj.total_deaths.clone() },
            total_damage_dealt: if decoder.next_boolean() { decoder.next_uint_diff(obj.total_damage_dealt) } else { obj.total_damage_dealt.clone() },
            total_healing_done: if decoder.next_boolean() { decoder.next_uint_diff(obj.total_healing_done) } else { obj.total_healing_done.clone() },
            longest_kill_streak: if decoder.next_boolean() { decoder.next_uint_diff(obj.longest_kill_streak) } else { obj.longest_kill_streak.clone() },
            match_duration: if decoder.next_boolean() { decoder.next_float_diff(obj.match_duration) } else { obj.match_duration.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TeamScore {
    pub team: Team,
    pub score: u64,
    pub kills: u64,
    #[serde(rename = "objectivesCaptured")]
    pub objectives_captured: u64,
}

impl Default for TeamScore {
    fn default() -> Self {
        Self {
            team: Team::default(),
            score: 0,
            kills: 0,
            objectives_captured: 0,
        }
    }
}

impl TeamScore {
    pub fn equals(&self, other: &Self) -> bool {
        self.team == other.team
            && self.score == other.score
            && self.kills == other.kills
            && self.objectives_captured == other.objectives_captured
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_enum(self.team.to_u32(), 2);
        encoder.push_uint(self.score);
        encoder.push_uint(self.kills);
        encoder.push_uint(self.objectives_captured);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.team == b.team);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.team.to_u32(), b.team.to_u32(), 2);
        }
        let changed = !(a.score == b.score);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.score, b.score);
        }
        let changed = !(a.kills == b.kills);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.kills, b.kills);
        }
        let changed = !(a.objectives_captured == b.objectives_captured);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.objectives_captured, b.objectives_captured);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            team: Team::from_u32(decoder.next_enum(2)),
            score: decoder.next_uint(),
            kills: decoder.next_uint(),
            objectives_captured: decoder.next_uint(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            team: if decoder.next_boolean() { Team::from_u32(decoder.next_enum_diff(obj.team.to_u32(), 2)) } else { obj.team.clone() },
            score: if decoder.next_boolean() { decoder.next_uint_diff(obj.score) } else { obj.score.clone() },
            kills: if decoder.next_boolean() { decoder.next_uint_diff(obj.kills) } else { obj.kills.clone() },
            objectives_captured: if decoder.next_boolean() { decoder.next_uint_diff(obj.objectives_captured) } else { obj.objectives_captured.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GameSettings {
    #[serde(rename = "maxPlayers")]
    pub max_players: u64,
    #[serde(rename = "friendlyFire")]
    pub friendly_fire: bool,
    #[serde(rename = "respawnDelay")]
    pub respawn_delay: f32,
    #[serde(rename = "roundTimeLimit")]
    pub round_time_limit: u64,
    #[serde(rename = "startingGold")]
    pub starting_gold: u64,
    #[serde(rename = "gravityMultiplier")]
    pub gravity_multiplier: f32,
}

impl Default for GameSettings {
    fn default() -> Self {
        Self {
            max_players: 0,
            friendly_fire: false,
            respawn_delay: 0.0,
            round_time_limit: 0,
            starting_gold: 0,
            gravity_multiplier: 0.0,
        }
    }
}

impl GameSettings {
    pub fn equals(&self, other: &Self) -> bool {
        self.max_players == other.max_players
            && self.friendly_fire == other.friendly_fire
            && delta_pack::equals_float(self.respawn_delay, other.respawn_delay)
            && self.round_time_limit == other.round_time_limit
            && self.starting_gold == other.starting_gold
            && delta_pack::equals_float(self.gravity_multiplier, other.gravity_multiplier)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_uint(self.max_players);
        encoder.push_boolean(self.friendly_fire);
        encoder.push_float(self.respawn_delay);
        encoder.push_uint(self.round_time_limit);
        encoder.push_uint(self.starting_gold);
        encoder.push_float(self.gravity_multiplier);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.max_players == b.max_players);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.max_players, b.max_players);
        }
        encoder.push_boolean_diff(a.friendly_fire, b.friendly_fire);
        let changed = !(delta_pack::equals_float(a.respawn_delay, b.respawn_delay));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.respawn_delay, b.respawn_delay);
        }
        let changed = !(a.round_time_limit == b.round_time_limit);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.round_time_limit, b.round_time_limit);
        }
        let changed = !(a.starting_gold == b.starting_gold);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.starting_gold, b.starting_gold);
        }
        let changed = !(delta_pack::equals_float(a.gravity_multiplier, b.gravity_multiplier));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.gravity_multiplier, b.gravity_multiplier);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            max_players: decoder.next_uint(),
            friendly_fire: decoder.next_boolean(),
            respawn_delay: decoder.next_float(),
            round_time_limit: decoder.next_uint(),
            starting_gold: decoder.next_uint(),
            gravity_multiplier: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            max_players: if decoder.next_boolean() { decoder.next_uint_diff(obj.max_players) } else { obj.max_players.clone() },
            friendly_fire: decoder.next_boolean_diff(obj.friendly_fire),
            respawn_delay: if decoder.next_boolean() { decoder.next_float_diff(obj.respawn_delay) } else { obj.respawn_delay.clone() },
            round_time_limit: if decoder.next_boolean() { decoder.next_uint_diff(obj.round_time_limit) } else { obj.round_time_limit.clone() },
            starting_gold: if decoder.next_boolean() { decoder.next_uint_diff(obj.starting_gold) } else { obj.starting_gold.clone() },
            gravity_multiplier: if decoder.next_boolean() { decoder.next_float_diff(obj.gravity_multiplier) } else { obj.gravity_multiplier.clone() },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GameState {
    #[serde(rename = "gameId")]
    pub game_id: String,
    #[serde(rename = "serverTime")]
    pub server_time: f32,
    #[serde(rename = "tickNumber")]
    pub tick_number: u64,
    pub round: u64,
    pub phase: String,
    #[serde(rename = "timeRemaining")]
    pub time_remaining: f32,
    pub players: HashMap<String, Player>,
    pub enemies: HashMap<String, Enemy>,
    pub projectiles: HashMap<String, Projectile>,
    #[serde(rename = "droppedLoot")]
    pub dropped_loot: HashMap<String, DroppedLoot>,
    #[serde(rename = "worldObjects")]
    pub world_objects: HashMap<String, WorldObject>,
    #[serde(rename = "teamScores")]
    pub team_scores: Vec<TeamScore>,
    #[serde(rename = "matchStats")]
    pub match_stats: MatchStats,
    pub settings: GameSettings,
    #[serde(rename = "winningTeam")]
    pub winning_team: Option<Team>,
    #[serde(rename = "mapName")]
    pub map_name: String,
    #[serde(rename = "weatherIntensity")]
    pub weather_intensity: f32,
}

impl Default for GameState {
    fn default() -> Self {
        Self {
            game_id: String::new(),
            server_time: 0.0,
            tick_number: 0,
            round: 0,
            phase: String::new(),
            time_remaining: 0.0,
            players: HashMap::new(),
            enemies: HashMap::new(),
            projectiles: HashMap::new(),
            dropped_loot: HashMap::new(),
            world_objects: HashMap::new(),
            team_scores: Vec::new(),
            match_stats: MatchStats::default(),
            settings: GameSettings::default(),
            winning_team: None,
            map_name: String::new(),
            weather_intensity: 0.0,
        }
    }
}

impl GameState {
    pub fn equals(&self, other: &Self) -> bool {
        self.game_id == other.game_id
            && delta_pack::equals_float(self.server_time, other.server_time)
            && self.tick_number == other.tick_number
            && self.round == other.round
            && self.phase == other.phase
            && delta_pack::equals_float(self.time_remaining, other.time_remaining)
            && delta_pack::equals_record(&self.players, &other.players, |x, y| x.equals(y))
            && delta_pack::equals_record(&self.enemies, &other.enemies, |x, y| x.equals(y))
            && delta_pack::equals_record(&self.projectiles, &other.projectiles, |x, y| x.equals(y))
            && delta_pack::equals_record(&self.dropped_loot, &other.dropped_loot, |x, y| x.equals(y))
            && delta_pack::equals_record(&self.world_objects, &other.world_objects, |x, y| x.equals(y))
            && delta_pack::equals_array(&self.team_scores, &other.team_scores, |x, y| x.equals(y))
            && self.match_stats.equals(&other.match_stats)
            && self.settings.equals(&other.settings)
            && self.winning_team == other.winning_team
            && self.map_name == other.map_name
            && delta_pack::equals_float(self.weather_intensity, other.weather_intensity)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.game_id);
        encoder.push_float(self.server_time);
        encoder.push_uint(self.tick_number);
        encoder.push_uint(self.round);
        encoder.push_string(&self.phase);
        encoder.push_float(self.time_remaining);
        encoder.push_record(&self.players, |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc));
        encoder.push_record(&self.enemies, |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc));
        encoder.push_record(&self.projectiles, |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc));
        encoder.push_record(&self.dropped_loot, |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc));
        encoder.push_record(&self.world_objects, |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc));
        encoder.push_array(&self.team_scores, |enc, item| item.encode_into(enc));
        self.match_stats.encode_into(encoder);
        self.settings.encode_into(encoder);
        encoder.push_optional(&self.winning_team, |enc, &item| enc.push_enum(item.to_u32(), 2));
        encoder.push_string(&self.map_name);
        encoder.push_float(self.weather_intensity);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.game_id == b.game_id);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.game_id, &b.game_id);
        }
        let changed = !(delta_pack::equals_float(a.server_time, b.server_time));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.server_time, b.server_time);
        }
        let changed = !(a.tick_number == b.tick_number);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.tick_number, b.tick_number);
        }
        let changed = !(a.round == b.round);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_uint_diff(a.round, b.round);
        }
        let changed = !(a.phase == b.phase);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.phase, &b.phase);
        }
        let changed = !(delta_pack::equals_float(a.time_remaining, b.time_remaining));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.time_remaining, b.time_remaining);
        }
        let changed = !(delta_pack::equals_record(&a.players, &b.players, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.players, &b.players, |x, y| x.equals(y), |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc), |enc, a, b| Player::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_record(&a.enemies, &b.enemies, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.enemies, &b.enemies, |x, y| x.equals(y), |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc), |enc, a, b| Enemy::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_record(&a.projectiles, &b.projectiles, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.projectiles, &b.projectiles, |x, y| x.equals(y), |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc), |enc, a, b| Projectile::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_record(&a.dropped_loot, &b.dropped_loot, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.dropped_loot, &b.dropped_loot, |x, y| x.equals(y), |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc), |enc, a, b| DroppedLoot::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_record(&a.world_objects, &b.world_objects, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_record_diff(&a.world_objects, &b.world_objects, |x, y| x.equals(y), |enc, item| enc.push_string(item), |enc, item| item.encode_into(enc), |enc, a, b| WorldObject::encode_diff_fields_into(a, b, enc));
        }
        let changed = !(delta_pack::equals_array(&a.team_scores, &b.team_scores, |x, y| x.equals(y)));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(&a.team_scores, &b.team_scores, |x, y| x.equals(y), |enc, item| item.encode_into(enc), |enc, a, b| TeamScore::encode_diff_fields_into(a, b, enc));
        }
        MatchStats::encode_diff_into(&a.match_stats, &b.match_stats, encoder);
        GameSettings::encode_diff_into(&a.settings, &b.settings, encoder);
        let changed = !(a.winning_team == b.winning_team);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_optional_diff(&a.winning_team, &b.winning_team, |enc, &item| enc.push_enum(item.to_u32(), 2), |enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), 2));
        }
        let changed = !(a.map_name == b.map_name);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.map_name, &b.map_name);
        }
        let changed = !(delta_pack::equals_float(a.weather_intensity, b.weather_intensity));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.weather_intensity, b.weather_intensity);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            game_id: decoder.next_string(),
            server_time: decoder.next_float(),
            tick_number: decoder.next_uint(),
            round: decoder.next_uint(),
            phase: decoder.next_string(),
            time_remaining: decoder.next_float(),
            players: decoder.next_record(|dec| dec.next_string(), |dec| Player::decode_from(dec)),
            enemies: decoder.next_record(|dec| dec.next_string(), |dec| Enemy::decode_from(dec)),
            projectiles: decoder.next_record(|dec| dec.next_string(), |dec| Projectile::decode_from(dec)),
            dropped_loot: decoder.next_record(|dec| dec.next_string(), |dec| DroppedLoot::decode_from(dec)),
            world_objects: decoder.next_record(|dec| dec.next_string(), |dec| WorldObject::decode_from(dec)),
            team_scores: decoder.next_array(|dec| TeamScore::decode_from(dec)),
            match_stats: MatchStats::decode_from(decoder),
            settings: GameSettings::decode_from(decoder),
            winning_team: decoder.next_optional(|dec| Team::from_u32(dec.next_enum(2))),
            map_name: decoder.next_string(),
            weather_intensity: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            game_id: if decoder.next_boolean() { decoder.next_string_diff(&obj.game_id) } else { obj.game_id.clone() },
            server_time: if decoder.next_boolean() { decoder.next_float_diff(obj.server_time) } else { obj.server_time.clone() },
            tick_number: if decoder.next_boolean() { decoder.next_uint_diff(obj.tick_number) } else { obj.tick_number.clone() },
            round: if decoder.next_boolean() { decoder.next_uint_diff(obj.round) } else { obj.round.clone() },
            phase: if decoder.next_boolean() { decoder.next_string_diff(&obj.phase) } else { obj.phase.clone() },
            time_remaining: if decoder.next_boolean() { decoder.next_float_diff(obj.time_remaining) } else { obj.time_remaining.clone() },
            players: if decoder.next_boolean() { decoder.next_record_diff(&obj.players, |dec| dec.next_string(), |dec| Player::decode_from(dec), |dec, a| Player::decode_diff_fields_from(a, dec)) } else { obj.players.clone() },
            enemies: if decoder.next_boolean() { decoder.next_record_diff(&obj.enemies, |dec| dec.next_string(), |dec| Enemy::decode_from(dec), |dec, a| Enemy::decode_diff_fields_from(a, dec)) } else { obj.enemies.clone() },
            projectiles: if decoder.next_boolean() { decoder.next_record_diff(&obj.projectiles, |dec| dec.next_string(), |dec| Projectile::decode_from(dec), |dec, a| Projectile::decode_diff_fields_from(a, dec)) } else { obj.projectiles.clone() },
            dropped_loot: if decoder.next_boolean() { decoder.next_record_diff(&obj.dropped_loot, |dec| dec.next_string(), |dec| DroppedLoot::decode_from(dec), |dec, a| DroppedLoot::decode_diff_fields_from(a, dec)) } else { obj.dropped_loot.clone() },
            world_objects: if decoder.next_boolean() { decoder.next_record_diff(&obj.world_objects, |dec| dec.next_string(), |dec| WorldObject::decode_from(dec), |dec, a| WorldObject::decode_diff_fields_from(a, dec)) } else { obj.world_objects.clone() },
            team_scores: if decoder.next_boolean() { decoder.next_array_diff(&obj.team_scores, |dec| TeamScore::decode_from(dec), |dec, a| TeamScore::decode_diff_fields_from(a, dec)) } else { obj.team_scores.clone() },
            match_stats: MatchStats::decode_diff_from(&obj.match_stats, decoder),
            settings: GameSettings::decode_diff_from(&obj.settings, decoder),
            winning_team: if decoder.next_boolean() { decoder.next_optional_diff(&obj.winning_team, |dec| Team::from_u32(dec.next_enum(2)), |dec, &a| Team::from_u32(dec.next_enum_diff(a.to_u32(), 2))) } else { obj.winning_team.clone() },
            map_name: if decoder.next_boolean() { decoder.next_string_diff(&obj.map_name) } else { obj.map_name.clone() },
            weather_intensity: if decoder.next_boolean() { decoder.next_float_diff(obj.weather_intensity) } else { obj.weather_intensity.clone() },
        }
    }
}
