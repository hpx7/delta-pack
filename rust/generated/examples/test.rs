// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Enum {
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
}

impl Enum {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => Enum::ONE,
            1 => Enum::TWO,
            2 => Enum::THREE,
            3 => Enum::FOUR,
            4 => Enum::FIVE,
            _ => panic!("Invalid Enum value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            Enum::ONE => 0,
            Enum::TWO => 1,
            Enum::THREE => 2,
            Enum::FOUR => 3,
            Enum::FIVE => 4,
        }
    }
}

impl Default for Enum {
    fn default() -> Self {
        Enum::ONE
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct InnerInner {
    pub long: i64,
    #[serde(rename = "enum")]
    pub enum_: Enum,
    pub sint32: i64,
}

impl Default for InnerInner {
    fn default() -> Self {
        Self {
            long: 0,
            enum_: Enum::default(),
            sint32: 0,
        }
    }
}

impl InnerInner {
    pub fn equals(&self, other: &Self) -> bool {
        self.long == other.long && self.enum_ == other.enum_ && self.sint32 == other.sint32
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_int(self.long);
        encoder.push_enum(self.enum_.to_u32(), 3);
        encoder.push_int(self.sint32);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.long == b.long);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.long, b.long);
        }
        let changed = !(a.enum_ == b.enum_);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_enum_diff(a.enum_.to_u32(), b.enum_.to_u32(), 3);
        }
        let changed = !(a.sint32 == b.sint32);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.sint32, b.sint32);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            long: decoder.next_int(),
            enum_: Enum::from_u32(decoder.next_enum(3)),
            sint32: decoder.next_int(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            long: if decoder.next_boolean() {
                decoder.next_int_diff(obj.long)
            } else {
                obj.long.clone()
            },
            enum_: if decoder.next_boolean() {
                Enum::from_u32(decoder.next_enum_diff(obj.enum_.to_u32(), 3))
            } else {
                obj.enum_.clone()
            },
            sint32: if decoder.next_boolean() {
                decoder.next_int_diff(obj.sint32)
            } else {
                obj.sint32.clone()
            },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Outer {
    #[serde(rename = "bool")]
    pub bool_: Vec<bool>,
    pub double: f32,
}

impl Default for Outer {
    fn default() -> Self {
        Self {
            bool_: Vec::new(),
            double: 0.0,
        }
    }
}

impl Outer {
    pub fn equals(&self, other: &Self) -> bool {
        self.bool_ == other.bool_ && delta_pack::equals_float(self.double, other.double)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_array(&self.bool_, |enc, &item| enc.push_boolean(item));
        encoder.push_float(self.double);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.bool_ == b.bool_);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_array_diff(
                &a.bool_,
                &b.bool_,
                |x, y| x == y,
                |enc, &item| enc.push_boolean(item),
                |enc, &a, &b| enc.push_boolean_diff(a, b),
            );
        }
        let changed = !(delta_pack::equals_float(a.double, b.double));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.double, b.double);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            bool_: decoder.next_array(|dec| dec.next_boolean()),
            double: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            bool_: if decoder.next_boolean() {
                decoder.next_array_diff(
                    &obj.bool_,
                    |dec| dec.next_boolean(),
                    |dec, &a| dec.next_boolean_diff(a),
                )
            } else {
                obj.bool_.clone()
            },
            double: if decoder.next_boolean() {
                decoder.next_float_diff(obj.double)
            } else {
                obj.double.clone()
            },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Inner {
    pub int32: i64,
    #[serde(rename = "innerInner")]
    pub inner_inner: InnerInner,
    pub outer: Outer,
}

impl Default for Inner {
    fn default() -> Self {
        Self {
            int32: 0,
            inner_inner: InnerInner::default(),
            outer: Outer::default(),
        }
    }
}

impl Inner {
    pub fn equals(&self, other: &Self) -> bool {
        self.int32 == other.int32
            && self.inner_inner.equals(&other.inner_inner)
            && self.outer.equals(&other.outer)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_int(self.int32);
        self.inner_inner.encode_into(encoder);
        self.outer.encode_into(encoder);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.int32 == b.int32);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.int32, b.int32);
        }
        InnerInner::encode_diff_into(&a.inner_inner, &b.inner_inner, encoder);
        Outer::encode_diff_into(&a.outer, &b.outer, encoder);
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            int32: decoder.next_int(),
            inner_inner: InnerInner::decode_from(decoder),
            outer: Outer::decode_from(decoder),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            int32: if decoder.next_boolean() {
                decoder.next_int_diff(obj.int32)
            } else {
                obj.int32.clone()
            },
            inner_inner: InnerInner::decode_diff_from(&obj.inner_inner, decoder),
            outer: Outer::decode_diff_from(&obj.outer, decoder),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Test {
    pub string: String,
    pub uint32: i64,
    pub inner: Inner,
    pub float: f32,
}

impl Default for Test {
    fn default() -> Self {
        Self {
            string: String::new(),
            uint32: 0,
            inner: Inner::default(),
            float: 0.0,
        }
    }
}

impl Test {
    pub fn equals(&self, other: &Self) -> bool {
        self.string == other.string
            && self.uint32 == other.uint32
            && self.inner.equals(&other.inner)
            && delta_pack::equals_float(self.float, other.float)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.string);
        encoder.push_int(self.uint32);
        self.inner.encode_into(encoder);
        encoder.push_float(self.float);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            Self::encode_diff_into(a, b, encoder);
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !a.equals(b);
        encoder.push_boolean(changed);
        if !changed {
            return;
        }
        Self::encode_diff_fields_into(a, b, encoder);
    }

    pub fn encode_diff_fields_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        let changed = !(a.string == b.string);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_string_diff(&a.string, &b.string);
        }
        let changed = !(a.uint32 == b.uint32);
        encoder.push_boolean(changed);
        if changed {
            encoder.push_int_diff(a.uint32, b.uint32);
        }
        Inner::encode_diff_into(&a.inner, &b.inner, encoder);
        let changed = !(delta_pack::equals_float(a.float, b.float));
        encoder.push_boolean(changed);
        if changed {
            encoder.push_float_diff(a.float, b.float);
        }
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            string: decoder.next_string(),
            uint32: decoder.next_int(),
            inner: Inner::decode_from(decoder),
            float: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| Self::decode_diff_from(obj, decoder))
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        let changed = decoder.next_boolean();
        if !changed {
            return obj.clone();
        }
        Self::decode_diff_fields_from(obj, decoder)
    }

    pub fn decode_diff_fields_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            string: if decoder.next_boolean() {
                decoder.next_string_diff(&obj.string)
            } else {
                obj.string.clone()
            },
            uint32: if decoder.next_boolean() {
                decoder.next_int_diff(obj.uint32)
            } else {
                obj.uint32.clone()
            },
            inner: Inner::decode_diff_from(&obj.inner, decoder),
            float: if decoder.next_boolean() {
                decoder.next_float_diff(obj.float)
            } else {
                obj.float.clone()
            },
        }
    }
}
