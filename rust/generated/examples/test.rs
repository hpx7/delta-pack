// Auto-generated by DeltaPack - do not edit
#![allow(dead_code, unused_imports, clippy::all)]

use delta_pack::{Decoder, Encoder};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Enum {
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
}

impl Enum {
    pub const NUM_BITS: u8 = 3;

    pub fn from_u32(val: u32) -> Self {
        match val {
            0 => Enum::ONE,
            1 => Enum::TWO,
            2 => Enum::THREE,
            3 => Enum::FOUR,
            4 => Enum::FIVE,
            _ => panic!("Invalid Enum value: {}", val),
        }
    }

    pub fn to_u32(self) -> u32 {
        match self {
            Enum::ONE => 0,
            Enum::TWO => 1,
            Enum::THREE => 2,
            Enum::FOUR => 3,
            Enum::FIVE => 4,
        }
    }
}

impl Default for Enum {
    fn default() -> Self {
        Enum::ONE
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct InnerInner {
    pub long: i64,
    #[serde(rename = "enum")]
    pub enum_: Enum,
    pub sint32: i64,
}

impl Default for InnerInner {
    fn default() -> Self {
        Self {
            long: 0,
            enum_: Enum::default(),
            sint32: 0,
        }
    }
}

impl InnerInner {
    pub fn equals(&self, other: &Self) -> bool {
        self.long == other.long && self.enum_ == other.enum_ && self.sint32 == other.sint32
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_int(self.long);
        encoder.push_enum(self.enum_.to_u32(), 3);
        encoder.push_int(self.sint32);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            encoder.push_object_diff(
                a,
                b,
                |x, y| x.equals(y),
                |enc| {
                    Self::encode_diff_into(a, b, enc);
                },
            );
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        encoder.push_field_diff(
            &a.long,
            &b.long,
            |x, y| x == y,
            |enc, &a, &b| enc.push_int_diff(a, b),
        );
        encoder.push_field_diff(
            &a.enum_,
            &b.enum_,
            |x, y| x == y,
            |enc, &a, &b| enc.push_enum_diff(a.to_u32(), b.to_u32(), 3),
        );
        encoder.push_field_diff(
            &a.sint32,
            &b.sint32,
            |x, y| x == y,
            |enc, &a, &b| enc.push_int_diff(a, b),
        );
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            long: decoder.next_int(),
            enum_: Enum::from_u32(decoder.next_enum(3)),
            sint32: decoder.next_int(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| {
            decoder.next_object_diff(obj, |dec| Self::decode_diff_from(obj, dec))
        })
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            long: decoder.next_field_diff(&obj.long, |dec, &a| dec.next_int_diff(a)),
            enum_: decoder.next_field_diff(&obj.enum_, |dec, &a| {
                Enum::from_u32(dec.next_enum_diff(a.to_u32(), 3))
            }),
            sint32: decoder.next_field_diff(&obj.sint32, |dec, &a| dec.next_int_diff(a)),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Outer {
    #[serde(rename = "bool")]
    pub bool_: Vec<bool>,
    pub double: f32,
}

impl Default for Outer {
    fn default() -> Self {
        Self {
            bool_: Vec::new(),
            double: 0.0,
        }
    }
}

impl Outer {
    pub fn equals(&self, other: &Self) -> bool {
        self.bool_ == other.bool_ && delta_pack::equals_float(self.double, other.double)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_array(&self.bool_, |enc, &item| enc.push_boolean(item));
        encoder.push_float(self.double);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            encoder.push_object_diff(
                a,
                b,
                |x, y| x.equals(y),
                |enc| {
                    Self::encode_diff_into(a, b, enc);
                },
            );
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        encoder.push_field_diff(
            &a.bool_,
            &b.bool_,
            |x, y| x == y,
            |enc, a, b| {
                enc.push_array_diff(
                    a,
                    b,
                    |x, y| x == y,
                    |enc, &item| enc.push_boolean(item),
                    |enc, &a, &b| enc.push_boolean_diff(a, b),
                )
            },
        );
        encoder.push_field_diff(
            &a.double,
            &b.double,
            |x, y| delta_pack::equals_float(*x, *y),
            |enc, &a, &b| enc.push_float_diff(a, b),
        );
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            bool_: decoder.next_array(|dec| dec.next_boolean()),
            double: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| {
            decoder.next_object_diff(obj, |dec| Self::decode_diff_from(obj, dec))
        })
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            bool_: decoder.next_field_diff(&obj.bool_, |dec, a| {
                dec.next_array_diff(
                    a,
                    |dec| dec.next_boolean(),
                    |dec, &a| dec.next_boolean_diff(a),
                )
            }),
            double: decoder.next_field_diff(&obj.double, |dec, &a| dec.next_float_diff(a)),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Inner {
    pub int32: i64,
    #[serde(rename = "innerInner")]
    pub inner_inner: InnerInner,
    pub outer: Outer,
}

impl Default for Inner {
    fn default() -> Self {
        Self {
            int32: 0,
            inner_inner: InnerInner::default(),
            outer: Outer::default(),
        }
    }
}

impl Inner {
    pub fn equals(&self, other: &Self) -> bool {
        self.int32 == other.int32
            && self.inner_inner.equals(&other.inner_inner)
            && self.outer.equals(&other.outer)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_int(self.int32);
        self.inner_inner.encode_into(encoder);
        self.outer.encode_into(encoder);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            encoder.push_object_diff(
                a,
                b,
                |x, y| x.equals(y),
                |enc| {
                    Self::encode_diff_into(a, b, enc);
                },
            );
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        encoder.push_field_diff(
            &a.int32,
            &b.int32,
            |x, y| x == y,
            |enc, &a, &b| enc.push_int_diff(a, b),
        );
        encoder.push_field_diff(
            &a.inner_inner,
            &b.inner_inner,
            |x, y| x.equals(y),
            |enc, a, b| InnerInner::encode_diff_into(a, b, enc),
        );
        encoder.push_field_diff(
            &a.outer,
            &b.outer,
            |x, y| x.equals(y),
            |enc, a, b| Outer::encode_diff_into(a, b, enc),
        );
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            int32: decoder.next_int(),
            inner_inner: InnerInner::decode_from(decoder),
            outer: Outer::decode_from(decoder),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| {
            decoder.next_object_diff(obj, |dec| Self::decode_diff_from(obj, dec))
        })
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            int32: decoder.next_field_diff(&obj.int32, |dec, &a| dec.next_int_diff(a)),
            inner_inner: decoder.next_field_diff(&obj.inner_inner, |dec, a| {
                InnerInner::decode_diff_from(a, dec)
            }),
            outer: decoder.next_field_diff(&obj.outer, |dec, a| Outer::decode_diff_from(a, dec)),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Test {
    pub string: String,
    pub uint32: i64,
    pub inner: Inner,
    pub float: f32,
}

impl Default for Test {
    fn default() -> Self {
        Self {
            string: String::new(),
            uint32: 0,
            inner: Inner::default(),
            float: 0.0,
        }
    }
}

impl Test {
    pub fn equals(&self, other: &Self) -> bool {
        self.string == other.string
            && self.uint32 == other.uint32
            && self.inner.equals(&other.inner)
            && delta_pack::equals_float(self.float, other.float)
    }

    pub fn encode(&self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            self.encode_into(encoder);
            encoder.finish()
        })
    }

    pub fn encode_into(&self, encoder: &mut Encoder) {
        encoder.push_string(&self.string);
        encoder.push_int(self.uint32);
        self.inner.encode_into(encoder);
        encoder.push_float(self.float);
    }

    pub fn encode_diff(a: &Self, b: &Self) -> Vec<u8> {
        Encoder::encode(|encoder| {
            encoder.push_object_diff(
                a,
                b,
                |x, y| x.equals(y),
                |enc| {
                    Self::encode_diff_into(a, b, enc);
                },
            );
            encoder.finish()
        })
    }

    pub fn encode_diff_into(a: &Self, b: &Self, encoder: &mut Encoder) {
        encoder.push_field_diff(
            &a.string,
            &b.string,
            |x, y| x == y,
            |enc, a, b| enc.push_string_diff(a, b),
        );
        encoder.push_field_diff(
            &a.uint32,
            &b.uint32,
            |x, y| x == y,
            |enc, &a, &b| enc.push_int_diff(a, b),
        );
        encoder.push_field_diff(
            &a.inner,
            &b.inner,
            |x, y| x.equals(y),
            |enc, a, b| Inner::encode_diff_into(a, b, enc),
        );
        encoder.push_field_diff(
            &a.float,
            &b.float,
            |x, y| delta_pack::equals_float(*x, *y),
            |enc, &a, &b| enc.push_float_diff(a, b),
        );
    }

    pub fn decode(buf: &[u8]) -> Self {
        Decoder::decode(buf, |decoder| Self::decode_from(decoder))
    }

    pub fn decode_from(decoder: &mut Decoder) -> Self {
        Self {
            string: decoder.next_string(),
            uint32: decoder.next_int(),
            inner: Inner::decode_from(decoder),
            float: decoder.next_float(),
        }
    }

    pub fn decode_diff(obj: &Self, diff: &[u8]) -> Self {
        Decoder::decode(diff, |decoder| {
            decoder.next_object_diff(obj, |dec| Self::decode_diff_from(obj, dec))
        })
    }

    pub fn decode_diff_from(obj: &Self, decoder: &mut Decoder) -> Self {
        Self {
            string: decoder.next_field_diff(&obj.string, |dec, a| dec.next_string_diff(a)),
            uint32: decoder.next_field_diff(&obj.uint32, |dec, &a| dec.next_int_diff(a)),
            inner: decoder.next_field_diff(&obj.inner, |dec, a| Inner::decode_diff_from(a, dec)),
            float: decoder.next_field_diff(&obj.float, |dec, &a| dec.next_float_diff(a)),
        }
    }
}
